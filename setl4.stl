
*   Copyright 2017, David Shields
*   Licensed under the MIT license.

    &stlimit = 40000
*   TODO

*# SETL4 - An Implementation of SETL Written in SPITBOL


*## What is SPITBOL?

*   SNOBOL is a general purpose programming language with special emphasis
*   on processing strings and text that was developed at Bell Labs in the
*   1960's by a team led by Ralph Griswold. The final version was called SNOBOL4.

*   Macro SPITBOL, or SPITBOL, is a very efficient implementation of SNOBOL4.
*   Created by Robert B. K. Dewar and Ken Belcher in 1969, SPITBOL/360
*   was written in IBM/360 assembly language, in a style Dewar termed
*   "aggressive assembly." That is, using every trick in the book to write
*   the fastest, most compact, code possible.
*
*   For example, SNOBOL4 requires maintaining a count of the number of
*   statements executed and the ability to stop execution when a specified
*   number of statements have been executed.  SPITBOL/360 does this by
*   computing an unnormalized floating point constant such that successive
*   increments of it result in floating point overflow when the limit is reached.

*   Dewar and Belcher also wrote Realia COBOL, a COBOL compiler for Intel/x86
*   written in COBOL. It produced very efficient code, better code than,
*   for example, that produced by IBM's product COBOL compiler.

*   Dewar ported SPITBOL/360 to several machines. Dewar joined the faculty
*   of the Courant Institute of Mathematical Sciences (CIMS) of New York
*   University (NYU) as a Professor in the early 1970's. In 1973,
*   while working with Anthony P. "Tony" McCann of Leeds University,
*   Dewar created Minimal, a portable assembly language. Dewar and
*   McCann then rewrote SPITBOL in Minimal, resulting in Macro SPITBOL,
*   or SPITBOL. The implementation has proved very stable, with only
*   minor changes in the last several decades.

*   Macro SPITBOL is remarkably small. The code consists of about 28,000
*   lines: 2000 lines of comments defining Minimal, 5000 lines of constant/data
*   declarations, and 21,000 lines of code.  Every line of code has a comment.
*   The executable for x86 Linux is less than 150 kilobytes.

*   SPITBOL was implemented for many machines and operating systems by
*   a small team that included Steve Duff, Mark Emmer, Bob Goldberg, and Dave Shields:
*   ICL 1900, Univac, CDC 6600, IBM PC, Apple Macintosh, SUN Solaris Sparc,
*   Microsoft (DOS/NT/Windows), Intel x86_64 (Unix/Linux), and x86_64 Apple iOS.
*   Special credit is due Mark Emmer, who led the project from the mid 1980's
*   to 2009. Dave Shields has maintained SPITBOL since then.

*   SETL4 requires a modified version of standard SPITBOL called BOL4.
*   BOL4 differs from standard SPITBOL as follows:
*
*-  There is no automatic case folding. In standard SPITBOL the names 'x' and 'X' are the same;
*   they are different in BOL4.
*-  The default case is lower case.
*-  The function _set()_ has been renamed to _zet_, so that _set_ can be used as an identifier.
*-  The default value of _&anchor_ is 1. The default value of _&trim_ is 1.

*   The file `bin/setl4' provided as part of the distribution is the executable for _spitbol4_.

*## What is SETL?

*   SETL (SET Language)  is  a programming language with  finite sets as
*   the fundamental data type. It was created by Jacob T. "Jack" Schwartz
*   of the Courant Institute of Mathematical Sciences (CIMS) of New York
*   University (NYU).

*   Jack founded the SETL project in 1970. It was later funded by two
*   five-year grants from the Office of Naval Research.

*   SETL was used to write NYU Ada/Ed, the first validated Ada compiler.
*   Devloped on the DEC Vax 11/780, Ada/Ed was ported to the IBM PC (DOS)
*   by a team led by Dave Shields.


*## Why the name SETL4?

*   The SETL Project produced three implementations of SETL. The first was
*   written by Dave Shields in BALM, a language developed by Prof. Malcom
*   Harrison of CIMS, the second by Henry S. "Hank" Warren in PL/I while on
*   leave from IBM, and the third by Robert B. K. Dewar and Art Grand in LITTLE,
*   a low-level implementation language developed at CIMS.

*   SETL4 is the fourth implementation of SETL produced during the course of
*   the SETL Project.  Dave Shields wrote the first implementation. This was
*   followed by two more implementations. This is the fourth implementation
*   written by a member of the SETL project,  hence the name SETL4.


*## Brief Introduction to SETL4

*   SETL4 extends SPITBOL by adding the datatype _set_ to represent finite sets.

*   A set is a collection of distinct elements: for example,  _{a,b,c}_ is a set,
*   as is _{a,b,c,a}_; however, _{a,b,c,a}_ has only three elements, and is
*   equal to _{a,b,c}_.

*   For example, the folowing SETL4 expression determines if the integer _P_ is prime:

*           !exists(|'int 2 P' @ 'multiple(P,this)')

*   where _multiple(a,b)_ is true if and only if _a_ is a multiple of _b_.

*## Sets in SETL4

*   SETL4 provides several kinds of sets.

*   Sets of kind 'set' are a collection of distinct members.

*   Sets of kind 'map' consist of a series or ordered pairs,
*   called entries. The first element of an entry is the key,
*   and the second is the value.  No two entries in the map can
*   have the same key but different values.

*   Sets of kind 'iterator' consist of  integers of the form
*```
*   low, low + step, ... high
*```

*   or

*```
*   high, high - step ... low
*```

*   If only _low_ is specified, then the iteator is interpreted as 'iterator 1 low'.
*   For example, 'iterator 100' is the set 1, 2, ... 100.
*   and 'iterator 5 25 5' is the set {5 10 15 20 25}; where
*   iteration over the iterator will go in order 5, 10 ... 25.
*   'iterator 25 5 -5' is the same set; but iteration will
*   go in the order 25,20 ... 5.
*
*   If _high_ is less than _low_, then a negative step is undersood,
*   even if it is given as a positive value. For example, both
*   `iter 25 5 -5` and `iter 25 5 5' go in order "25, 20 ... 1"

*   Iterators support efficient iteration, but they provide only
*   the operations of iteration and membership; you cannot
*   add or remove an element from an iterator.

*   Sets of kind 'integer' are intended or sets of integers
*   containing many elements. See below for more details.

*   A sequence is a map defined on a set of consecutive positive integers.
*   For example 'sequence 5' is a map defined on 1, 2, ... 5.

*   Sequences are represented in the same way as a map. They differ from a map only
*   in that iteration over a sequence returns the values of the sequence, not the
*   instances of _entry_ that are returned when iterating over a map.

*   A tuple is an sequence of elements. Tuples differ from sequences in that,
*   when they are listed using the _show_ function, the indices of the
*   elements are are not listed if there are fewer than ten elements.

*   By convention, the kinds are writtten 'int', 'iter', 'map', 'seq', 'set', and 'tup'.


*## Set Data Type

*   A set is a collection unequall objects, and is represented in SETL4 by the datatype _set_:

    data('set(set.kind,set.iter,set.index,set.key,set.size,'
.   'set.block,set.blocks,set.offset,set.str)')

*   where

*- _set.index_         SPITBOL table used to map the integer id assigned each element to the value of the element.
*It is needed to support iteration.

*- _set.iter_ iterator for controlling iteration over the set.

*- _set.key_  SPITBOL table mapping set elements to index entries.

*- _set.kind_
*is the kind of the set, one of 'int', 'iter', 'map', 'seq', 'set', or 'tuple'.
*The kind is  specified when the set is created.
*The default kind is 'set'.

*- _set.size_ the current number of members.

*- _set.str_           is used for sets of kind 'int'


*   The following fields are used only for sets of kind 'int':

*- _set.block_         block

*- _set.blocks_        number of blocks

*- _set.offset_        offset within block corresponding to a given integer

* _set.str_           used to update the current block's membersip string


*   New elements in the set are assigned an integer id.
*   The table _set.index_ maps the id to a key;
*   it is used to iterate over the set.
*   The table _set.key_ maps a key to its associated value;
*   it is used to retrieve element values.

*## Sets of integers

*   SETL4 sets of kind _integers' provide an efficient implementation of a set with
*   many non-negative integers, such as  a set with more than a million integers.
*
*   The set is represented by a table of strings, each with  _setl4.config.int_ characters,
*   so that the first block represents the integers `0 .. _setl4_config.int_ -1 and so forth.
*   Addition to  the set is done by setting the appropriate character in a block to '+'.
*   New blocks are allocated only when necesary.

*   The SPITBOL function BREAK is used to find the next element
*   in the set when iterating over the set.

*## Ordered Pairs

*   In set theory, sets are not ordered. The set _{a,b}_ is the same as (equal to)
*   the set _{b,a}_.

*   Although sets are not ordered, sets can be used to define an ordered pair:

    data('pair(first,second)')

*   by defining _pair(a,b)_ to be
*
*       _{a,{a,b}}_
*
*   It is easy to prove that, given this definition, _pair(a,b)_ is equal
*   to _pair(c,d)_ if and only if _a_ is equal to _c_ and _b_ is equal to _d_.


*## Maps

*   A map defined on a finite set is a set of ordered pairs,
*   or entries, that define a relation between the first element of an entry,
*   its _key_, and the second element of the entry, the value of the map for _key_.

    data('entry(key,value)')

*   A set of ordered pairs is a map if and only if there do not exist two entries
*   _entry(a,b)_ and _entry(c,d)_ such that _a_ is equal to _c_ and _b_ is not equal to _d_.
*   For example, the map defined by the set _{[one,1],[2,two],[one,1]}_ is valid, but
*   one cannot define a map based on the set _{[one,1],[2,two],[one,3]}_.

*   However, SETL4 does allow the use of a set of pairs that would not
*   be allowed in stanard set theory to define a map. If two of more pairs
*   have the same first value, the the last such pair encountered defines the
*   value to be used. For exampe, the set _{entry(one,1),entry(2,two),entry(one,3)}_ produces
*   the same map as _{entry(one,3),entry(2,two)}_.

*   Though you can use _entry to give a key and its associated value, the
*   preferred convention is separate a key and its value with a colon.
*   allows you to write "key:value," so that
*```
*       new('map' one:1 two:2 three:3')

*```
*   instead of

*```
*       new('map' entry('one',1) ' ' entry('two',2) ' ' entry('three',3) )
*```

*   Though in set theory, maps are defined in terms of sets, in the SETL4
*   implementation, sets are represented are maps, by mapping each element
*   to itself. For example, the set _{a,b,c}_ is kept as the map: {a:a,b:b,c:c}.

*   SETL4 supports adding entries to a set of kind _map_ by using the
*   key and value in the entry to define the value of the map for _key(entry)_
*   to be _value(entry)_.

*   The SPITBOL datatype TABLE provides the machinery to implement maps.
*   SPITBOL provides no way to determine the number of entries in a table
*   other than converting the map to an array. This is the only way in
*   SPITBOL to iterate over a SPITBOL table.

*   For this reason, maps are implemented using two tables: _index_ and _key_.
*   Each new entry added to a map is given an integer id, starting with one.
*   The field _index_ maps the id's to the associated pairs.
*   The entries in _index_ allow efficient iteration over the
*
*   The table _key_ maps keys in the map to the corresponding entry in the map.
*   The entries in _key_ permit efficient retrieval of the map's value for a given key.

*   SETL4 supports stacks by implementing them as a sequence. The fuction
*   _push()_ pushes a value on to the stack; the function _pop_ removes the
*   top value.


*## Loops, Iterators

*   Loops in SPITBOL have the form of a test followed by the loop body,
*   with the body with a branch back to the test.

*  For example, here is a loop that prints the first one hundred integers:

*```
*test
*       i = i + 1
*       le(i,100)                       :f(done)
*       output = i                      :(test)
*done
*```

*   This can also be written as:

*```
*test
*       output = le(i = i + 1,100) i    :s(test)
*```

*   Loops in SETL4 are constructed using the _loop_ and _next_ statements.

*   A loop has the form:

*```
*       loop(set,thisname)
*
*   set.next
*       var = next(set)     :f(set.done)
*       out(this)           :(set.next)
*   set.done
*```

*   The first operand specifies of _loop_ gives the set or range of values
*   of the iteration.  The optional second argument names a variable that is
*   updated as part of successful call to _next_.  The name _this_ is used
*   if the second argument is not given. The _loop_ statement above can be
*   written as _loop(set)_ or also _loop(set,.this)_ or _loop(set,'this').
*
*   Loops can have a specific variable associated with a loop.

*```
*       loop(set,.this.s)
*       ...
*   set.next
*       next(set)           :f(set.done)
*       out(this.s)         :(set.next)
*   set.done
*```

*   The _loop_ statement creates an instance of _iterator_ to control the
*   iteration. The _next_ statement advances the iteration by producing the
*   next element or failing if no more elements remain.

*   See the functions _prime_ and _primes_ defined below to see _loop_
*   and _next_ in action. See also the code for _exists_ and _forall_.

*   SETL4 provides the datatype _iterator_ to control iteration over a
*   range of integers, over a set, or over a map.

    data('iterator(iter.next,iter.start,iter.finis,iter.step,iter.thisname,'
.                 'iter.block,iter.blocks,iter.offset,iter.str)')

*   where

*-  _iter.next      last value returned by the iterator.

*-  The following fields are used to iterate over a range:

*-  _iter.start_    starting value for iteration

*-  _iter.finis_    finishing value for iteration

*-  _iter.step_     difference between values of an iteration

*-  _iter.thisname_ name of iteration variable to be update to iteration value

*## Additional Operations Provided as an Artifact of the Implementation

*   The use of the tables _set.index_ and _set.key_ to implement a set makes it
*   possible to provide some operations not available in in standard set theory.
*   For example, it is possible to retrieve elements using the function _get_.
*   _Get(s,i)_ retrieves the i-th element in the set.

*   The function _sorter can be used to determine the order in which the elements
*   of a set are accessed during an iteration, or to 'sort' the tables implementing
*   the set. For example, _sorter(s,'+v')_ sorts a map in increasing order of the
*   values of the map. _sorter(s,'-v')_ sorts the values in descendng order, and
*   so forth. For example, here is the code to find the ten members with
*   the largest values in a map:

*```
*       sorter(map,'-v')
*       largest = new('set')
*       iter = new('iter 1 10')
*       loop(set)
*
*   largest.add
*
*       add(largest,next(set))               :s(largest.add)
*```

*   _Sorter_ is used by the _show_ function to display the values of a set or
*   map in a standard order. For example, if _s_ is a set with the elements
*   'a', 'b' and 'c', then _show(s)_ yields `set 'a' 'b' 'c' }`, not
*   `set 'b' 'c' 'a' }`.

*## SETL4 Configuration Options

*   _setl4.config.channel.1_ is channel number for temporary files, that is,
*   files created on entry to a procedure and closed before returning from
*   the procedure.

    setl4.config.channel.1 = 3

*   Define initial sizes of tables when creating a set.

*   _setl4.config.set.table.size_ is default size for the _index_ and _key_ tables of a set.

    setl4.config.set.table.size = 1024

*   _setl4.config.int.table.size_ is size of index and key tables in set of kind 'int.'

    setl4.config.int.table.size = 1000

*   _setl4.config.int_ is number of characters in the block for an integer set.
*   _setl4.config.int.init_ is string of spaces of size _setl4.config.int_.

    setl4.config.int = 1000
    setl4.config.int = 20
    setl4.config.int.init = dupl('-',setl4.config.int)

*## Additonal SETL4 data types

*   SETL4 provides the following data type in addtion to _set_:

*       _token_

*   where

*       token(lineno,ndx,type,text) is a lexeme, or lexical token.

*## Show

*   The function _show_ writes out the value of a SETL4 object in a readable
*   form. Objects are shown in the order defined by the function _sorter.



*   '@'     s @ e   Filter          Returns subset of set _s_ for which _e_ is true
*   '~'     m ~ s   Membership      Tests if _m_ is member of set _s_

*## Sample data

*   Programs need data. Since SPITBOL is designed to analyze and manipulate text, SETL4 provides
*   a library consisting of several works chosen from the world's greatest literature, including
*   the works of William Shakespeare, a dictionary, and the text of the King James version
*   of the Bible. Except for the dictionary, all texts were obtained using Project Gutenberg.

*   As an extension of SPITBOL, SETL4 brings the raw power and speed of SPITBOL to the task
*   of working with text. Additional functions are provided, including a lexical scanner, or
*   tokenizer, to assist in performing deep, detailed analysis of textual structure.

*   Several of these functions have as their purpose the translation of text into sets, maps,
*   and sequences. For example, the tokenizer returns a sequence consisting of the tokens
*   in a line of text.

*   In order to be able to use the program ./examples/align.stl to align the
*   goto fields in the source, use the variable _char(58)_ where
*   the colon character enclosed in quotes would normally be used.

*## SETL4 Functions

*   SETL4 provides the following functions:
*
*-  add(set,elem)               Adds element to set.
*-  and(a,b)                    Tests if both operands are true.
*-  append(str,w,ch)            Appends _ch_ (or space if _ch_ is null) to _str_, then _w_
*-  arbitrary(n)                Returns arbitary (randomly chosen) integer in 1 .. _n_.
*-  arbitrary(set)              Returns arbitary (randomly chosen) element of _set_.
*-  ascii(line)                 Returns the text of line with every ascii character identified
*-  assert(expr)                Tests that _expr_ is true, ends execution otherwise.
*-  assert.type(obj,type)       Tests that _obj_ has SPITBOL datatype _type_, ends execution otherwise.
*-  begins(str,sub)             Tests if string _key_ begins with string _sub_.
*-  binary(n)                   Returns string with value of _n_ in binary number.
*-  checkout(filename)          Returns ('checks out') set or map defined by a text file from the libary
*-  compare(a,b)                Compares two integers or strings, returning -1 (less), 0 (equal), or +1 (greater).
*-  compose(a,b)                Returns composition of two maps or tables.
*-  datename(date)              Returns string based on current time suitable for use as filename.
*-  defined(map,key)            Tests if a map is defined for a specified key.
*-  difference(a,b)             Returns set of members of set _a_ not in the set _b_.
*-  digits()                    Returns list of digits: '0 1 2 .. 9'.
*-  domain(map)                 Returns set of elements in the domain of a map.
*-  equal(a,b)                  Tests if two SETL4 objects are equal.
*-  even(n)                     Tests if _n_ is even.
*-  exists(set,expr)            Tests if an expression is true for at least one element in a set.
*-  factorial(n)                Returns n!  = n * (n -1) * ... * 1.
*-  frequency(s)                Returns frequency of values in sequence, map or string _s_.
*-  from(set,elem)              Returns set consisting of the members of a set except a specified member.
*-  get(map,key)                Gets the value of map _map_ for _key_ for a map.
*-  get(set,i)                  Gets the i-th element in a set, or fails if no such element.
*-  false(e)                    Tests if argument is false.
*-  filter(set,expr)            Returns set of elements in _set_ for which _expr_ is true.
*-  forall(set,expr)            Tests if an expression is true for every element of a set.
*-  integers(n)                 Returns set of integers 1 ... n.
*-  intersection(a,b)           Returns set of elements common to two sets.
*-  is.plain(s)                 Tests if _s_ is plain type: integer, name, real, or string.
*-  join(a,b)                   Joins two strings into a single string by concatenating them.
*-  less(str,sub)               Removes the first instance of each character in _sub_ from _str_,
*-  loop(set,this)              Set up iteration over _set_ using _next_. _this_ names variable updated during iteration.
*-  tolower(s)                  Returns _s_ with upper case letters replaced by lower case equivalent.
*-  multiple(n,m)               Tests if _n_ is a multiple of _m_.
*-  odd(n)                      Tests if _n_ is odd.
*-  out(text1,text2,text3)      Outputs _text1_, then _text2_ enclosed in '[]' if _text2_ not null.
*-  pack(seq)                   Packs sequence of strings into single string.
*-  plain(v)                    Returns string representing a plain type, per is.plain().
*-  powerset(set)               Return the powerset of _set_, the set of all the subsets of _set_.
*-  prefix(str,pre)             Takes a list of space-separated words in _str_, prefixes each with _pre_.
*-  member(elem,set)            Tests if _elem_ is a member of _set_.
*-  new(str)                    Returns a new set specified by _str_.
*-  next(set)                   Returns next element in iteration defined by prevous _loop_, fails if no more elements.
*-  not(expr)                   Tests if operand is false.
*-  number(s)                   Returns integer defined by _s_.
*-  or(a,b)                     Tests if either operand is true.
*-  push(stack,value)           Push value onto a stack.
*-  pop(stack)                  Pop the top of a stack and return its value.
*-  prime(n)                    Tests if _n_ is prime.
*-  primes(n)                   Returns set of primes less than _n_.
*-  put(map,key,val)            Defines the value of a map key.
*-  quicksort(seq)              Use Hoare's quicksort algorithm to sort a sequence.
*-  random(n)                   Returns random integer if _n_ is integer, elsel random element of set or map.
*-  random.seed()               Sets random number seed to initialize _random_.
*-  range(map)                  Returns set of elements in the range of a map.
*-  reader(filename,expr)       Returns sequence of lines in file _filename_, using _expr_ (if given).
*-  reader(str,delim)           Like _reader(filename..)_ but reads lines from a string with lines.
*-  remove(set,elem)            Removes arbitary element from set, or most recent entry from map.
*-  set.size(set)               Returns number of elements in set _set_.
*-  show(v)                     Shows value of _v_.
*-  show.b(e)                   Shows value of _b_ as boolean.
*-  show.lines(lines,number)    Shows a sequence of lines, with id if _number_ not null.
*-  slice(str,first,last)       Like SPITBOL substr to work for sequences and tuples.
*-  sorter(set,type)            Sorts a set, map or string according to _type_.
*-  split.line(line)            Splits line of blank-separated words into sequence.
*-  split.string(str)           Splits string into sequence of characters.
*-  square.root(n)              Returns integer square root on _n_
*-  subset(a,b)                 Tests if the set _b_  is a subset of set _a_
*-  this(set)                   Returns current iteration value for _set_.
*-  thousands(s)                Returns _s_ with a comma every three spaces from the right.
*-  top(s)                      Returns top element of sequence viewed as stack.
*-  traceon()                   Turns on tracing.
*-  traceoff()                  Turns off tracing
*-  tokens(line)                Returns sequence of the tokens in _line_.
*-  true(e)                     Tests if operand is true.
*-  union(a,b)                  Returns set consisting of all the members in two sets.
*-  toupper(s)                  Returns _s_ with upper case letters replaced by lower case equivalent.
*-  visit(set,expr)             Visits each element of set _set_ and evaluates _expr_ for that element.
*-  words(line,w)               Returns sequence of words (defined by _w_) in _line_.
*-  writer(lines)               Writes sequence _lines_ to standard output.

*   SETL4 Function Definitions

    define('add(set,elem)ara,i,n,str')                 :(add.end)

*   _Add_ adds an element to a set if it not already a member.
*   If the set has kind _map_ and _elem_ has the data type _entry_
*   the map is updated using the key and value of the entry.

add

    differ(datatype(set),'set') error('attempt to add to non-set ' datatype(set))
    elem = integer(elem) +elem
    ident(set.kind(set),'map')                         :s(add.map)
    ident(set.kind(set),'seq')                         :s(add.seq)f(add.set)
    ident(set.kind(set),'tup')                         :s(add.seq)f(add.set)

add.map

    differ(datatype(elem),'entry') error("can only add 'entry' elements to a map.")
    put(set,key(elem),value(elem))                     :(return)

add.seq

    error("Use 'put' or 'push', but not 'add', to add elements to a sequence.")

add.set
    member(set,elem)                                   :s(return)

    set.size(set) = set.size(set) + 1
    set.index(set)[set.size(set)] = elem
    set.key(set)[elem] = elem                          :(return)

add.end

    define('and(a,b)')                                 :(and.end)

*   _And_ tests if both operand are true (not null), only
*   evaluating the second argument when necessary.

and

*   See if both operands are integers.

    and = integer(a) eq(a)                             :s(freturn)
    and = integer(a) integer(b) ne(a * b)              :s(return)f(freturn)

*   Here where at least one operand for 'and' is not integer, so
*   use ident/differ to evaluate.

    and = differ(a) differ(b)                          :s(return)f(freturn)

and.end

    define('append(str,w,ch)')                         :(append.end)

*   _Appends appends _ch_, or ' ' if _ch_ is null, to _str_ and then appends _w_.

append

    append = str (ident(str) w, (ident(ch) ' ' , ch) w):(return)

append.end

    define('arbitrary(set)iter,r')                     :(arbitrary.end)

*   _Arbtrary_ returns an arbitrary (randomly selected) element of a set, or
*   if the argument is an integer, then _arbitrary_ returns a random
*   integer in the range 1 .. _set_.

arbitrary

    arbitrary = integer(set) random(+set)              :s(return)
    r = random(set.size(set))
    ident(set.kind(set),'iter')                        :s(arbitrary.iter)
    arbitrary = set.key(set)[set.index(set)[r]]
                                                       :(return)

arbitrary.iter

    iter = set.iter(set)
    arbitrary = iter.starbitraryitrary(iter) + (r - 1) * iter.step(iter):(return)

arbitrary.end

    define('ascii(line)c,n,name,nul,num,pos')          :(ascii.end)

*   _Ascii_ returns the text of its argument string with every ascii character identified.

ascii

    differ(ascii.initialized)                          :s(ascii.initialized)

*   Here to initialize the needed maps.

    ascii.init()
    ascii.initialized = 1

ascii.initialized

    nul = substr(&alphabet,1,1)

ascii.next

*   Add space after previous character if result not null.

    ascii = differ(ascii) ascii ' '
    c = substr(line,1,1)                               :f(ascii.done)
    ident(c,nul)                                       :s(ascii.null)
    line any('0123456789')                             :s(ascii.integer)
    line any(&lcase &ucase)                            :s(ascii.letter)
    line ' '                                           :s(ascii.space)

*   Check for control character (code <=26)

    &alphabet break(c) . pos                           :f(ascii.other)
    pos = size(pos)
    gt(pos,26)                                         :s(ascii.other)
*TODO here fix g. usage
    ascii = ascii g.ascii.name[c] '(^'
               substr('ABCDEFGHIJKLMNOPQRSTUVWXYZ',pos,1) ')'
    line len(1) =                                      :(ascii.next)

ascii.integer

    line span('0123456789') . text =
    ascii = ascii  text                                :(ascii.next)

asciiletter

    line span(&lcase &ucase) . text =
    ascii = ascii  text                                :(ascii.next)

ascii.null

    ascii = ascii 'NUL'                                :(ascii.next)

ascii.other

*   Here if none of the other cases apply, so just list the ascii name.

    ascii = ascii ascii.name[c]
    line = substr(line,2)                              :(ascii.next)

ascii.space

    line span(' ') . text =

    ascii =  ascii 'SPC'
    ascii = gt(size(text),1) ascii 'SPC*' size(text)
    ascii = ascii
                                                       :(ascii.next)
ascii.done

    ascii = trim(ascii)                                :(return)

ascii.end

    define('ascii.init(init)entry,name,value')         :(ascii.init.end)

*   _Ascii.init_ Initialize maps for use by _ascii_.
*   Since space (ascii 32) prints as space, use the name SPC for 32.

ascii.init


    ascii.init = new('map '
.      '0:NUL 16:DLE 32:SPC 48:0 64:@ 80:P  96:` 112   :p '
.      '1:SOH 17:DC1 33:!   49:1 65:A 81:Q  97:a 113   :q '
.      '2:STX 18:DC2 34:"   50:2 66:B 82:R  98:b 114   :r '
.      '3:ETX 19:DC3 35:#   51:3 67:C 83:S  99:c 115   :s '
.      '4:EOT 20 DC4 36:$   52:4 68:D 84:T 100:d 116   :t '
.      '5:ENQ 21:NAK 37:%   53:5 69:E 85:U 101:e 117   :u '
.      '6:ACK 22:SYN 38:&   54:6 70:F 86:V 102:f 118   :v '
.      "7:BEL 23:ETB 39:'   55:7 71:G 87:W 103:g 119   :w "
.      '8:BS  24:CAN 40:(   56:8 72:H 88:X 104:h 120   :x '
.      '9:HT  25:EM  41:)   57:9 73:I 89:Y 105:i 121   :y '
.      '10:LF 26:SUB 42:*   58:  74:J 90:Z 106:j 122   :z '
.      '11:VT 27:ESC 43:+   59:; 75:K 91:[ 107:k 123   :{ '
.      '12:FF 28:FS  44:,   60:< 76:L 92:\ 108:l 124   :| '
.      '13:CR 29:GS  45:-   61:= 77:M 93:] 109:m 125   :} '
.      '14:SO 30:RS  46:.   62:> 78:N 94:^ 110:n 126   :~ '
.      '15:SI 31:US  47:/   63:? 79:O 95:_ 111:o 127   :DEL ')

    ascii.name = new('map #128')
    ascii.value = new('map #128')
    loop(ascii.init)

ascii.init.next

    entry = setl4.l.next(ascii.init)                   :(ascii.init.finis)
*   Correct entry for 0 to be NUL, the NUL character
    ascii.name[substr(&alphabet,+v + 1,1)] = name
    ascii.value[name] = +value                         :(ascii.init.next)
    ascii.name[] = 'NUL'
    ascii.value['NUL'] = 0
    ascii.name[' '] = 'SPC'
    ascii.value['SPC'] = 32
    ascii.value['SPC'] = 32
    ascii.name[char(58)] = char(58)
    ascii.value[char(58)] = 58

ascii.init.end

    define('assert(expr)')                             :(assert.end)

*   _Assert_ tests that its argument expression is non null, ending execution otherwise.

assert

    true(expr)                                         :s(return)
    error('assertion failed, quitting')

assert.end

    define('assert.type(obj,typ)')                     :(assert.type.end)

*   _Assert.type_ tests that _obj_ has datatype _typ_, and ends execution if not.

assert.type

    assert(ident(datatype(obj),typ))                   :s(return)
    error('assertion on datatype failed ' typ )


assert.type.end

    define('begins(str,init)')                         :(begins.end)

*   _Begin_ tests if string _str_ begins with string _init_.
*   It returns _str_ on success, fails otherwise.

begins

    ident(str)                                         :s(freturn)
    ident(init)                                        :s(freturn)
    begins = str
    ident(str,init)                                    :s(return)
    gt(size(init),size(str))                           :s(freturn)
    ident(substr(str,1,size(init)),init)               :s(return)f(freturn)

begins.end

    define('binary(n)')                                :(binary.end)

*   _Binary_returns a string with the value of _n_ as a binary number.

binary

    n = n * 2

binary.next

    n = n / 2

    binary = eq(n)   '0'                               :s(return)
    binary = eq(n,1) '1'                               :s(return)
    binary = even(n) binary(n / 2) '0'
    binary = odd(n)  binary(n / 2) '1'
                                                       :(return)

                                                       :(binary.next)

binary.done

*   binary = ident(binary) '0'                          :s(return)
*   binary = gt(size(binary),1) substr(binary,2)
                                                       :(return)

binary.end

	define('checkout(filename)file,fullname,line,word')   :(checkout.end)

*	_Checkout_ checks out (retrieves)  a file from the library as a sequence of lines
*   or a set of words. _Checkout_ lists the available files if _filename_ is null.

*   Dictionary has one word per line, with toupper 'S' at end denoting
*   that both singular and plural form are words in the dictionary.

*   When checking out text files, skip blank lines and lines that start with '*'.

checkout

    differ(filename)                                   :s(checkout.check)

checkout.list

    out('available texts in the checkout               :')
	out('dictionary')
	out('genesis')
	out('hamlet')
	out('new-testament')
	out('old-testament')
	out('romeo-and-juliet')
	out('shakespeare')
	out('sonnets')
                                                       :(return)

checkout.check

*   See if _filename_ matches one of the available texts.


	filename = begins('dictionary',filename)              :s(checkout.open)
	filename = begins('enable1',filename)                 :s(checkout.open)
	filename = begins('genesis',filename)                 :s(checkout.open)
	filename = begins('hamlet',filename)                  :s(checkout.open)
	filename = begins('new-testament',filename)           :s(checkout.open)
	filename = begins('old-testament',filename)           :s(checkout.open)
	filename = begins('romeo-and-juliet',filename)        :s(checkout.open)
	filename = begins('shakespeare',filename)             :s(checkout.open)
	filename = begins('sonnets',filename)                 :s(checkout.open)

    out('sorry, that text is not available.')
    out('here is a list of the available texts')       :(checkout.list)

checkout.open

	fullname = '../library/' filename '.txt'
	input(.file,3,fullname)                               :s(checkout.opened)
	error('unable to open file ',filename)                :(freturn)

checkout.opened

*   Dictionary requires special handling.

    ident(filename,'dictionary')                       :s(checkout.dictionary)
    checkout = set('seq',iterator(),table(2000),table(2000))

checkout.next

	line = file                                           :f(checkout.finis)
    lines = lines + 1
    ident(line)                                        :s(checkout.next)
    line '*'                                           :s(checkout.next)
    push(checkout,line)                                :(checkout.next)

checkout.dictionary

    checkout = set('set',iterator(),table(40000),table(40000))

checkout.dictionary.add

    add(checkout,word)

checkout.dictionary.next

    word = file                                        :f(checkout.finis)
    ident(substr(word,size(word),1),'S')               :f(checkout.dictionary.add)

*   Here if plural. Add plural form and them merge to add singular form.

    word = substr(word,1, size(word) - 1)
    add(checkout, word 's')                            :(checkout.dictionary.add)

checkout.finis

	endfile(3)                                            :(return)

checkout.end

    define('compare(a,b)')                             :(compare.end)

*   _Compare_ compares two integers or strings, returning -1 if the _a_ is
*   less than _b_ , 0 if both have the seq.eq value, and +1 if the _a_ is greater than _b_.

compare

    a = integer(a) +a
    b = integer(b) +b
*   out('compare ' datatype(a) ' ' datatype(b))
    differ(datatype(a),datatype(b)) error("compare argument types differ " datatype(a) " " datatype(b))
    ident(datatype(a),'string')                        :s(compare.strings)

*   Here to numerically compare integers.

    compare = lt(a,b) -1                               :s(return)
    compare = eq(a,b) 0                                :s(return)
    compare = 1                                        :(return)

compare.strings

*   Here to lexically compare strings.
    compare = llt(a,b) -1
    compare = leq(a,b) 0
    compare = lgt(a,b) 1
*   out('compare ' show(a) ' ' show(b) ' ' compare)
                                                       :(return)

compare.end

    define('compose(a,b)ara,entry,i')                  :(compose.end)

*   _Compose_ returns the composition of two maps or tables.
*   Given maps _a_ and _b_ such that _range(a)_ is a subset of _domain(b)_,
*   then the composition _c_ of _a_ and _b_ is defined as follows:
*   Let A be a member of the domain of _a_. Let B be the value of _a[A]_.
*   Then _c[A]_ is defined as _b[B]_.

compose

    ident(datatype(a),'table')                         :s(compose.table)

*   Here to compose two maps.

    n = set.size(a)
    compose = eq(n) new('map')                         :s(return)
    compose = new('map #' n)
    set.size(compose) = n
    loop(a)

compose.map.next

    entry  = next(a)                                   :f(return)
    put(compose,key,get(b,value(entry)))               :(compose.map.next)

compose.table

    ara = convert(a,'array')                           :f(show.table.error)
    prototype(ara) break(',') . n
    compose = table(n)
    i = 0

compose.table.next

    le(i = i + 1,n)                                    :f(return)
    compose[i] = b[a[i]]                               :(compose.table.next)

compose.end

    define('datename()s')                              :(datename.end)

*   _Datename_ converts the current date in a form with no spaces,
*   just dashes, that is suitable for use as part of a file name.

datename

    datename = replace(date(),'                        :/','---')
    datename = substr(datename,12,8) '-' substr(datename,1,10)
                                                       :(return)
datename.end

    define('defined(map,key)entry')                    :(defined.end)

*   _Defined_ tests if the map _map_ has an entry for _key_.

defined
    key = integer(key) +key
    defined = set.key(map)[key]
    differ(defined)                                    :s(return)f(freturn)

defined.end

    define('difference(a,b)this')                      :(difference.end)

*   _Difference_ returns the set defined by the set of elements of _a_ that are not in _b_.

difference

    difference = new()
    loop(a)

diference.next

    this = next(a)                                     :f(return)
    member(b,this)                                     :s(difference.next)
    add(difference,this)                               :(difference.next)

difference.end

    define('digits()str,ch')                           :(digits.end)

*   _Digits_ returns the string consisting of the digits 0 .. 9 separated by a space.

digits

    digits =
    str = '0123456789'

digits.next

    str len(1) . ch =                                  :f(return)
    digits = append(digits,ch)                         :(digits.next)

digits.end

    define('domain(map)elem)')                         :(domain.end)

*   _Domain_ returns the domain of map, which is the set of the keys in _map_.

domain

    domain = new()
    loop(map)

domain.next

    entry = next(map)                                  :f(return)
    differ(entry) add(domain,key(entry))               :(domain.next)

domain.end

    define('equal(a,b)entry,i,key,value')              :(equal.end)

*   _Equals_ tests if two objects are equal. Use DIFFER unless both are sets, in
*   which case use equality tests specified below.

equal

    ident(datatype(a),'set') ident(datatype(b),'set')  :s(equal.sets)
    ident(a,b)                                         :s(return)f(freturn)

equal.setl4

*   Here for equality test of two SETL4 objects.

    ident(set.kind(a),set.kind(b))                     :f(freturn)
    eq(set.size(a),set.size(b))                        :f(freturn)
                                                       :($('equal.' set.kind(a)))

equal.int

    eq(iter.start(a),iter.start(b))                    :f(freturn)
    eq(iter.finis(a),iter.finis(b))                    :f(freturn)
    eq(iter.step(a),iter.step(b))                      :f(freturn)s(return)

equal.map

*   Two maps are equal if they have the same vaue at every element in the domain.

    gt(i = i + 1, set.size(a))                         :s(equal.true)
    entry = set.index(a)[i]
    ident(value(entry),get(b,key(entry)))              :f(freturn)s(equal.map)

equal.seq

*   Two sequences are equal if they have the same vaue at every element in the domain.

    gt(i = i + 1, set.size(a))                         :s(equal.true)
    ident(set.seq(a)[i], set.seq(b)[i])                :s(equal.seq)f(freturn)

equal.sets


    lt(set.size(a),set.size(b))                        :s(freturn)
    ident(set.kind(a),set.kind(b))                     :f(freturn)
    ident(set.kind(set),'int')                         :s(equal.int)
    ident(set.kind(set),'iter')                        :s(equal.iter)
    ident(set.kind(set),'map')                         :s(equal.map)
    ident(set.kind(set),'seq')                         :s(equal.seq)
    ident(set.kind(set),'set')                         :s(equal.set)
    ident(set.kind(set),'tup')                         :s(equal.seq)
    error('equal mismatched kinds')


equal.set

*   Two sets are equal if and only if each is a subset of the other.
    subset(a,b)                                        :f(freturn)
    subset(b,a)                                        :f(freturn)
                                                       :(return)
    equal = and(subset(a,b),subset(b,a))               :f(freturn)s(return)

equal.end

    define('even(n)')                                  :(even.end)

*   _Even_ tests if its argument is even.

even

    eq(remdr(n,2))                                     :s(return)f(freturn)

even.end

    define('error(str)')                               :(error.end)

*   _Error_ writes out its argument string and ends execution.

error

    &dump = 2
    &dump = 3
    out('&dump',&dump)

*   Clear variables that need not appear in &dump output

    setl4.clear()
    out('Fatal error: ' str)                           :(end)

error.end

    define('exists(set,expr)this,e')                   :(exists.end)

*   _Exists_ tests if there is an element in _set such that _expr_ is true.

exists

    loop(set)

exists.loop

    this = next(set)                                   :f(freturn)
    exists = eval(expr)                                :f(exists.loop)s(return)

exists.done

    output = 'exists loop ended, failing'              :(freturn)

exists.end

    define('factorial(n)')                             :(factorial.end)

*   _Factorial_ computes the value of the factorial function of its argument.

factorial

    factorial = (eq(n,1) 1, n * factorial(n -1))       :(return)

factorial.end

    define('false(e)')                                 :(false.end)

*   _False_ tests if its argument is false (null).

false

    e = integer(e) +e
    false = integer(e)  eq(e)                          :s(freturn)
    false = ident(e)                                   :s(return)f(freturn)

false.end

    define('filter(set,expr)e,this')                   :(filter.end)

*   According to Paul Halmos, in his book "Naive Set Theory,"
*   a major principle of set theory, often referred to by its
*   German name _Aussonderungsaxiom_, is the Axiom of Specification:

*   To every set _A_ and every condition _S(x)_ there corresponds
*   a set _B_ whose elements are exactly those elements _x_ of _A_
*   for which _S(x)_ holds.

*   In SETL4 we say that the expression '_A_ @ _S_' "filters"
*   _A_ by _S_. This can also be read as
*           "the subset of _A_ such that _S_ is true"

*   Returns the subset of set, map or sequence _set_ for which _expr_ is true.

filter

    out('filter set.kind',set.kind(set))
    ident(set.kind(set),'map')                         :s(filter.map)
    ident(set.kind(set),'seq')                         :s(filter.seq)
    ident(set.kind(set),'tup')                         :s(filter.tup)
    filter = new('set')
    loop(set)

filter.set.next

    this = next(set)                                   :f(return)
    eval(expr) add(filter,this)                        :(filter.set.next)

filter.map

    filter = new('map')
    loop(set)

filter.map.loop

    this = next(set)                                   :f(return)
    eval(expr) push(filter,value(this))                :(filter.map.loop)

filter.seq

    filter = new('seq')
    loop(set)

filter.seq.loop

    this = next(set)                                   :f(return)
*   out('at filter.seq.loop')
    out('filter this',this)
    eval(expr) push(filter,this)                       :(filter.seq.loop)

filter.tup

    filter = new('tup')
    loop(set)

filter.tup.loop

    this = next(set)                                   :f(return)
*   out('at filter.seq.loop')
    out('filter this',this)
    eval(expr) push(filter,this)                       :(filter.seq.loop)

filter.end

    define('forall(set,expr)e')                        :(forall.end)

*   _Forall_ tests if _expr_ is true for all elements of _set_.

forall

    loop(set)

forall.loop

    next(set)                                          :f(return)
    e = eval(expr)                                     :f(freturn)s(forall.loop)

forall.end


    define('frequency(map)this')            :(frequency.end)

*   _Frequency_ returns a frequency distribution for a map,
*   sequence  or string. The frequency distribution of a string
*   gives the number of times each character in the string occurs
*   in the string. The distribution of a map or sequence gives,
*   for each element in the range of the map the number of keys
*   having that value.


frequency

    show(map)

    frequency = new('map')
    ident(datatype(map),'set')            :s(frequency.map)

*   Compute distribution for string by converting string to sequence
*   and merging with code to find distribution for a map.

    map = split.string(map)
    show(map)

frequency.map
    
*   Here to compute frequency distribution of a map.

    loop(map)

frequency.next

    this = value(next(map))                 :f(return)
    this = integer(this) +this
    put(frequency,this,get(frequency,this) + 1) :(frequency.next)

frequency.end

    define('from(set,elem)this')                       :(from.end)

*   _From_ removes an (existing) element from a set.

from

    from = new()
    loop(set)

from.next

    this = next(set)                                   :f(return)
    differ(this,elem) add(from,this)                   :(from.next)

from.end

    define('get(map,key)val,entry')                    :(get.end)

*   _Get_ gets the value of the key _key_ in the map _map_, or gets
*   element _key_ in a set, failing if no such element.

get

    key = integer(key) +key
    ident(set.kind(map),'int')                         :s(get.int)
    ident(set.kind(map),'map')                         :s(get.map)
    ident(set.kind(map),'seq')                         :s(get.map)
    ident(set.kind(map),'set')                         :s(get.set)
    ident(set.kind(map),'tup')                         :s(get.set)
    error('get on unsupported kind of set              : ' set.kind(map))

get.int

    error("get on set of kind 'int' not yet supported.")

get.map

    get = set.key(map)[key]                            :(return)

get.set

    ident(set.kind(map),'iter')                        :s(get.int)
    get = set.index(map)[key]
    ident(get)                                         :s(freturn)f(freturn)
    get = set.key(map)[entry]                          :(return)

get.end

    define('int(n)')                                   :(int.end)

*   _Int_ Returns _n_ if _n_ is an integer, or returns _n_ converted to an
*   integer if _n_ is real, or returns the value of a string written in exponential
*   (scientific) notation converted to its integer value.

int

    int = integer(n) n                                 :s(return)
    int = ident(datatype(n),'real') convert(n,'integer'):s(return)
    int = n
    n break('e')                                       :f(return)
    n break('e') . int 'e' =
    int = int * +('1' dupl('0',n))
    int = +int
                                                       :(return)

int.end

    define('integers(n)')                              :(integers.end)

*   _Integers_ returns the set containing the integers 1 .. _n_

integers

    integers = set('set',iterator(),table(n),table(n))

integers.next

    le(i = i + 1,n) add(integers,i)                    :s(integers.next)f(return)

integers.end

    define('intersection(a,b)this')                    :(intersection.end)

*   _Intersection_ returns the intersection of its argument sets.

intersection

*   Make _a_ the smaller

    le(set.size(a),set.size(b))                        :s(intersection.next)
    a = b
    b = intersection
    intersection = new()
    loop(a)

intersection.next

    this = next(a)                                     :f(return)
    member(b,this) add(intersection,this)              :(intersection.next)

intersection.end

    define('is.plain(v)')                               :(is.plain.end)

*   Tests if _v_  has a plain type. 
*   The plain types are 'integer', 'name', 'real', and 'string'.

is.plain

    ident(v)                                            :s(return)
    ident(datatype(v),'integer')                        :s(return)
    ident(datatype(v),'name')                           :s(return)
    ident(datatype(v),'real')                           :s(return)
    ident(datatype(v),'string')                         :s(return)
                                                        :(freturn)

is.plain.end

    define('join(a,b,c)i')                             :(join.end)

*   _Join_ joins strings by concatenating them, and sequences or tuples
*   by returning a new sequence or tuple consisting of all the elements of
*   the first followed by all the elements of the second, and then
*   by the elements of the third.

*   If called with three arguments, the result returned is the same as join(join(a,b),c)`

join

    ident(a)                                           :s(return)
    ident(datatype(a),'string')                        :s(join.string)
    join = new(set.kind(a))
    loop(a)

join.a

    push(join,next(a))                                 :s(join.a)
    loop(b)

join.b

    push(join,next(b))                                 :s(join.b)
    loop(c)

join.c

    push(join,next(c))                                 :s(join.c)f(return)

join.string

*   Here to join strings.

    join = a (differ(b) b, '') (differ(c) c,'')        :(return)

join.end

    define('less(str,sub)before,after')                :(less.end)

*   _Less_ removes the first instance of each character in _sub_ from _str_,
*   where _sub_ is a substr of _str_.

less

    ident(str)                                         :s(return)
    less = str

less.ch
    sub len(1) . ch =                                  :f(return)
    less break(ch) . before  ch rem . after
    less = before after                                :(less.ch)

less.end


    define('loop(set,thisname)iter')                   :(loop.end)

*   _Loop_ creates or updates the iterator of _set_ so that,
*   on first call to _next()_,  _iter.next_  will be
*   advanced to select the first element in the iteration.

*   If _thisname_ is not null, then _thisname_ is set to 'this'.
*   On each call to _next()_ during the iteration established
*   by _loop_, the value of the iterate will be assigned to _thisname_.

loop

    differ(datatype(set),'set') error('argument to loop must be set.')
    iter = iterator()

	ident(set.kind(set),'iter')                        :s(loop.iter)
    ident(set.kind(set),'int')                         :s(loop.int)
    ident(set.kind(set),'map')                         :s(loop.map)
    ident(set.kind(set),'seq')                         :s(loop.map)
    ident(set.kind(set),'set')                         :s(loop.set)
    ident(set.kind(set),'tup')                         :s(loop.map)
    error('unknown kind of iterator, ' set.kind(set))

loop.int

    iter.next(set) = set.block(iter) = set.offset(iter) = 0:(loop.finis)

loop.iter

*   When iterating over a set of kind 'iter', use the iterator
*   created when the set was created.

    differ(set.kind(set),'iter') error("loop.iter requires kind 'iter'")
    iter.next(iter) = gt(iter.step(iter)) iter.start(iter) - iter.step(iter)
    iter.next(iter) = lt(iter.step(iter)) iter.start(iter) - iter.step(iter)
                                                       :(loop.finis)

loop.map
loop.seq
loop.set

loop.finis

    thisname = ident(thisname) .this
    thisname = ident(datatype(thisname),'string') .thisname
    iter.thisname(iter) = thisname
    set.iter(set) = iter                               :(return)

loop.end

    define('member(set,elem)kind,entry,i,iter,key,this,value,block)'):(member.end)

*   _Member_ tests if _elem_ is member of _set_.

member

*   Branch according to whether _set_ is set, map, or sequence.

    eq(set.size(set))                                  :s(freturn)
    elem = integer(elem) +elem
    ident(datatype(elem),'entry')                      :s(member.map)
    ident(set.kind(set),'int')                         :s(member.int)
    ident(set.kind(set),'iter')                        :s(member.iter)
    ident(set.kind(set),'set')                         :s(member.set)
    error('member                                      : unexpected kind ' kind )

member.int

*   To test for membership in set of kind _int_ get the block
*   for the element. If it is null then fail since element not
*   in the set. Otherwise see if character corresponding to the
*   value of _elem_ is '+'.

    block = elem / setl4.config.int
    this = +(remdr(elem,setl4.config.int) + 1)
    value = set.key(set)[block]
    ident(value)                                       :s(freturn)
    ident(substr(value,this,1),'+')                    :s(return)f(freturn)

member.iter

    integer(elem)                                      :f(freturn)
    iter = set.iter(set)
    lt(iter.step(iter)) lt(elem,iter.finis(iter))      :s(freturn)
    gt(iter.step(iter)) eq(remdr(elem - iter.start(iter),iter.step(iter))):s(return)
    lt(iter.step(iter)) eq(remdr(iter.start(iter) - elem,iter.step(iter))):s(return)
                                                       :(freturn)

member.map

    differ(set.key(set)[key(elem)])                    :s(return)f(freturn)

member.set

    differ(set.key(set)[elem])                         :s(return)f(freturn)

member.end

    define('multiple(n,m)')                            :(multiple.end)

*   _Multiple_ Tests if _n_ is a multiple of _m_.

multiple

    multiple = eq(remdr(n,m))                          :s(return)f(freturn)

multiple.end

    define('new(init,elem1,elem2)kind,i,index,iter,len,n,key,seq,val,values,words)'):(new.end)

*   _New_ constructs a new set with initial values determined by string _init_.

*   The first three characters in _init_ give the kind of the set:
*
*       'iter'          iterator, followed by iterator specification
*       'map'           map, followed by list of key/value pairs separated by colon
*       'set'           set, followed by list of initial members
*       'seq'           sequence, followed by list of initial values.
*       'tup'           tuple, followed by list of initial values.

*   The set kind may optionally be followed by a number sign (#) followed by an integer, to
*   indiate an estimate of the number of elements in a set or map. Ihe number need not be
*   accurate. Values that are too high will cause the program to expend space to save some time;
*   numbers that are too low will expend some time to save space.

*   _New_ returns the new object.

new

*   Assume kind is 'set' unless explicitly specified.

    kind = 'set'

    init span(' ') =
    ident(init)                                        :s(new.set)
    init = init ' '
    init break(' ') . kind span(' ') =
    kind = (gt,size(kind),3) substr(kind,1,3)
    begins('integers',kind)                            :s(new.kind)
    begins('iterator',kind)                            :s(new.kind)
    begins('map',kind)                                 :s(new.kind)
    begins('seq',kind)                                 :s(new.kind)
    begins('set',kind)                                 :s(new.kind)
    begins('tup',kind)                                 :s(new.kind)
    begins('string',kind)                              :s(new.kind)

*   If the kind is not given, then the kind is 'set' and _init_
*   is not null, it gives the initial element(s) to add to the set.

    kind = 'set'

new.kind

    kind = gt(size(kind),3) substr(kind,1,3)
    n = 0
    init span(' ') =
    n = setl4.config.table.int.table.size
    init '# ' span('0123456789') . n =                 :s(new.sized)
    init '#' span('0123456789') . n =

new.sized

*   Branch on kind to finish initialization of new set.

                                                       :($('new.' kind))
new.int

    new = set('set',iterator(),table(n),table(n))
    set.kind(new) = 'int'
    set.index(new) = table(1000)
    set.key(new) = table(1000)

new.int.next

    init break(' ') . key span(' ') =                  :f(new.init.elem)
    add(new,int(key))                                  :(new.int.next)

net.int.elem

    differ(elem1) add(new,elem1)
    differ(elem2) add(new,elem2)                       :(return)
    
new.ite
new.iter

    iter = iterator()
    iter.step(iter) = 1
    seq = new('seq ' init)

*   Ignore extra arguments to iterator constructor.

    set.size(seq) = gt(set.size(seq),3)
    eq(set.size(seq),1)                                :s(new.iter.1)
    eq(set.size(seq),2)                                :s(new.iter.2)
    eq(set.size(seq),3)                                :s(new.iter.3)

new.iter.1

    iter.start(iter) =  1
    iter.finis(iter) = get(seq,1)
    iter.step(iter) = 1                                :(new.iter.step)

new.iter.2

    iter.start(iter) =  get(seq,1)
    iter.finis(iter) = get(seq,2)
    iter.step(iter) = 1                                :(new.iter.step)

new.iter.3

    iter.start(iter) =  get(seq,1)
    iter.finis(iter) = get(seq,2)
    iter.step(iter) = get(seq,3)

new.iter.step

*   Make sure step negative if first argument to iter is greater than the second.

    lt(iter.step) out('new -step',iter.step(iter))
    iter.step(iter) = gt(iter.start(iter),iter.finis(iter))  gt(iter.step(iter)) - iter.step(iter)
    new = set('iter',iter)
    set.size(new) = ((iter.finis(iter) - iter.start(iter)) / iter.step(iter)) + 1

new.map

    new = set('map',iterator(),table(n),table(n))

*   If present, _init_ is a list consisting of a list of key/value pairs,

*   with a colon (:) separating the key and value.

    init = init ' '
    init span(' ') =
    ident(init)                                        :s(return)

new.map.next

    init break(char(58)) . key char(58) break(' ') . val span(' ') =:f(return)
    put(new,key,val)
                                                       :(new.map.next)

new.seq
new.tup

    new = set(kind,iterator(),table(n),table(n))
    init span(' ') =
    ident(init)                                        :s(return)
    init = init ' '

new.seq.next

    init span(' ') =
    init break(' ') . val ' ' =                        :f(new.seq.elem)
    push(new,val)                                      :(new.seq.next)

new.seq.elem

    ident(elem1) add(new,elem1)
    ident(elem2) add(new,elem2)                        :(return)

new.set

    new = set('set',iterator(),table(n),table(n))
    set.kind(new) = 'set'
    ident(init)                                        :s(return)

new.set.iter.next

    init break(' ') . key span(' ') =                  :f(new.set.elem)
    add(new,key)                                       :(new.set.iter.next)

new.set.elem

    differ(elem1) add(new,elem1)
    differ(elem2) add(new,elem2)

new.set.done

    iter.next(new) =                                   :(return)

new.end

    define('new.stack()')                              :(new.stack.end)

*   _New.stack_ returns a new stack.

new.stack

*   Don't allocate stack table when creating stack. Do that
*   when first add value to stack.

    new.stack = stack(,0)                              :(return)

new.stack.end

    define('next(set)iter,key,next,str,thisname,value'):(next.end)

*   _Next_ advances an iteration or fails if no more elements remain.

next

*   Branch on kind to find next iteration value.

    iter = set.iter(set)                               :($('next.' set.kind(set)))

next.int

*   Iteration over a set    of kind 'int' makes use of the following fields:
*
*       set.block      is current block for iteration
*       set.offset     is zero if this block not search, or else index of an
                       element of the set in this block
*       set.str        is set to the string of a block when advance to it.

*   Branch to get first block if _set.str_ is null.

    ident(set.str(set))                                :s(next.int.block)

next.int.test

*   See if any members remain in this block, branching to _next.int.block_ if none.

next.int.block

*   Here to advance to next block, ending iteration if no more remain.

    set.block(set) = set.block(set) + 1
    gt(set.block(set),set.blocks(set))                 :s(freturn)
    set.str(set) = set.key(set)[set.index(set)[set.block(set)]]
    str = set.str(set)
    str break('+') . key                               :f(next.int.block)

*   Here when member found. Clear the membership character and return.

    set.str(set) = set.key(set)[block]
    set.str(set) = ne(set.offset(set))
.           substr(set.str(set),1,set.offset(set) - 1,'-','+')
.          '+'
.          substr(str,set.offset(set) + 1)
    set.str(set) = str
    next = (set.block(set) * setl4.config.int) + size(key):(next.finis)

next.iter

*   Here to find next element in iterator.

    next = iter.next(iter) = iter.next(iter) + iter.step(iter)
    gt(iter.step(iter)) gt(next,iter.finis(iter))      :s(freturn)
    lt(iter.step(iter)) lt(next,iter.finis(iter))      :s(freturn)
                                                       :(next.finis)

next.map
next.seq
next.tup

    next = iter.next(iter) = iter.next(iter) + 1
    le(next,set.size(set))                             :f(freturn)
    key = set.index(set)[next]
    next = entry(key,set.key(set)[key])                :(next.finis)

*next.seq
*
*    next = iter.next(iter) = iter.next(iter) + 1
*    le(next,set.size(set))                             :f(freturn)
*    key = set.index(set)[next]
*    next = set.key(set)[next]                          :(next.finis)
*
next.set

    next = iter.next(iter) = +iter.next(iter) + 1
    le(next,set.size(set))                             :f(freturn)
    next = set.index(set)[next]                        :(next.finis)

next.finis

*   Here to update _thisname_  to the next iteration value.

    thisname = iter.thisname(iter)
    $(thisname) = next                                 :(return)

next.end

    define('not(expr)')                                :(not.end)

*   _Not_ returns the negation of a boolean expression.

not

    not = integer(expr) (eq(expr) 1, '')               :s(return)f(freturn)
    not = ident(expr) 1                                :s(return)f(freturn)

not.end

    define('number(n)')                                :(number.end)

*   Test if _n_ is a string with integer value or integer, returning its
*   value if so, or failing otherwise.

number

    number = integer(n) +n                             :s(return)f(freturn)

number.end

    define('odd(n)')                                   :(odd.end)

*   _Odd_ tests if its argument is odd.

odd

    odd = ne(remdr(n,2))                               :s(return)f(freturn)

odd.end

    define('or(a,b)')                                  :(or.end)

*   _Or_ tests if either operand is true, fails otherwise, only evaluating
*   its second argument if necessary

or
    or = integer(a) ne(a)                              :s(return)
    or = integer(b) ne(b)                              :s(return)

*   Here if operands not both integers, so use ident/differ.

    or = differ(a)                                     :s(return)
    or = differ(b)                                     :s(return)f(freturn)

or.end

    define('out(text1,text2,text3)type1,type2')        :(out.end)

*   _Out_ writes a line to standard output  conisting of _text1_,
*   then _text2_ enclosed in brackets if _text2_ is not null, followed
*   by _text3_ if _text3_ is not null.

out

    text2 = is.plain(text2) plain(text2)
    output  = text1 (differ(text2) '[' text2 ']', '') (differ(text3) text3,'') :(return)

out.end

    define('out.dt(v)')                                :(out.dt.end)

*   Show datatype of _v_

out.dt

    out('Datatype ' v,eval('datatype(' v ')'))         :(return)

out.dt.end

    define('pack(seq)i')                               :(pack.end)

*   _Pack_ packs a sequence of strings into a single string.

pack

    loop(seq)

pack.next

    pack = pack value(next(seq))                       :s(pack.next)f(return)

pack.end

    define('plain(v)')                  :(plain.end)

*   Tests if _v_ is a plain type, where the plain types are _entry_, _integer_,
*   _pair_, _real_, and _string_. If _v_ is plain, then _plain_ returns its
*   value as a string. Otherwise, _v_ is returned as the value.

plain

    ident(v)                                            :s(return)
    plain = v
    is.plain(v)                                         :f(return)
    plain = integer(v) +v                               :s(return)

*   Nothing to be done if argument is not string.

    ident(datatype(v),'string')                         :s(plain.string)
    error('unexpected input type to plain, ' datatype(v))

plain.string

*   String in plain form if starts with quote chacter. 

    plain '"'                                           :s(return)
    plain "'"                                           :s(return)
    v break("'")                                        :s(plain.double)

*   Here if arguent does not contain a single quote, so use single quotes around it.

    plain = "'" v "'"                                   :(return)

plain.double

*   Here if arguent contains single quote, so use double quotes around it.

    plain = '"' v '"'                                   :(return)

plain.end

    define('pop(stack)')                               :(pop.end)

*   _Pop_ removes (pops) the top item from stack, or fails if the stack is empty.

pop

    pop = stack
    eq(set.size(stack))                                :s(freturn)
    pop = set.key(stack)[set.index(stack)[set.size(stack)]]
    set.size(stack) = set.size(stack) - 1              :(return)

pop.end

    define('powerset(set)b,i,j,n,N,s,this')            :(powerset.end)

*   Return the powerset of _set_, defined as the set of all subsets of a set.

powerset

    powerset = new('set')

*   Let _n_ be the size of _set_.
*   The powerset of the empty set is the empty set.

    n = set.size(set)
    eq(n)                                              :s(return)

*   Compute _N_ = 2 to the powerset _n_.

    N = 1
    i = 0

powerset.N

    le(i = i + 1,n)                                    :f(powerset.N.done)
    N = N * 2                                          :(powerset.N)

powerset.N.done

*   Compute the powerset as follows:

*   Loop for i = 0 ... N - 1:
*       Let _b_ be the string containing the binary value of _i_, padded to length _n_.
*       Set _this_ to the empty set.
*       Loop for _j_ = _size(b)_ ... _1_
*           If the _j_-th character of _b_ is '1' then add
*           the _j_-th element of _set_ to _this_.
*       Add _this_ to _powerset_.

    i = -1

powerset.next.i

    lt(i = i + 1,N)                                    :f(return)
    b = binary(i,n)
    this = new('set')
    j = size(b) + 1

powerset.next.j

    gt(j = j - 1)                                      :f(powerset.j.done)
    s = substr(b,j,1)
    ident(s,'1') add(this,set.index(set)[j])
                                                       :(powerset.next.j)

powerset.j.done

    add(powerset,this)                                 :(powerset.next.i)

powerset.end
    define('prefix(str,pre)word')                      :(prefix.end)

*   _Prefix_ takes a list of space-separated words _str_ and prefixes each
*   with the str _pre_.

prefix

    str = str ' ';* so each word followed by space

prefix.1

    str break(' ') . word span(' ')  =                 :f(return)
    add1(.prefixcount)
    prefix = append(prefix, pre word,'A')              :(prefix.1)

prefix.end

    define('prime(n)')                                 :(prime.end)

*   _Prime_ tests if _n_ is a prime integer.

prime

    n = integer(n) +n
    eq(n,2)                                            :s(return)
    even(n)                                            :s(freturn)
    exists(new('iter 3 ' square.root(n) ' 2'), 'multiple(n,this)'):s(freturn)f(return)

prime.end

    define('primes(n)this')                            :(primes.end)

*   _Primes_ returns the set of primes less than _n_.

primes

    primes = filter(new('iter 2 ' (n - 1)),'prime(this)'):(return)
    primes = new('seq 2')
    iter = new('iter 2 ' (n - 1))
    loop(set)

primes.loop

    this = next(set)                                   :f(return)
    prime(this) push(primes,this)                      :(primes.loop)

primes.end

    define('push(stack,val1,val2,val3,val4,val5)') :(push.end)

*   _Push_ adds new value(s) to a stack or tuple, returning the updated
*   stack or tuple as its value.

push

    push = stack
    ident(val1)                                         :s(return)
    push.value(stack,val1)
    ident(val2)                                         :s(return)
    push.value(stack,val2)
    ident(val3)                                         :s(return)
    push.value(stack,val3)
    ident(val4)                                         :s(return)
    push.value(stack,val4)
    ident(val5)                                         :s(return)
    push.value(stack,val5)                              :(return)

push.end

    define('push.value(stack,value)')                   :(push.value.end)

*   _Push.value_ adds _value_ to a stack or tuple, returning
*   the updated stack or tuple as its value.

push.value

    push.value = stack
    ident(stack) error('push() first argument is null.')
    differ(datatype(stack),'set')
.       error('push() first argument is not a set, but instance of ' datatype(stack))
    ident(set.kind(stack),'map')                       :s(push.value.add)
    ident(set.kind(stack),'seq')                       :s(push.value.add)
    ident(set.kind(stack),'tup')                       :s(push.value.add)
    error('first argument to push.value must be set or map, is ' datatype(stack))

push.value.add

    put(stack,set.size(stack) + 1, value)              :(return)

push.value.end

    define('put(map,key,value)v')                      :(put.end)

*   _Put_ sets the value of the entry for key _key_ in map _map_ to be _val_,

put

    key = integer(key) +key
    value = integer(value) +value
    differ(set.key(map)[key])                          :s(put.value)

*   Here to create new entry in map, and then merge to set new value.

    set.size(map) = set.size(map) + 1
    set.index(map)[set.size(map)] = key

put.value

    set.key(map)[key] = value                          :(return)

put.end

    define('quicksort(seq)c,seq.eq,set.gt,seq.lt,pivot,this'):(quicksort.end)

*   _Quicksort_ sorts the sequence _seq_ using Hoare's quicksort algorithm.
*   _Seq_ must be sequence of integers or sequence of strings.

*   This program is for demonstrating SETL4.
*   Use the much more efficient _sorter_ for production use.

quicksort

    quicksort = le(set.size(seq),1) seq                :s(return)
    pivot = arbitrary(seq)
    number(pivot)                                      :f(quicksort.strings)

*   Here to sort sequence of integers.

    quicksort = join( quicksort(filter(seq,  'lt(value(this),pivot)')),
.                               filter(seq,  'eq(value(this),pivot)'),
.                     quicksort(filter(seq,  'gt(value(this),pivot)'))):(return)


*   Here to sort sequence of strings.

    quicksort = join( quicksort(filter(seq,  'llt(value(this),pivot)')),
.                               filter(seq,  'leq(value(this),pivot)'),
.                     quicksort(filter(seq,  'lgt(value(this),pivot)'))):(return)

quicksort.end

	define('random(n)')                                   :(random.end)

*	Return integer uniformly distributed in 1,2,...,n.
*	If n=0 returns real uniformly distributed in the interval [0,1].
*	The Algorithm is based on that in section 16.1 of "Algorithms in SNOBOL4,"
*	James F. Gimpel, John Wiley and Sons, 1976.

random

    ident(setl4.random.initialized) random.seed()
	setl4.random.value = remdr(setl4.random.value * 4676, 414971)
	random  = setl4.random.value / 414971.0
	random = ne(n) convert(random * n,'integer') + 1

*   Make sure random of integer never returns zero.

    random = integer(random) eq(random) 1
                                                       :(return)
random.end

	define('random.seed()s,c')                            :(random.seed.end)

*	Compute seed for random number generator from date and time.

random.seed
    differ(setl4.random.initialized)                   :s(return)
    setl4.random.initialized = 'TRUE'
	setl4.random.value =
	s = date()
	s = replace(s,'/                                      :-','123')

*	Get all the digits in s.

random.seed.loop

	s len(1) . c =                                        :f(random.seed.done)
	ident(c,' ')                                          :s(random.seed.loop)
	setl4.random.value = setl4.random.value c             :(random.seed.loop)

random.seed.done

*	Reverse the seed so digits depending on time come first.

	setl4.random.value = +reverse(setl4.random.value)
                                                       :(return)
random.seed.end

    define('range(map)elem)')                          :(range.end)

*   _Range_ returns the range of map, which is the set of the values in _map_.

range

    range = new()
    loop(map)

range.next

    entry = next(map)                                  :f(return)
    add(range,value(key(entry)))                       :(range.next)

range.end

    define('reader(filename,undent)line')              :(reader.end)

*   _Reader_ returns a sequence of the lines in the file specified by _filename_.
*   Lines are read from standard input if _filename_ is null.
*   If _undent_ is not null, leading spaces in lines are eliminated.

reader

    line  = input
    out('first',line)
    ident(filename)                                    :s(reader.read)
    input(.file,setl4.config.channel.1,filename)       :s(reader.opened)
    out('unable to open reader file ' filename '.')    :(freturn)

reader.read

    reader = new('seq')

reader.next

    line = (ident(filename) input, file)               :f(reader.eof)
    out(line)
    ident(line)                                        :s(reader.next)
    line '*'                                           :s(reader.next)
    ident(undent)                                      :s(reader.add)
    line span(' ') =

reader.add

    push(reader,line)                                  :(reader.next)

reader.eof

*   Here at end of file; close temporary file if one was needed.

    differ(filename) endfile(setl4.config.channel.1)   :(return)

reader.end

    define('reader.str(str,delim)line')                :(reader.str.end)

*   _Reader.str_ returns a sequence of the lines in _str_, where
*   the character _delim_ is used to indicate end of line.
*   If _delim_ is  not given, then '/' is understood.

reader.str

    delim = ident(delim) '/'
    reader.str = new('seq')

reader.str.next

    str break(delim) . line delim =                    :f(return)
    push(reader.str,line)                              :(reader.str.next)

reader.str.end

    define('remove(set,elem)i,iter,this')              :(remove.end)

*   _Remove_ removes the element _elem_  from the set _set_. _Remove_
*   does nothing if _elem_ is not a member of the set.

*   If _elem_ is new, remove the most recently added element of a set or map.
*   If _set_ is a set, then remove _elem_ from _set_ if it is a member.
*   If _set_ is a map, remove the entry with key _value_.
*   Return the element removed.

remove

    eq(set.size(set))                                  :s(freturn)
    ident(elem)                                        :s(remove.last)
    remove = elem
    ident(set.kind(set),'int')                         :s(remove.int)
    ident(set.kind(set),'map')                         :s(remove.map)
    ident(set.kind(set),'set')                         :s(remove.set)
    error('remove not defined for set of kind ' set.kind(set))

remove.int

    error("remove from set of kind 'int' not yet implemented.")

remove.last

    remove = set.index(set)[set.size(set)]
    set.size(set) = set.size(set) - 1                  :(return)

remove.map
remove.set

    ident(set.key(set)[elem])                          :s(return)

*   Find the entry with key _elem_, assuming it's more likely
*   to be a newer addition than one of the older elements.

    iter = new('iter ' set.size(set) ' 1')
    i = set.size(set) + 1

remove.find

    gt(i = i - 1)                                      :f(remove.error)
    ident(set.index(set)[i],elem)                      :f(remove.find)

*   Delete _elem_ from the key table, then move the entries
*   in the index table following this one down one position.
*   Nothing remains to be done if the set had only one element, or
*   if the element was the last in the index table.

    set.key(set)[elem] =
    set.size(set) = set.size(set) - 1
    eq(set.size(set))                                  :s(return)

remove.next

    eq(i,set.size(set))                                :s(return)
    set.index(set)[i] = set.index(set)[i + 1]
    i = i + 1                                          :(remove.next)

remove.error

    error('remove.set unable to locate member')

remove.end

    define('show(v,type,limit)ara,i,kind,elem,entry,key,line,hdr,n,this,str,value'):(show.end)

*   _Show_ displays the value of its first argument in a form that is hopefully both
*   readable and pleasing to the eye.

*   If _type_ is not null, sets and maps are ranked in order given by _type_.
*   Otherwise sets and maps are increased in ascending value of members (set)
*   or keys (map).

*   If _limit_ is not null, at most _limit_ elements of compount object _v_ are listed.

show


*   limit = differ(limit) +limit
    ident(v)                                            :s(return)

*   Show nothing by writing out nothing.

    ident(v)                                            :s(return)

    is.plain(v)  show.out(plain(v))                     :s(show.finis)

    ident(datatype(v),'array')                          :s(show.array)
    ident(datatype(v),'entry')                          :s(show.entry)
    ident(datatype(v),'table')                          :s(show.table)
    ident(datatype(v),'iterator')                       :s(show.iterator)
    differ(datatype(v),'set') error('unexpected datatype to show, ' datatype(v))

    type = ident(type) '+k'
    kind = set.kind(v)
    ident(kind,'int')                                  :s(show.int)
    ident(kind,'iter')                                 :s(show.iter)
    ident(kind,'map')                                  :s(show.map)
    ident(kind,'seq')                                  :s(show.seq)
    ident(kind,'set')                                  :s(show.set)
    ident(kind,'tup')                                  :s(show.tup)
    error('show unknown set kind',kind,' quitting.')

show.array

    proto = prototype(ara)
    proto break(',')                                   :s(show.array.2)

*   Here for one dimensional array.

show.array.1
    first = ara[add1(.i)]                              :f(show.array.done)
    show.out(lpad(i,3) tab first)                      :(show.array.1)

show.array.2
    first = ara[add1(.i),1]                            :f(show.array.done)
    show.out(lpad(i,3) tab show(first,type) tab show(ara[i,2],type)):(show.array.2)

show.array.done

                                                       :(show.finis)

show.entry

    is.plain(key(v)) is.plain(value(v))                :f(show.entry.notplain)
*   Out('plain entry stack size',set.size(show.stack))
    show.out(plain(key(v)) char(58) plain(value(v)))   :s(show.finis)

show.entry.notplain

*   Out('notplain entry stack size',set.size(show.stack))
    show(key(v))
    show(char(58)) 
    show(value(v))
                                                       :(show.finis)
show.iterator

    show.out('{iterator')
    ne(+iter.start(v))  show.out(' start ='  iter.start(v))
    ne(+iter.finis(v))  show.out(' finis ='  iter.finis(v))
    ne(+iter.step(v))   show.out(' step  ='  iter.step(v))
    show.out('} ')                                     :(show.finis)

show.int
show.iter
show.map
show.set

    encloser = '{}'                                    :(show.compound)

show.pair

    is.plain(first(v)) is.plain(second(v))             :f(show.pair.notplain)
    show.out('(' plain(first(v)) ',' plain(second(v)) ')') :(show.finis)

show.pair.notplain

    show.out(first(v))
    show.out(char(58))
    show(second(v))                                    :(show.finis)

show.seq

*   If the sequence has fewer than ten elements, list as a tuple.

    kind = lt(set.size(v),10) 'tup'
    lt(set.size(v),10)                                  :s(show.tup)
    encloser = '[]'                                     :(show.compound)

show.tup

    encloser = '[]'                                     :(show.compound)

show.compound

    sorter(v,type)
    loop(v)
    show.out(substr(encloser,1,1))
    show.level = show.level + 1

show.compound.next

    elem = next(v)                                      :f(show.compound.done)
    is.plain(elem)     show(plain(elem))                :s(show.compound.next)
    ident(kind,'int')  show(elem)                       :s(show.compound.next)
    ident(kind,'iter') show(elem)                       :s(show.compound.next)

*   show = ident(datatype(value(entry),'token'))
*               show  show.token(v,,'TRUE')             :s(show.map.check)

    ident(kind,'map')   show(elem)                      :s(show.compound.next)
    ident(kind,'seq')   show(elem)                      :s(show.compound.next)
    ident(kind,'set')   show(elem)                      :s(show.compound.next)
    ident(kind,'tup')   show(value(elem))               :s(show.compound.next)
*   lt(limit = limit -1)                                :s(show.compound.done)

show.compound.done

    show.level = show.level - 1
    show.out(substr(encloser,2,1))
            :(show.finis)

show.table

    show.out('[')
    ara = convert(v,'array')                           :f(show.table.error)
    i = 0
    prototype(ara) break(',') . n                      :(show.table.next)

show.table.error

    error('error converting table to array')

show.table.next

    le(i = i + 1,n)                                    :f(show.table.done)
    show(ara[i,1])                                     :(show.table.next)

show.table.done

    show.out(']')                                       :(show.finis)

show.finis

    show.done()                                         :(return)

show.end

    define('show.done()')                              :(show.done.end)

*   Write out _show.line_ unless in midst of showing compound object.

show.done

    le(size(show.line),72)                             :s(show.done.finis)

*   Here to write out long line.

    out(show.line)
    show.line =

show.done.finis

    gt(show.level)                                     :s(return)
    differ(show.line) out(show.line)
    show.line =                                        :(return)

show.done.end

    define('show.out(str)')                            :(show.out.end)

*   Append _str_ to _show.line_.

show.out

    str = integer(str) +str                            :s(show.out.show)
    differ(datatype(str),'string')
.       error('show.out expects argument to be string, but got ' datatype(str))

show.out.show

    show.line = show.line (differ(show.line) ' ', '') str
*   show.line = show.line  str
    le(size(show.line),72)                             :s(return)
    out(show.line)
    show.line =                                        :(return)

show.out.end

    define('show.b(e)')                                :(show.b.end)

*   _Show.b_ shows the value if its argument as a boolean value: TRUE or FALSE

show.b

    integer(e) out((ne(e) 'TRUE', 'FALSE'))            :s(return)
    out((differ(e) 'TRUE', 'FALSE'))                   :(return)

show.b.end

    define('show.eval(expr)e')                         :(show.eval.end)

*   _Show.eval_ evaluates its argument and returns 'success' if
*   the evaluation succeeded, or 'failure' if not.

show.eval

    eval(expr)                                         :s(show.eval.success)
    show.eval = 'failure'                              :(show.eval.finis)

show.eval.success

    show.eval = 'success'

show.eval.finis

    out('eval ' expr ' ' show.eval)                    :(return)

show.eval.end

    define('show.lines(lines,number)i,line')           :(show.lines.end)

*   Show a sequence of lines, including the line number if _number_ not null.

show.lines

    loop(lines)

show.lines.next

    line = next(lines)                                 :f(return)
    i = i + 1
    gt(i,100) error('i too big')
    ident(number)    out(line)                         :s(show.lines.next)
    differ(number)   out(lpad(i,4) '  ' line)          :(show.lines.next)

show.lines.end

    define('slice(v,start,n)')                         :(slice.end)

*   _Slice_ returns a slice of a sequence, string or tuple.
*   For a string _slice_ is equivant to SPITBOL's _substr_.

slice

    slice = ident(datatype(v),'string') substr(v,start,n) :s(return)

*   Here to compute slice of a string or tuple.

    slice = new(set.kind(v))
*   Out('slice kind',set.kind(v))
    n = ident(n) set.size(v) - start + 1
    lt(start,1)                                         :s(freturn)
    gt(start + n - 1,set.size(v))                       :s(freturn)
    start = start - 1

slice.next

*   Out('slice.next start',start)
*   Out('pushing ',get(v,start = start + 1))

    push(slice,get(v,start = start + 1))
    gt(n = n - 1)                                       :s(slice.next)f(return)

slice.end


    define('sorter(set,type)ara,entry,i,key,index.table,map,n,seq,str,tbl,value.table,value'):(sorter.end)

*   _Sorter_ sorts the index table of _set_ according to _type_ to reflect
*   a desired sort of the elements of set, keys or maps, or values of map.
*   _Sorter_ doesn't create a new set, but just updates the index table so that,
*   going forward, entries will be visited in the order specified by _type_.

*   _Sorter_ can also be used to put a string in normal form by converting the string
*   into a sequence of the characters in the string and then sorting the range
*   of the sequence.

*   The argument _type_ specifies the ordering to be used:

*       '+index'    increasing order of when entry created (oldest first)

*       '-index'    decreasing order of when entry created (most recent first)

*       '+key'      increasing order of the values in the domain

*       '-key'      decreasing order of the values in the domain

*       '+value'    increasing order of the values in the range

*       '-value'    decreasing order of the values in the range

*   Types for keys and values may be abbreviated: "+key" may be written
*   as "+k" or "+ke", "+value" as "+v" or +"val", and so forth.

sorter

    ident(type) error('sorter null type.')
    ident(type,'no')                                   :s(return)

*   Use _sorter.string_ if input is a string.

    sorter = ident(datatype(set),'string') sorter.string(set):s(return)

    n = set.size(set)
    index.table = set.index(set)

*   Here to detect cases for which sort has no meaning, in which case
*   return immediately. This includes the case 'int' which, though possible
*   to sort as desired, requires a complicated algorithm that has yet to be
*   thought through.

    type = get(sorter.types,type)

    differ(datatype(set),'set') error('sorter - unsupported input type ' datatype(set) )
    ident(datatype(set),'set') ident(set.kind(set),'int'):s(return)
    ident(datatype(set),'set') ident(set.kind(set),'iter'):s(return)

*   Nothing to do if set is empty or only has one element.

    le(n,1)                                            :s(return)
    differ(datatype(set),'set') error('sorter bad datatype ' datatype(set))
    ident(type) error('sorter null type')

    ident(type,'+v')                                   :s(sorter.value)
    ident(type,'-v')                                   :s(sorter.value)

    tbl = sorter.set(set,type)
    differ(datatype(tbl),'table') error('sorter result not table')
                                                       :(sorter.finis)
    i = 0

sorter.index.next

    error('why did we reach here')
    le(i = i + 1,n)                                    :f(sorter.finis)
    tbl[i] = set.index(set)[ara[i,1]]                  :(sorter.index.next)

sorter.value

*   Here to  sort by value: build table mapping index numbers into
*   the values associated with their keys, and sort that.

    tbl = compose(set.index(set),set.key(set))
    type = ident(type,'+v') '+k'
    type = ident(type,'-v') '-k'
    value.table = sorter.table(set,type,tbl)
    i = 0

*   The table is in proper order, so replace values with the keys
*   associated with that value.

sorter.value.next

    le(i = i + 1,n)                                    :f(sorter.finis)
    tbl[i] = value.table[i]                            :(sorter.value.next)

sorter.finis

    set.index(set) = tbl                               :(return)

sorter.end

    define('sorter.set(set,type)ara,i,index')          :(sorter.set.end)

*   _Setl4.table.sorter_ returns an index table derived from the
*   index table of _set_ that reflects the ordering given by _type_.

sorter.set

    le(set.size(set),1)                                :s(return)
    ara = ident(type,'+i')    sort( set.index(set), 1) :s(sorter.set.1)
    ara = ident(type,'-i')    rsort(set.index(set), 1) :s(sorter.set.1)
    ara = ident(type,'+k')    sort( set.index(set), 2) :s(sorter.set.1)
    ara = ident(type,'-k')    rsort(set.index(set), 2) :s(sorter.set.1)

    error('sorter.set unsupported key type             : ' type)

sorter.set.1

    differ(datatype(ara),'array')
.               error('sorter.set sort result not array:' datatype(ara))

    sorter.set = table(n)
    index = 0

sorter.set.set.next

    le(i = i + 1,n)                                    :f(return)
    index = ara[i,1]
    sorter.set[i] = set.index(set)[index]              :(sorter.set.set.next)

sorter.set.end

    define('sorter.string(str)ara,c,i,tbl')            :(sorter.string.end)

*   _Sorter_sorts a string into a string with all the characters
*   in lexical (alphabetic) order.

sorter.string

    tbl = table(size(str))

sorter.string.tbl

    c = substr(str,i = i + 1,1)                        :f(sorter.string.sort)
    tbl[i] = c                                         :(sorter.string.tbl)

sorter.string.sort

*   Sort the table and rebuild the string in sorter order.

    i = 0
    ara = sort(tbl,2)

sorter.string.next

    c = ara[i = i + 1,2]                               :f(return)
    sorter.string = sorter.string c                    :(sorter.string.next)

sorter.string.end

    define('sorter.table(set,type,tbl)ara,i,index')    :(sorter.table.end)

*   _Setl4.table.sorter_ returns an index table derived from the
*   index table of _set_ that reflects the ordering given by _type_.

sorter.table

    le(set.size(set),1)                                :s(return)

    ara = ident(type,'+i')    sort(tbl,1)              :s(sorter.table.1)
    ara = ident(type,'-i')    rsort(tbl,1)             :s(sorter.table.1)
    ara = ident(type,'+k')    sort(tbl,2)              :s(sorter.table.1)
    ara = ident(type,'-k')    rsort(tbl,2)             :s(sorter.table.1)
    error('sorter.table unexpected type                :' type)

sorter.table.1

    sorter.table = table(n)
    index = 0

sorter.table.table.next

    le(i = i + 1,set.size(set))                        :f(return)
    index = ara[i,1]                                   :f(sorter.table.error)
    sorter.table[i] = index.table[index]
                                                       :(sorter.table.table.next)
sorter.table.error

    error('sorter.table error, array out of bounds reference.')

sorter.table.end

    define('split.line(line)word')                     :(split.line.end)

*   _Split.lines_ splits a line into a sequence of words, where words are separated by one of more spaces.

split.line

    split.line = new('seq')
    line span(' ') =
    ident(line)                                        :s(return)
    line = line ' '

split.line.next

*   Here to split line into a sequence of its words.

    line break(' ') . word span(' ') =                 :f(return)
    push(split.line, word)                             :(split.line.next)

split.line.end

    define('split.string(str)c')                       :(split.string.end)

*   _Split.str_ returns a sequence of the characters in _str_.

split.string

    split.string = new('seq')
    str span(' ') =
    ident(str)                                         :s(return)

split.string.next

*   Here to split.stringing into a sequence of its characters.

    str len(1) . c =                                   :f(return)
    put(split.string,i = i + 1, c)                     :(split.string.next)

split.string.end

    define('square.root(n)')                           :(square.root.end)

*   _Square.root_ returns the square root of its argument, rounded up.

square.root

    square.root = int(sqrt(n)) + 1                     :(return)

square.root.end

    define('subset(a,b)elem')                          :(subset.end)

*   _Subset_ tests if its second argument is a subset of the first.

subset

    gt(set.size(b),set.size(a))                        :s(freturn)
    loop(b)

subset.next

    elem = next(b)                                     :f(return)
    member(a,elem)                                     :s(subset.next)f(freturn)

subset.end

    define('this(set)')                                :(this.end)

*   _This_ returns the value determined in the most recent call to next.

this

    this = iter.thisname(set)                          :(return)

this.end

    define('thousands(s)n')                            :(thousands.end)

*   _Thousands_ formats its argument by inserting comma's every three digits from right.

thousands

    n = size(s)
    thousands = le(n,3) s                              :s(return)
    thousands = thousands(substr(s,1,n - 3)) ',' substr(s, n - 2, 3):(return)

thousands.end

*#  Tokens: Lexical Scanning


*   A token is represented as an instance of the datatype _token_ as follows:

    data('token(lineno,col,type,text)')

*   where:
*           _lineno_        is the line number within the file;
*           _col_           is the index (column number) of the first character of the token in the line;
*           _type_          is the token's type, as described below; and
*           _text_          is the text of the token.

*   The type is represented by a single character, as follows:

*           'c'             comment, indicated by asterisk (*) in the first column.
*                           The text consists of the entire line.

*           'i'             integer, consisting of one or more digits ('0123456789')

*           'l'             left opener, one of '(<[{'

*           'p'             punctation, one of '.;,?!', or single quote (') or double quote ("),

*           'o'             other printable character, one of '~@#$%^&*_-+=`'.

*           'q'             quoted str, starting witn '"', and continuing to the next instance of the opening quote character.

*           'r'             right closer, one of ')>]}'

*           's'             space, consistine of one or more spaces (spaces)

*           't'             tab character

*           'u'             unprintable character, for example control-k

*           'w'             word, consisting of one of more letters in upper or lowercase, or "'" or "_".

*   The longest possible string meeting the rules is used when building a token.
*   For example, 'abc' is just the word 'abc', not 'a' followed by 'bc', and so forth.

*   It is recommended that the tab character NOT be used as an abbreviation for
*   one or more spaces in the input file. If tabs are used, then _col_ is ill-defined.
*   If tabs are not used, then _col_ indicates the true position in the line of
*   the first character of the token, and so error messages and references to the
*   token will be exact.  For example, _pos_ could be used to indicate where to give
*   emphasis to a token by underlining it, or enclosing it in '_' to generate
*   markdown format, and so forth.

    define('tokens(line)type,pos,text,lineno')         :(tokens.end)

*   _Tokens_ scans a line _line_ and returns a table of the tokens in the line.
*   The table has keys from 1..n, where _n_ is the number of tokens found.

*   This function is an instance of what is called a lexical scanner, or tokenizer.
*   This is the first stage in a programming language compiler, or for any program
*   that processes text files with a specified structure.

tokens

    tokens = new('seq')
    line '*'                                           :f(tokens.next)
    type = 'c'
    text = line
    line =                                             :(tokens.new)

tokens.next

    line ' '                                           :s(tokens.space)
    line any('0123456789')                             :s(tokens.integer)
    line any('(<[{')                                   :s(tokens.left)
    line any('.;,?!')                                  :s(tokens.punctuation)
    line '"'                                           :s(tokens.quote)
    line any('~@#$%^&*_-+=')                           :s(tokens.other)
    line any(')>]}')                                   :s(tokens.right)
    line char(9)                                       :s(tokens.tab)
    line any(&lcase &ucase)                            :s(tokens.word)

*   Here for unprintable
    error('unprintable?? fix in tokens')

tokens.integer

    type = 'i'
    line span('0123456789') . text =                   :(tokens.new)

tokens.punctuation

    type = 'p'                                         :(tokens.character)

tokens.other

    type = 'o'                                         :(tokens.character)

tokens.quote

    type = 'q'
    line '"' break('"') . text '"' =
    text = '"' text '"'                                :(token.new)

tokens.right

    type = 'r'                                         :(tokens.character)

tokens.space

    type = 's'
    line span(' ')  . text =                           :(tokens.new)

tokens.tab

    type = 't'                                         :(tokens.character)

tokens.word

*TODO*
    type = 'w'
    line span(&ucase &lcase "_" "'") . text =          :(tokens.new)

tokens.character

*   Here if token is single character.

    line len(1) . text                                 :(tokens.new)

tokens.new

    setl4.add(tokens,token(lineno,pos,type,text))      :(tokens.next)

tokens.end

    define('tolower(s)')                               :(tolower.end)

*   _Lower.case_ converts argument to tolower.

tolower

    tolower = replace(s,&ucase,&lcase)                 :(return)

tolower.end

    define('top(seq)')                                 :(top.end)

*   _Top_ returns the last element of a sequence, or fails if the sequence is empty.

top

    differ(datatype(seq),'set')  error('argument to top is not a set')
    eq(set.size(seq))                                  :s(freturn)
    ident(set.kind(seq),'seq')                         :s(top.get)
    ident(set.kind(seq),'tup')                         :s(top.get)
    error('argument to top() is not sequence or tuple.')

top.get

    top = get(seq,set.size(seq))                       :(return)

top.end

    define('toupper(s)')                               :(toupper.end)

*   _Upper.case_ converts its argument to toupper.

toupper

    toupper = replace(s,&lcase,&ucase)                 :(return)

toupper.end

    define('traceoff()')                               :(traceoff.end)

*   _Traceoff_ ends tracing.

traceoff

    &ftrace = &trace =
    out('stop TRACING ')

traceoff.end

    define('traceon()')                                :(traceon.end)

*   _Traceon_ begins tracing.

traceon

    out('start TRACING')
*   &ftrace = &trace = 1500000
    g.scoring = g.tracing = 1
                                                       :(return)
traceon.end

    define('true(e)')                                  :(true.end)

*   _True_ Tests if its operand is true

true

    e = integer(e) +e
    integer(e) ne(e)                                   :s(return)
    differ(e)                                          :s(return)f(freturn)

true.end

    define('union(a,b)elem')                           :(union.end)

*   _Union_ returns the union of sets _a_ and _b_.

union

*   Arrange so set _a_ is the larger

    ge(set.size(a),set.size(b))                        :s(union.a)
    union = a
    a = b
    b = union

union.a

*   Make copy of _a_ to start things off.

    union = copy(a)
    loop(b)

union.b

    elem = next(b)                                     :f(return)
    add(union,elem)                                    :(union.b)

union.end

    define('visit(set,expr)this')                      :(visit.end)

*   _Visit_ loops over _set and calls _eval_ with argument
*   _expr_  for each of member of the set.

visit

    loop(set)

visit.next

    this = next(set)                                   :f(return)
    eval(expr)                                         :(visit.next)

visit.end

    define('words(line,w)word')                        :(words.end)

*   _Words_ returns a sequence of the words in _line_, where _w_
*   is a string that defines the allowed characters in a word.

words

    words = new('seq #' size(line))

words.next

    line span(w) . word =                              :s(words.add)

*   No word begins at this character, so move on to the next one.

    line len(1) =                                      :f(return)s(words.next)

words.add

    push(words, word)                                  :(words.next)

words.end

    define('writer(lines)')                            :(writer.end)

*   _Writer_ writes the lines in the sequence _lines_ to standard output.

writer

    loop(lines)

writer.next

    output = next(lines)                               :f(return)s(writer.next)

writer.end

*## SETL4 internal functions

*   Functions whose names begin with _setl4_ are for internal use only, and are
*   not meant to be called directly by the SETL4 user.

*   Their definitions and implmentations may change at any time, so use them
*   directly at your own peril.


    define('setl4.clear()')                            :(setl4.clear.end)

*   _Setl4.clear) clearis the values of setl4 global variables. This reduces amount of &dump output.

setl4.clear

    setl4.config.set.table.size = setl4.config.stack = setl4.config.set.table.size = setl4.config.int =
.   setl4.ascii.initialized = setl4.ascii.name = setl4.config.int.init =
.   setl4.ascii.value = setl4.random.initialized = setl4.any.digit = setl4.span.digits =
.   setl4.break.digit = setl4.break.letter = setl4.any.letter =
.   setl4.span.letters = setl4.span.spaces = setl4.break.space =
.   setl4.any.word = setl4.span.word = setl.sorter.map = sorter.types =
                                                       :(return)
setl4.clear.end

    define('setl4.show(set)iter')                      :(setl4.show.end)

*   Setl4.show_ shows  the fields of an instance of _set_ or _iterator_.

setl4.show

    ident(datatype(set),'iterator')                    :s(setl4.show.iter)
    ident(datatype(set),'set')                         :s(setl4.show.set)
                                                       :(return)

setl4.show.iter

    setl4.show =  out('(iterator '
.            (ne(iter.start(set)) ' start              :'     +iter.start(set), '')
.            (ne(iter.finis(set)) ' finis              :'     +iter.finis(set),'')
.            (ne(iter.step(set))  ' step               :'      +iter.step(set),'') ')' )
                                                       :(return)

setl4.show.map
setl4.show.seq
setl4.show.set

    iter = set.iter(set)
                                        out('{')
                                        out('  kind',     plain(set.kind(set)))
    ne(set.size(set))                   out('  size',     set.size(set))

    differ(set.index(set)) differ(set.key(set))
.                                       out('  has index and key tables')

*   differ(set.index(set))              out('  has index table')
*   differ(set.key(set))                out('  has key table')

*   differ(iter)                        out('  has iterator')
    differ(iter) ne(iter.start(iter))   out('  start',    iter.start(iter))
    differ(iter) ne(iter.finis(iter))   out('  finis',    iter.finis(iter))
    differ(iter) ne(iter.step(iter))    out('  step',     iter.step(iter))
                                        out('}')
    differ(set.index(set)) differ(datatype(set.index(set)),'table')
.           error(' set.index is not table')
    differ(set.key(set)) differ(datatype(set.key(set)),'table')
.           error('set.key is not table')
                                                       :(return)
setl4.show.end

    define('setl4.size(set)')                          :(setl4.size.end)

*   Setl4.set.size_ returns the  size of operand.

setl4.size

*   out('enter setl4.size')
*   setl4.show(set)
    setl4.size = ident(datatype(set),'string') size(set):s(return)
    setl4.size = differ(iter.step(set)) (iter.finis(set) - iter.start(set) / iter.step(set)) + 1:s(return)
    setl4.size = set.size(set)                         :(return)

setl4.size.end

    define('Out(text1,text2,text3)type1,type2')        :(Out.end)

*   _Out_ is just another name for _out_. Use it for debugging, as
*   will be the be easy to find calls to it, to delete them once they
*   have served their purpose.

Out

    out('O:' text1,text2,text3)                        :(return)

Out.end


*## SETL4 Global variables

    setl4.ascii.initialized =
    setl4.ascii.name =
    setl4.ascii.value =
    setl4.random.initialized =
    setl4.random.value = 2017

*   Useful patterns

    setl4.any.digit         =   any('0123456789')
    setl4.span.digits       =   span('0123456789')
    setl4.break.digit       =   break('0123456789')

    setl4.break.letter      =   break(&lcase &ucase)
    setl4.any.letter        =   any(&lcase &ucase)
    setl4.span.letters      =   span(&lcase &ucase)
    setl4.span.spaces       =   span(' ' char(9))
    setl4.break.space       =   break(' ' char(9))

    setl4.any.word          =   any(&lcase &ucase '0123456789')
    setl4.span.word         =   span(&lcase &ucase '0123456789')

    setl4.random.value      = 2017
*   sorter.types gives valid values for the argument _type_ in the function _sorter()_

    sorter.types = new('map '
.      '+:+k +k:+k +ke:+k +key:+k -:-k -k:-k -ke:-k -key:-k '
.      '+v:+v +va:+v +val:+v +valu:+v +value:+v -v:-v -va:-v -val:-v -valu:-v -value:-v '
.      '+i:+i +in:+i +ind:+ +inde:i+i +index:+i -i:-i -in:-i -ind:- -inde:i-i -index:-i')

*   Show.level is set non-zero when listing elements within a compound object.

    show.level = 0

*   _setl4.config.library.texts_ is a set of the names of the available texts.

    setl4.config.library.texts = new('set dictionary genesis hamlet new-testament old-testament romeo-and-juliet shakespeare sonnets')

*   Here endeth the SETL4 code.
*   May you fare well using it.

*** Rest of code is for opsyn. Not working, so comment out for now (DS 3 Jul 2017)
**  _Setl4.opsyn_ uses _opsyn_ to define a SETL4 operator.
*
*setl4.op
*
*    out('setl4.op op',ch)
*    out('setl4.op proc',proc)
*    out('setl4.op n',n)
*    opsyn(ch,proc,n)                                    :s(return)
*
*    error('fatal problem with opsyn for ' ch)
*
*   SETL4 uses some of the undefined SPITBOL operators for SETL4 functions.

*   Characters available for use by 'opsyn' to associate the character
*   with a function.

*   binary  &  @  #  %  ~
*   unary:  !  %  /  #  =  | /

*setl4.op.end
*   define('setl4.op(ch,proc,n)')                       :(setl4.op.end)
*
*    out('at setl4.op.end')
**   SETL4 binary operators
*
**   setl4.op('@','filter',2)
**   setl4.op('~','member',2)
**   opsyn('@','filter',     2)
**   opsyn('~','member',     2)
*
* &dump = 3
**   SETL4 unary operators:
*
**   opsyn('=','this',       1)
**   opsyn('|','new',        1)
**   opsyn('!','not',        1)
**   opsyn('#','setl4.size', 1)
**   opsyn('/','split',      1)
*
*
**## SETL4 Unary Operators:
*
**   '='     =s      Iteration       Returns 'this', the current element of an iteration
**   '|'     |str    Constructor     Returns set specified by string _str_
**   '!'     !expr   Not             True if and only if _expr_ is false
**   '#'     #s      Size            Number of elements in set _s_
**   '/'     /s      Split           Divides a string into a sequence of words
*

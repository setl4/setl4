*   Copyright 2017, David Shields
*   Licensed under the MIT license.

*# SETL4 - An Implementation of SETL Written in SPITBOL


*## What is SPITBOL?

*   SNOBOL is a general purpose programming language with special emphasis
*   on processing strings and text that was developed at Bell Labs in the
*   1960's by a team led by Ralph Griswold. The final version was called SPITBOL4.

*   Macro SPITBOL, or SPITBOL, is a very efficient implementation of SNOBOL4.
*   Created by Robert B. K. Dewar and Ken Belcher in 1969, SPITBOL/360
*   was written in IBM/360 assembly language, in a style Dewar termed
*   "aggressive assembly." That is, using every trick in the book to write
*   the fastest, most compact, code possible.
*
*   For example, SNOBOL4 requires maintaining a count of the number of
*   statements executed and the ability to stop execution when a specified
*   number of statements have been executed.  SPITBOL/360 does this by
*   computing an unnormalized floating point constant such that successive
*   increments of it result in floating point overflow when the limit is reached.

*   Dewar and Belcher also wrote Realia COBOL, a COBOL compiler for Intel/x86
*   written in COBOL. It produced very efficient code, better code than,
*   for example, that produced by IBM's product COBOL compiler.

*   Dewar ported SPITBOL/360 to several machines. Dewar joined the faculty
*   of the Courant Institute of Mathematical Sciences (CIMS) of New York
*   University (NYU) as a Professor in the early 1970's. In 1973,
*   while working with Anthony P. "Tony" McCann of Leeds University,
*   Dewar created Minimal, a portable assembly language. Dewar and
*   McCann then rewrote SPITBOL in Minimal, resulting in Macro SPITBOL,
*   or SPITBOL. The implementation has proved very stable, with only
*   minor changes in the last several decades.

*   Macro SPITBOL is remarkably small. The code consists of about 28,000
*   lines: 2000 lines of comments defining Minimal, 5000 lines of constant/data
*   declarations, and 21,000 lines of code.  Every line of code has a comment.
*   The executable for x86 Linux is less than 150 kilobytes.

*   SPITBOL was implemented for several machines and operating systems by
*   a small team that included Steve Duff, Mark Emmer, Bob Goldberg, and Dave Shields:
*   ICL 1900, Univac, CDC 6600, IBM PC, Apple Macintosh, SUN Solaris Sparc,
*   Microsoft (DOS/NT/Windows), Intel x86_64 (Unix/Linux), and x86_64 Apple iOS.
*   Special credit is due Mark Emmer, who led the project from the mid 1980's
*   to 2009, when Dave Shields became the maintainer of SPITBOL.

*   SETL4 requires a modified version of standard SPITBOL called SPITBOL4.
*   SPITBOL4 differs from standard SPITBOL as follows:
*
*-  There is no automatic case folding. In standard SPITBOL the names 'x' and 'X' are the same;
*   they are different in SPITBOL4.
*-  The default case is lower case.
*-  The function _set()_ has been renamed to _zet_, so that _set_ can be used as an identifier.
*-  The default value of _&anchor_ is 1. The default value of _&trim_ is 1.

*   The file `bin/setl4' provided as part of the distribution is the executable for _spitbol4_.

*## What is SETL?

*   SETL (SET Language)  is  a programming language with  finite sets as
*   the fundamental data type. It was created by Jacob T. "Jack" Schwartz
*   of the Courant Institute of Mathematical Sciences (CIMS) of New York
*   University (NYU).

*   Jack founded the SETL project in 1970. It was later funded by two
*   five-year grants from the Office of Naval Research.

*   SETL was used to write NYU Ada/Ed, the first validated Ada compiler.
*   Devloped on the DEC Vax 11/780, Ada/Ed was ported to the IBM PC (DOS)
*   by a team led by Dave Shields.


*## Why the name SETL4?

*   The SETL Project produced three implementations of SETL. The first was
*   written by Dave Shields in BALM, a language developed by Prof. Malcom
*   Harrison of CIMS, the second by Henry S. "Hank" Warren in PL/I while on
*   leave from IBM, and the third by Robert B. K. Dewar and Art Grand in LITTLE,
*   a low-level implementation language developed at CIMS.

*   SETL4 is the fourth implementation of SETL produced during the course of
*   the SETL Project.  Dave Shields wrote the first implementation. This was
*   followed by two more implementations. This is the fourth implementation
*   written by a member of the SETL project,  hence the name SETL4.


*## Brief Introduction to SETL4

*   SETL4 extends SPITBOL by adding the datatype _set_ to represent finite sets.

*   A set is a collection of distinct elements: for example,  _{a,b,c}_ is a set,
*   as is _{a,b,c,a}_; however, _{a,b,c,a}_ has only three elements, and is
*   equal to _{a,b,c}_.

*   For example, the folowing SETL4 expression determines if the integer _P_ is prime:

*           !exists(|'int 2 P' @ 'multiple(P,this)')

*   where _multiple(a,b)_ is true if and only if _a_ is a multiple of _b_.

*## Sets in SETL4

*   SETL4 provides several kinds of sets.

*   Sets of kind 'set' are a collection of distinct members.

*   Sets of kind 'map' consist of a series or ordered pairs,
*   called entries. The first element of an entry is the key,
*   and the second is the value.  No two entries in the map can
*   have the same key but different values.

*   Sets of kind 'iterator' consist of  integers of the form
*```
*   low, low + step, ... high
*```

*   or

*```
*   high, high - step ... low
*```

*   If only _low_ is specified, then the iteator is interpreted as 'iterator 1 low'.
*   For example, 'iterator 100' is the set 1, 2, ... 100.
*   and 'iterator 5 25 5' is the set {5 10 15 20 25}; where
*   iteration over the iterator will go in order 5, 10 ... 25.
*   'iterator 25 5 -5' is the same set; but iteration will
*   go in the order 25,20 ... 5.
*
*   If _high_ is less than _low_, then a negative step is undersood,
*   even if it is given as a positive value. For example, both
*   `iter 25 5 -5` and `iter 25 5 5' go in order "25, 20 ... 1"

*   Iterators support efficient iteration, but they provide only
*   the operations of iteration and membership; you cannot
*   add or remove an element from an iterator.

*   Sets of kind 'integer' are intended or sets of integers
*   containing many elements. See below for more details.

*   A sequence is a map defined on a set of consecutive positive integers.
*   For example 'sequence 5' is a map defined on 1, 2, ... 5.

*   Sequences are represented in the same way as a map. They differ from a map only
*   in that iteration over a sequence returns the values of the sequence, not the
*   instances of _entry_ that are returned when iterating over a map.

*   By convention, the kinds are writtten 'int', 'iter', 'map', 'seq', and 'set'.


*## Set Data Type

*   A set is a collection unequal objects, and is represented in SETL4 by the datatype _set_:

    data('set(set.kind,set.iter,set.index,set.key,set.size,set.encloser,'
.   'set.block,set.blocks,set.offset,set.str)')

*   where

*- _set.kind_          is the kind of the set: 'integer', 'iterator', 'map', 'sequence', or 'set'.
*                      The kind is specified when the set is created. The default kind is 'set'.
*                      The kinds are abbreviated below as:'int', 'iter', 'map', 'seq', or 'set'.

*- _set.iter_ iterator for controlling iteration over the set.

*- _set.index_         SPITBOL table used to map the integer id assigned
*                      each element to the value of the element.
*                       It is needed to support iteration.

*- _set.key_  SPITBOL table mapping set elements to index entries.

*- _set.size_          the current number of members.

*- _set.encloser_      characters used to enclose value when showing this set


*   The following fields are used only for sets of kind 'int':

*- _set.block_         block

*- _set.blocks_        number of blocks

*- _set.offset_        offset within block corresponding to a given integer

* _set.str_            is used to update the current block's membersip string
*                      for sets of kind 'init'


*   New elements in the set are assigned an integer id. The table _set.index_
*   maps the id to a key; it is used to iterate over the set. The table
*   _set.key_ maps a key to its associated value; it is used to retrieve element values.

*## Sets of integers

*   SETL4 sets of kind _integers' provide an efficient implementation of a set with
*   many non-negative integers, such as  a set with more than a million integers.
*
*   The set is represented by a table of strings, each with  _setl4.config.int_ characters,
*   so that the first block represents the integers `0 .. _setl4_config.int_ -1 and so forth.
*   Addition to  the set is done by setting the appropriate character in a block to '+'.
*   New blocks are allocated only when necesary.

*   The SPITBOL function BREAK is used to find the next element
*   in the set when iterating over the set.

*## Ordered Pairs

*   In set theory, sets are not ordered. The set _{a,b}_ is the same as (equal to)
*   the set _{b,a}_.

*   Although sets are not ordered, sets can be used to define an ordered pair:

    data('pair(first,second)')

*   by defining _pair(a,b)_ to be
*
*       _{a,{a,b}}_
*
*   It is easy to prove that, given this definition, _pair(a,b)_ is equal
*   to _pair(c,d)_ if and only if _a_ is equal to _c_ and _b_ is equal to _d_.


*## Maps

*   A map defined on a finite set is a set of ordered pairs,
*   or entries, that define a relation between the first element of an entry,
*   its _key_, and the second element of the entry, the value of the map for _key_.

    data('entry(key,value)')

*   A set of ordered pairs is a map if and only if there do not exist two entries
*   _entry(a,b)_ and _entry(c,d)_ such that _a_ is equal to _c_ and _b_ is not equal to _d_.
*   For example, the map defined by the set _{[one,1],[2,two],[one,1]}_ is valid, but
*   one cannot define a map based on the set _{[one,1],[2,two],[one,3]}_.

*   However, SETL4 does allow the use of a set of pairs that would not
*   be allowed in stanard set theory to define a map. If two of more pairs
*   have the same first value, the the last such pair encountered defines the
*   value to be used. For exampe, the set _{entry(one,1),entry(2,two),entry(one,3)}_ produces
*   the same map as _{entry(one,3),entry(2,two)}_.

*   Though you can use _entry to give a key and its associated value, the
*   preferred convention is separate a key and its value with a colon.
*   allows you to write "key:value," 
*```
*       new('map' one:1 two:2 three:3')

*```

*   instead of

*```
*       new('map' entry('one',1) ' ' entry('two',2) ' ' entry('three',3) )
*```

*   Though in set theory, maps are defined in terms of sets, in the SETL4
*   implementation, sets are represented are maps, by mapping each element
*   to itself. For example, the set _{a,b,c}_ is kept as the map: {a:a,b:b,c:c}.

*   SETL4 supports adding entries to a set of kind _map_ by using the
*   key and value in the entry to define the value of the map for _key(entry)_
*   to be _value(entry)_.

*   The SPITBOL datatype TABLE provides the machinery to implement maps.
*   SPITBOL provides no way to determine the number of entries in a table
*   other than converting the map to an array. This is the only way in
*   SPITBOL to iterate over a SPITBOL table.

*   For this reason, maps are implemented using two tables: _index_ and _key_.
*   Each new entry added to a map is given an integer id, starting with one.
*   The field _index_ maps the id's to the associated pairs.
*   The entries in _index_ allow efficient iteration over the
*
*   The table _key_ maps keys in the map to the corresponding entry in the map.
*   The entries in _key_ permit efficient retrieval of the map's value for a given key.

*   SETL4 supports stacks by implementing them as a sequence. The fuction
*   _push()_ pushes a value on to the stack; the function _pop_ removes the
*   top value.


*## Loops, Iterators

*   Loops in SPITBOL have the form of a test followed by the loop body,
*   with the body ending with a branch back to the test.

*  For example, here is a loop that prints the first one hundred integers:

*```
*test
*       i = i + 1
*       le(i,100)                       :f(done)
*       output = i                      :(test)
*done
*```

*   This can also be written as:

*```
*test
*       output = le(i = i + 1,100) i    :s(test)
*```

*   Loops in SETL4 are constructed using the _loop_ and _next_ statements.

*   A loop has the form:

*```
*       loop(set,thisname)
*
*   set.next
*       var = next(set)     :f(set.done)
*       out(this)           :(set.next)
*   set.done
*```

*   The first operand specifies of _loop_ gives the set or range of values
*   of the iteration.  The optional second argument names a variable that is
*   updated as part of successful call to _next_.  The name _this_ is used
*   if the second argument is not given. The _loop_ statement above can be
*   written as _loop(set)_ or also _loop(set,.this)_ or _loop(set,'this').
*
*   Loops can have a specific variable associated with a loop.

*```
*       loop(set,.this.s)
*       ...
*   set.next
*       next(set)           :f(set.done)
*       out(this.s)         :(set.next)
*   set.done
*```

*   The _loop_ statement creates an instance of _iterator_ to control the
*   iteration. The _next_ statement advances the iteration by producing the
*   next element or failing if no more elements remain.

*   See the functions _prime_ and _primes_ defined below to see _loop_
*   and _next_ in action. See also the code for _exists_ and _forall_.

*   SETL4 provides the datatype _iterator_ to control iteration over a
*   range of integers, over a set, or over a map.

    data('iterator(iter.next,iter.start,iter.finis,iter.step,iter.thisname,'
.                 'iter.block,iter.blocks,iter.offset,iter.str)')

*   where

*-  _iter.next      last value returned by the iterator.

*-  The following fields are used to iterate over a range:

*-  _iter.start_    starting value for iteration

*-  _iter.finis_    finishing value for iteration

*-  _iter.step_     difference between values of an iteration

*-  _iter.thisname_ name of iteration variable to be update to iteration value

*## Showing Values

*   Use the function _show()_ to display the value of a SETL4 or SPITBOL object

*   Sets are listed with the values enclosed in '{}'.
*   Sequences of ten or fewer elements are listed with the
*   values enclosed in '()'. Sequences of more than ten elements
*   are listed with the index and value enclosed in '[]').
*   Pairs and entries are listed with the component values enclosed in '()'.

*## Additional Operations Provided as an Artifact of the Implementation

*   The use of the tables _set.index_ and _set.key_ to implement a set makes it
*   possible to provide some operations not available in in standard set theory.
*   For example, it is possible to retrieve elements using the function _get_.
*   _Get(s,i)_ retrieves the i-th element in the set.

*   The function _sorter_ can be used to determine the order in which the elements
*   of a set are accessed during an iteration, or to 'sort' the tables implementing
*   the set. For example, _sorter(s,'+v')_ sorts a map in increasing order of the
*   values of the map. _sorter(s,'-v')_ sorts the values in descendng order, and
*   so forth. For example, here is the code to find the ten members with
*   the largest values in a map:

*```
*       sorter(map,'-v')
*       largest = new('set')
*       iter = new('iter 1 10')
*       loop(set)
*
*   largest.add
*
*       add(largest,next(set))               :s(largest.add)
*```

*   _Sorter_ is used by the _show_ function to display the values of a set or
*   map in a standard order. For example, if _s_ is a set with the elements
*   'a', 'b' and 'c', then _show(s)_ yields `set 'a' 'b' 'c' }`, not
*   `set 'b' 'c' 'a' }`.

*## SETL4 Configuration Options

*   _setl4.config.channel.1_ is channel number for temporary files, that is,
*   files created on entry to a procedure and closed before returning from
*   the procedure.

    setl4.config.channel.1 = 3

*   Define initial sizes of tables when creating a set.

*   _setl4.config.set.table.size_ is default size for the _index_ and _key_ tables of a set.

    setl4.config.set.table.size = 1024
    setl4.config.set.table.size = 32000

*   _setl4.config.int.table.size_ is size of index and key tables in set of kind 'int.'

    setl4.config.int.table.size = 1000

*   _setl4.config.int_ is number of characters in the block for an integer set.
*   _setl4.config.int.init_ is string of spaces of size _setl4.config.int_.

    setl4.config.int = 1000
    setl4.config.int = 20
    setl4.config.int.init = dupl('-',setl4.config.int)

*## Additonal SETL4 data types

*   SETL4 provides the following data type in addtion to _set_:

*       _token_

*   where

*       token(lineno,ndx,type,text) is a lexeme, or lexical token.

*## SETL4  Operator Symbols

*   SETL4 provides the following operator symbols:
*
*   _#s_        returns the size of a string or set _s_
*   _x ~ s_     tests if _x_ is member of set _s_
*   _s @ e_     is equivalent to _filter(s,e)
*   _=s_        returns the value of the iteration variable (usually 'this') of a loop.

*   For example, _member(x,s)_ can be written _x ~ s_, _set.size(x)_ can be written
*   _#s_, and _filter(s,e)_ can be written _s @ e_.

*   Need to define _setl4.size_ before use of opsyn to allow use of '#'
*   as unary operator to return size of set or string.

    define('setl4.size(set)')                           :(setl4.size.end)

*   Setl4.set.size_ returns the  size of operand.

setl4.size

    setl4.size = ident(datatype(set),'string') size(set):s(return)
*   setl4.size = differ(iter.step(set)) (iter.finis(set) - iter.start(set) / iter.step(set)) + 1:s(return)
    setl4.size = set.size(set)                          :(return)

setl4.size.end

    opsyn('#','setl4.size', 1)

*## Sample data

*   Programs need data. Since SPITBOL is designed to analyze and manipulate text, SETL4 provides
*   a library consisting of several works chosen from the world's greatest literature, including
*   the works of William Shakespeare, a dictionary, and the text of the King James version
*   of the Bible. Except for the dictionary, all texts were obtained using Project Gutenberg.

*   As an extension of SPITBOL, SETL4 brings the raw power and speed of SPITBOL to the task
*   of working with text. Additional functions are provided, including a lexical scanner, or
*   tokenizer, to assist in performing deep, detailed analysis of textual structure.

*   Several of these functions have as their purpose the translation of text into sets, maps,
*   and sequences. For example, the tokenizer returns a sequence consisting of the tokens
*   in a line of text.

*   In order to be able to use the program ./examples/align.stl to align the
*   goto fields in the source, use the variable _char(58)_ where
*   the colon character enclosed in quotes would normally be used.

*## SETL4 Functions

*   SETL4 provides the following functions:
*
*-  add(set,elem)               Adds element to set.
*-  and(a,b)                    Tests if both operands are true.
*-  append(str,w,ch)            Appends _ch_ (or space if _ch_ is null) to _str_, then _w_
*-  arbitrary(n)                Returns arbitary (randomly chosen) integer in 1 .. _n_.
*-  arbitrary(set)              Returns arbitary (randomly chosen) element of _set_.
*-  ascii(line)                 Returns the text of line with every ascii character identified
*-  assert(expr)                Tests that _expr_ is true, ends execution otherwise.
*-  assert.type(obj,type)       Tests that _obj_ has SPITBOL datatype _type_, ends execution otherwise.
*-  begins(str,sub)             Tests if string _str_ begins with string _sub_.
*-  binary(n)                   Returns string with value of _n_ in binary number.
*-  checkout(filename)          Returns ('checks out') set or map defined by a text file from the libary
*-  compare(a,b)                Compares two integers or strings, returning -1 (less), 0 (equal), or +1 (greater).
*-  compose(a,b)                Returns composition of two maps or tables.
*-  datename(date)              Returns string based on current time suitable for use as filename.
*-  defined(map,key)            Tests if a map is defined for a specified key.
*-  difference(a,b)             Returns set of members of set _a_ not in the set _b_.
*-  domain(map)                 Returns set of elements in the domain of a map.
*-  equal(a,b)                  Tests if two SETL4 objects are equal.
*-  even(n)                     Tests if _n_ is even.
*-  exists(set,expr)            Tests if an expression is true for at least one element in a set.
*-  factorial(n)                Returns n!  = n * (n -1) * ... * 1.
*-  frequency(s)                Returns frequency of values in sequence, map or string _s_.
*-  from(set,elem)              Returns set consisting of the members of a set except a specified member.
*-  get(map,key)                Gets the value of map _map_ for _key_ for a map.
*-  get(set,i)                  Gets the i-th element in a set, or fails if no such element.
*-  false(e)                    Tests if argument is false.
*-  filter(set,expr,n)          Returns set of elements in _set_ for which _expr_ is true.
*-  forall(set,expr)            Tests if an expression is true for every element of a set.
*-  integers(n)                 Returns set of integers 1 ... n.
*-  intersection(a,b)           Returns set of elements common to two sets.
*-  is.plain(s)                 Tests if _s_ is plain type: integer, name, real, or string.
*-  join(a,b)                   Joins two strings into a single string by concatenating them.
*-  less(str,sub)               Removes the first instance of each character in _sub_ from _str_,
*-  longest(set)                Returns the longest string in a set.
*-  loop(set,this)              Set up iteration over _set_ using _next_. _this_ names variable updated during iteration.
*-  tolower(s)                  Returns _s_ with upper case letters replaced by lower case equivalent.
*-  minimum(set)                Returns the shortest string in a set.
*-  multiple(n,m)               Tests if _n_ is a multiple of _m_.
*-  odd(n)                      Tests if _n_ is odd.
*-  out(text1,text2,text3)      Outputs _text1_, then _text2_ enclosed in '[]' if _text2_ not null.
*-  pack(seq)                   Packs sequence of strings into single string.
*-  plain(v)                    Returns string representing a plain type, per is.plain().
*-  powerset(set)               Return the powerset of _set_, the set of all the subsets of _set_.
*-  prefix(str,pre)             Takes a list of space-separated words in _str_, prefixes each with _pre_.
*-  product(seq)                Returns (Cartesian) product of a sequence of sets.
*-  member(set,elem)            Tests if _elem_ is a member of _set_.
*-  new(str)                    Returns a new set specified by _str_.
*-  next(set)                   Returns next element in iteration defined by prevous _loop_, fails if no more elements.
*-  not(expr)                   Tests if operand is false.
*-  number(s)                   Returns integer defined by _s_.
*-  or(a,b)                     Tests if either operand is true.
*-  push(stack,value)           Push value onto a stack.
*-  pop(stack)                  Pop the top of a stack and return its value.
*-  prime(n)                    Tests if _n_ is prime.
*-  primes(n)                   Returns set of primes less than _n_.
*-  put(map,key,val)            Defines the value of a map key.
*-  quicksort(seq)              Use Hoare's quicksort algorithm to sort a sequence.
*-  random(n)                   Returns random integer if _n_ is integer, elsel random element of set or map.
*-  random.seed()               Sets random number seed to initialize _random_.
*-  range(map)                  Returns set of elements in the range of a map.
*-  reader(filename,expr)       Returns sequence of lines in file _filename_, using _expr_ (if given).
*-  reader(str,delim)           Like _reader(filename..)_ but reads lines from a string with lines.
*-  remove(set,elem)            Removes arbitary element from set, or most recent entry from map.
*-  #set               Returns number of elements in set _set_.
*-  show(v)                     Shows value of _v_.
*-  show.plain(v)               Same as _show()_, but strings are not enclosd in quotes.
*-  show.b(e)                   Shows value of _b_ as boolean.
*-  show.lines(lines,number)    Shows a sequence of lines, with id if _number_ not null.
*-  slice(str,first,last)       Like SPITBOL substr to work for sequences and tuples.
*-  sorter(set,type)            Sorts a set, map or string according to _type_.
*-  split.line(line)            Splits line of blank-separated words into sequence.
*-  split.string(str)           Splits string into sequence of characters.
*-  square.root(n)              Returns integer square root on _n_
*-  subset(a,b)                 Tests if the set _b_  is a subset of set _a_
*-  this(set)                   Returns current iteration value for _set_.
*-  thousands(s)                Returns _s_ with a comma every three spaces from the right.
*-  top(s)                      Returns top element of sequence viewed as stack.
*-  traceon()                   Turns on tracing.
*-  traceoff()                  Turns off tracing
*-  tokens(line)                Returns sequence of the tokens in _line_.
*-  true(e)                     Tests if operand is true.
*-  union(a,b)                  Returns set consisting of all the members in two sets.
*-  unpack(str)                 Unpacks string into sequence of its characters.
*-  toupper(s)                  Returns _s_ with upper case letters replaced by lower case equivalent.
*-  visit(set,expr)             Visits each element of set _set_ and evaluates _expr_ for that element.
*-  words(line,w)               Returns sequence of words (defined by _w_) in _line_.
*-  writer(lines)               Writes sequence _lines_ to standard output.

*   SETL4 Function Definitions

    define('add(set,elem)ara,i,n,str')                  :(add.end)

*   _Add_ adds an element to a set if it not already a member.
*   If the set has kind _map_ and _elem_ has the data type _entry_
*   the map is updated using the key and value of the entry.

add

*   Test if adding blank and if so, do not convert to integer.
*   Otherwise convert string with integer value to integer.

    elem = integer(elem) +elem

    differ(datatype(set),'set') error('attempt to add to non-set ' datatype(set))

    ident(set.kind(set),'map')                          :s(add.map)
    ident(set.kind(set),'seq')                          :s(add.seq)f(add.set)

add.map

    differ(datatype(elem),'entry') error("can only add 'entry' elements to a map.")
    put(set,key(elem),value(elem))                      :(return)

add.set

    member(elem,set)                                    :s(return)

add.seq

    set.size(set) = #set + 1
    set.index(set)[#set] = elem
    set.key(set)[elem] = elem
                                                        :(return)

add.end

    define('and(a,b)')                                  :(and.end)

*   _And_ tests if both operand are true (not null), only
*   evaluating the second argument when necessary.

and

*   See if both operands are integers.

    and = integer(a) eq(a)                              :s(freturn)
    and = integer(b) eq(b)                              :s(freturn)
    and = integer(a) integer(b) ne(a * b)               :s(return)f(freturn)

*   Here where at least one operand for 'and' is not integer, so
*   use ident/differ to evaluate.

    and = differ(a) differ(b)                           :s(return)f(freturn)

and.end

    define('append(str,w,ch)')                          :(append.end)

*   _Appends appends _ch_, or ' ' if _ch_ is null, to _str_ and then appends _w_.

append

    append = str (ident(str) w, (ident(ch) ' ' , ch) w) :(return)

append.end

    define('arbitrary(set)iter,r')                      :(arbitrary.end)

*   _Arbtrary_ returns an arbitrary (randomly selected) element of a set, or
*   if the argument is an integer, then _arbitrary_ returns a random
*   integer in the range 1 .. _set_.

arbitrary

    arbitrary = integer(set) random(+set)               :s(return)
    r = random(#set)
    ident(set.kind(set),'iter')                         :s(arbitrary.iter)
    arbitrary = set.key(set)[set.index(set)[r]]
                                                        :(return)

arbitrary.iter

    iter = set.iter(set)
    arbitrary = iter.starbitraryitrary(iter) + (r - 1) * iter.step(iter):(return)

arbitrary.end

    define('ascii(line)c,n,name,nul,num,pos')           :(ascii.end)

*   _Ascii_ returns the text of its argument string with every ascii character identified.

ascii

    differ(setl4.ascii.initialized)                     :s(ascii.initialized)

*   Here to initialize the needed maps.

    ascii.init()
    setl4.ascii.initialized = 1

ascii.initialized

    nul = substr(&alphabet,1,1)

ascii.next

*   Add space after previous character if result not null.

    ascii = differ(ascii) ascii ' '
    c = substr(line,1,1)                                :f(ascii.done)
    ident(c,nul)                                        :s(ascii.null)
    line any('0123456789')                              :s(ascii.integer)
    line any(&lcase &ucase)                             :s(ascii.letter)
    line ' '                                            :s(ascii.space)

*   Check for control character (code <=26)

    &alphabet break(c) . pos                            :f(ascii.other)
    pos = size(pos)
    gt(pos,26)                                          :s(ascii.other)
    ascii = ascii setl4.ascii.name[c] '(^'
               substr('ABCDEFGHIJKLMNOPQRSTUVWXYZ',pos,1) ')'
    line len(1) =                                       :(ascii.next)

ascii.integer

    line span('0123456789') . text =
    ascii = ascii  text                                 :(ascii.next)

ascii.letter

    line span(&lcase &ucase) . text =
    ascii = ascii  text                                 :(ascii.next)

ascii.null

    ascii = ascii 'NUL'                                 :(ascii.next)

ascii.other

*   Here if none of the other cases apply, so just list the ascii name.

    ascii = ascii setl4.ascii.name[c]
    line = substr(line,2)                               :(ascii.next)

ascii.space

    line span(' ') . text =

    ascii =  ascii 'SPC'
    ascii = gt(size(text),1) ascii 'SPC*' size(text)
    ascii = ascii
                                                        :(ascii.next)
ascii.done

    ascii = trim(ascii)                                 :(return)

ascii.end

    define('ascii.init(init)entry,name,value')          :(ascii.init.end)

*   _Ascii.init_ Initialize maps for use by _ascii_.
*   Since space (ascii 32) prints as space, use the name SPC for 32.

ascii.init


    ascii.init = new('map '
.      '0:NUL 16:DLE 32:SPC 48:0 64:@ 80:P  96:` 112    :p '
.      '1:SOH 17:DC1 33:!   49:1 65:A 81:Q  97:a 113    :q '
.      '2:STX 18:DC2 34:"   50:2 66:B 82:R  98:b 114    :r '
.      '3:ETX 19:DC3 35:#   51:3 67:C 83:S  99:c 115    :s '
.      '4:EOT 20 DC4 36:$   52:4 68:D 84:T 100:d 116    :t '
.      '5:ENQ 21:NAK 37:%   53:5 69:E 85:U 101:e 117    :u '
.      '6:ACK 22:SYN 38:&   54:6 70:F 86:V 102:f 118    :v '
.      "7:BEL 23:ETB 39:'   55:7 71:G 87:W 103:g 119    :w "
.      '8:BS  24:CAN 40:(   56:8 72:H 88:X 104:h 120    :x '
.      '9:HT  25:EM  41:)   57:9 73:I 89:Y 105:i 121    :y '
.      '10:LF 26:SUB 42:*   58:  74:J 90:Z 106:j 122    :z '
.      '11:VT 27:ESC 43:+   59:; 75:K 91:[ 107:k 123    :{ '
.      '12:FF 28:FS  44:,   60:< 76:L 92:\ 108:l 124    :| '
.      '13:CR 29:GS  45:-   61:= 77:M 93:] 109:m 125    :} '
.      '14:SO 30:RS  46:.   62:> 78:N 94:^ 110:n 126    :~ '
.      '15:SI 31:US  47:/   63:? 79:O 95:_ 111:o 127    :DEL ')

    setl4.ascii.name = new('map #128')
    setl4.ascii.value = new('map #128')
    loop(ascii.init)

ascii.init.next

    entry = setl4.l.next(ascii.init)                    :(ascii.init.finis)
*   Correct entry for 0 to be NUL, the NUL character
    setl4.ascii.name[substr(&alphabet,+v + 1,1)] = name
    setl4.ascii.value[name] = +value                          :(ascii.init.next)
    setl4.ascii.name[] = 'NUL'
    setl4.ascii.value['NUL'] = 0
    setl4.ascii.name[' '] = 'SPC'
    setl4.ascii.value['SPC'] = 32
    setl4.ascii.value['SPC'] = 32
    setl4.ascii.name[char(58)] = char(58)
    setl4.ascii.value[char(58)] = 58

ascii.init.end

    define('assert(expr)')                              :(assert.end)

*   _Assert_ tests that its argument expression is non null, ending execution otherwise.

assert

    true(expr)                                          :s(return)
    error('assertion failed, quitting')

assert.end

    define('assert.type(obj,typ)')                      :(assert.type.end)

*   _Assert.type_ tests that _obj_ has datatype _typ_, and ends execution if not.

assert.type

    assert(ident(datatype(obj),typ))                    :s(return)
    error('assertion on datatype failed ' typ )


assert.type.end

    define('begins(str,init)')                          :(begins.end)

*   _Begin_ tests if string _str_ begins with string _init_.
*   It returns _str_ on success, fails otherwise.

begins

    ident(str)                                          :s(freturn)
    ident(init)                                         :s(freturn)
    begins = str
    ident(str,init)                                     :s(return)
    gt(size(init),size(str))                            :s(freturn)
    ident(substr(str,1,size(init)),init)                :s(return)f(freturn)

begins.end

    define('binary(n)')                                 :(binary.end)

*   _Binary_returns a string with the value of _n_ as a binary number.

binary

    n = n * 2

binary.next

    n = n / 2

    binary = eq(n)   '0'                                :s(return)
    binary = eq(n,1) '1'                                :s(return)
    binary = even(n) binary(n / 2) '0'
    binary = odd(n)  binary(n / 2) '1'
                                                        :(return)

                                                        :(binary.next)

binary.done

*   binary = ident(binary) '0'                          :s(return)
*   binary = gt(size(binary),1) substr(binary,2)
                                                        :(return)

binary.end

	define('checkout(filename)file,fullname,line,word')    :(checkout.end)

*	_Checkout_ checks out (retrieves) a file from the library as a sequence of lines
*   or a set of words. _Checkout_ lists the available files if _filename_ is null.

*   Dictionary has one word per line, with toupper 'S' at end denoting
*   that both singular and plural form are words in the dictionary.

*   When checking out text files, skip blank lines and lines that start with '*'.

checkout

    differ(filename)                                    :s(checkout.check)

checkout.list

    out('available texts in the checkout                :')
	out('dictionary')
	out('genesis')
	out('hamlet')
	out('new-testament')
	out('old-testament')
	out('romeo-and-juliet')
	out('shakespeare')
	out('sonnets')
                                                        :(return)

checkout.check

*   See if _filename_ matches one of the available texts.


	filename = begins('dictionary',filename)               :s(checkout.open)
	filename = begins('enable1',filename)                  :s(checkout.open)
	filename = begins('genesis',filename)                  :s(checkout.open)
	filename = begins('hamlet',filename)                   :s(checkout.open)
	filename = begins('new-testament',filename)            :s(checkout.open)
	filename = begins('old-testament',filename)            :s(checkout.open)
	filename = begins('romeo-and-juliet',filename)         :s(checkout.open)
	filename = begins('shakespeare',filename)              :s(checkout.open)
	filename = begins('sonnets',filename)                  :s(checkout.open)

    out('Sorry, that text is not available.')
    out('Here is a list of the available texts:')        :(checkout.list)

checkout.open

	fullname = '../library/' filename '.txt'
	input(.file,3,fullname)                                :s(checkout.opened)
	error('unable to open file ',filename)                 :(freturn)

checkout.opened

*   Dictionary requires special handling.

    ident(filename,'dictionary')                        :s(checkout.dictionary)
    checkout = set('seq',iterator(),table(2000),table(2000))

checkout.next

	line = file                                            :f(checkout.finis)
    lines = lines + 1
    ident(line)                                         :s(checkout.next)
    line '*'                                            :s(checkout.next)
    push(checkout,line)                                 :(checkout.next)

checkout.dictionary

    checkout = set('set',iterator(),table(40000),table(40000))

checkout.dictionary.add

    add(checkout,word)

checkout.dictionary.next

    word = file                                         :f(checkout.finis)
    ident(substr(word,size(word),1),'S')                :f(checkout.dictionary.add)

*   Here if plural. Add plural form and them merge to add singular form.

    word = substr(word,1, size(word) - 1)
    add(checkout, word 's')                             :(checkout.dictionary.add)

checkout.finis

	endfile(3)                                             :(return)

checkout.end

    define('compare(a,b)')                              :(compare.end)

*   _Compare_ compares two integers or strings, returning -1 if the _a_ is
*   less than _b_ , 0 if both have the seq.eq value, and +1 if the _a_ is greater than _b_.

compare

    a = integer(a) +a
    b = integer(b) +b
    differ(datatype(a),datatype(b)) error("compare argument types differ " datatype(a) " " datatype(b))
    ident(datatype(a),'string')                         :s(compare.strings)

*   Here to numerically compare integers.

    compare = lt(a,b) -1                                :s(return)
    compare = eq(a,b) 0                                 :s(return)
    compare = 1                                         :(return)

compare.strings

*   Here to lexically compare strings.
    compare = llt(a,b) -1
    compare = leq(a,b) 0
    compare = lgt(a,b) 1
*   out('compare ' show(a) ' ' show(b) ' ' compare)
                                                        :(return)

compare.end

    define('compose(a,b)ara,entry,i')                   :(compose.end)

*   _Compose_ returns the composition of two maps or tables.
*   Given maps _a_ and _b_ such that _range(a)_ is a subset of _domain(b)_,
*   then the composition _c_ of _a_ and _b_ is defined as follows:
*   Let A be a member of the domain of _a_. Let B be the value of _a[A]_.
*   Then _c[A]_ is defined as _b[B]_.

compose

    ident(datatype(a),'table')                          :s(compose.table)

*   Here to compose two maps.

    n = #a
    compose = eq(n) new('map')                          :s(return)
    compose = new('map #' n)
    set.size(compose) = n
    loop(a)

compose.map.next

    entry  = next(a)                                    :f(return)
    put(compose,key,get(b,value(entry)))                :(compose.map.next)

compose.table

    ara = convert(a,'array')                            :f(show.table.error)
    prototype(ara) break(',') . n
    compose = table(n)
    i = 0

compose.table.next

    le(i = i + 1,n)                                     :f(return)
    compose[i] = b[a[i]]                                :(compose.table.next)

compose.end

    define('datename()s')                               :(datename.end)

*   _Datename_ converts the current date in a form with no spaces,
*   just dashes, that is suitable for use as part of a file name.

datename

    datename = replace(date(),'                         :/','---')
    datename = substr(datename,12,8) '-' substr(datename,1,10)
                                                        :(return)
datename.end

    define('defined(map,key)entry')                     :(defined.end)

*   _Defined_ tests if the map _map_ has an entry for _key_.

defined
    key = integer(key) +key
    defined = set.key(map)[key]
    differ(defined)                                     :s(return)f(freturn)

defined.end

    define('difference(a,b)this')                       :(difference.end)

*   _Difference_ returns the set difference of two sets, which is
*   defined as the set of elements of the first set that are not
*   also elements of the second set.

difference

    difference = new('set')
    loop(a)

diference.next

    this = next(a)                                      :f(return)
    member(this,b)                                      :s(difference.next)
    add(difference,this)                                :(difference.next)

difference.end

    define('domain(map)elem)')                          :(domain.end)

*   _Domain_ returns the domain of map, which is the set of the keys in _map_.

domain

    domain = new('set')
    loop(map)

domain.next

    entry = next(map)                                   :f(return)
    differ(entry) add(domain,key(entry))                :(domain.next)

domain.end

    define('equal(a,b)entry,i,key,value')               :(equal.end)

*   _Equals_ tests if two objects are equal. Use DIFFER unless both are sets, in
*   which case use equality tests specified below.

equal

    ident(datatype(a),datatype(b))                      :f(freturn)
    ident(datatype(a),'entry')                          :s(equal.entry)
    ident(datatype(a),'pair')                           :s(equal.pair)
    ident(datatype(a),'set')                            :s(equal.sets)
    ident(a,b)                                          :s(return)f(freturn)

equal.entry

    equal(key(a),key(b))                                :f(freturn)
    equal(value(a),value(b))                            :f(freturn)s(return)

equal.int

    eq(iter.start(a),iter.start(b))                     :f(freturn)
    eq(iter.finis(a),iter.finis(b))                     :f(freturn)
    eq(iter.step(a),iter.step(b))                       :f(freturn)s(return)

equal.map

*   Two maps are equal if they have the same vaue at every element in the domain.

    eq(#a,#b)                                           :f(freturn)
    gt(i = i + 1, #a)                                   :s(equal.true)
    entry = set.index(a)[i]
    ident(value(entry),get(b,key(entry)))               :f(freturn)s(equal.map)

equal.pair

    equal(first(a),first(b))                            :f(freturn)
    equal(second(a),second(b))                          :f(freturn)s(return)

equal.seq

*   Two sequences are equal if they have the same vaue at every element in the domain.
    
    eq(#a,#b)                                           :f(freturn)
    gt(i = i + 1, #a)                                   :s(equal.true)
    ident(set.seq(a)[i], set.seq(b)[i])                 :s(equal.seq)f(freturn)

equal.sets


    eq(#a,#b)                                           :f(freturn)
    ident(set.kind(a),set.kind(b))                      :f(freturn)
    ident(set.kind(set),'int')                          :s(equal.int)
    ident(set.kind(set),'iter')                         :s(equal.iter)
    ident(set.kind(set),'map')                          :s(equal.map)
    ident(set.kind(set),'seq')                          :s(equal.seq)
    ident(set.kind(set),'set')                          :s(equal.set)
    error('equal mismatched kinds')


equal.set

*   Two sets are equal if and only if each is a subset of the other.

    eq(#a,#b)                                           :f(freturn)
    subset(a,b)                                         :f(freturn)
    subset(b,a)                                         :f(freturn)
                                                        :(return)
    equal = and(subset(a,b),subset(b,a))                :f(freturn)s(return)

equal.end

    define('even(n)')                                   :(even.end)

*   _Even_ tests if its argument is even.

even

*HERE*
    
    integer(n)                                          :f(freturn)
    eq(remdr(n,2))                                      :s(return)f(freturn)

even.end

    define('error(str)')                                :(error.end)

*   _Error_ writes out its argument string and ends execution.

error

*   &dump = 2
*   &dump = 3
    out('&dump',&dump)

*   Clear variables that need not appear in &dump output

    setl4.clear()
    out('Fatal error: ' str)                            :(end)

error.end

    define('exists(set,expr)this,e')                    :(exists.end)

*   _Exists_ tests if there is an element in _set such that _expr_ is true.

exists

    loop(set)

exists.loop

    this = next(set)                                    :f(freturn)
    exists = eval(expr)                                 :f(exists.loop)s(return)

exists.done

    output = 'exists loop ended, failing'               :(freturn)

exists.end

    define('factorial(n)')                              :(factorial.end)

*   _Factorial_ computes the value of the factorial function of its argument.

factorial

    integer(n)                                          :f(freturn)
    factorial = (eq(n,1) 1, n * factorial(n -1))        :(return)

factorial.end

    define('false(e)')                                  :(false.end)

*   _False_ tests if its argument is false (null).

false

    e = integer(e) +e
    false = integer(e)  eq(e)                           :s(freturn)
    false = ident(e)                                    :s(return)f(freturn)

false.end

    define('filter(set,expr,n)e,this')                    :(filter.end)

*   According to Paul Halmos, in his book "Naive Set Theory,"
*   a major principle of set theory, often referred to by its
*   German name _Aussonderungsaxiom_, is the Axiom of Specification:

*   To every set _A_ and every condition _S(x)_ there corresponds
*   a set _B_ whose elements are exactly those elements _x_ of _A_
*   for which _S(x)_ holds.

*   In SETL4 we say that the expression '_A_ @ _S_' "filters"
*   _A_ by _S_. This can also be read as
*           "the subset of _A_ such that _S_ is true"

*   _Filter_ returns the subset of a set, map or sequence _set_
*    for which the given expresion is true.

*   _filter(s,e)_ can also be written using the operator symbol '@':
```
        s @ e
```
*   that is, "the elements in _s_ at which _e_ is true.

*   If _n_ is not null, it gives an estimate of the size of the result.

filter

    ident(set.kind(set),'map')                          :s(filter.map)
    ident(set.kind(set),'seq')                          :s(filter.seq)
    filter = new('set' (eq(n) '', ' #' n))
    loop(set)

filter.set.next

    this = next(set)                                    :f(return)
    eval(expr) add(filter,this)                         :(filter.set.next)

filter.map

    filter = new('map')
    loop(set)

filter.map.loop

    this = next(set)                                    :f(return)
    eval(expr) push(filter,value(this))                 :(filter.map.loop)

filter.seq

    filter = new('seq')
    loop(set)

filter.seq.loop

    this = next(set)                                    :f(return)
    eval(expr) push(filter,this)                        :(filter.seq.loop)

filter.end

    define('forall(set,expr)e')                         :(forall.end)

*   _Forall_ tests if _expr_ is true for all elements of _set_.

forall

    loop(set)

forall.loop

    next(set)                                           :f(return)
    e = eval(expr)                                      :f(freturn)s(forall.loop)

forall.end


    define('frequency(map)this')                        :(frequency.end)

*   _Frequency_ returns a frequency distribution for a map,
*   sequence  or string. The frequency distribution of a string
*   gives the number of times each character in the string occurs
*   in the string. The distribution of a map or sequence gives,
*   for each element in the range of the map the number of keys
*   having that value.


frequency

    frequency = new('map')
    ident(datatype(map),'set')                          :s(frequency.map)

*   Compute distribution for string by converting string to sequence
*   and merging with code to find distribution for a map.

    map = split.string(map)

frequency.map

*   Here to compute frequency distribution of a map.

    loop(map)

frequency.next

    this = value(next(map))                             :f(return)
    this = integer(this) +this
    put(frequency,this,get(frequency,this) + 1)         :(frequency.next)

frequency.end

    define('from(set,elem)this')                        :(from.end)

*   _From_ removes an element from a set, or returns a copy
*   of the set if the given element is not a member of the set.

from

    from = new('set')
    loop(set)

from.next

    this = next(set)                                    :f(return)
    differ(this,elem) add(from,this)                    :(from.next)

from.end

    define('get(map,key)val,entry')                     :(get.end)

*   _Get_ gets the value of the key _key_ in the map _map_, or gets
*   element _key_ in a set, failing if no such element.

get

    key = integer(key) +key
    ident(set.kind(map),'int')                          :s(get.int)
    ident(set.kind(map),'map')                          :s(get.map)
    ident(set.kind(map),'seq')                          :s(get.map)
    ident(set.kind(map),'set')                          :s(get.set)
    error('get on unsupported kind of set               : ' set.kind(map))

get.int

    error("get on set of kind 'int' not yet supported.")

get.map

    get = set.key(map)[key]                             :(return)

get.set

    ident(set.kind(map),'iter')                         :s(get.int)
    get = set.index(map)[key]
    ident(get)                                          :s(freturn)f(freturn)
    get = set.key(map)[entry]                           :(return)

get.end

    define('int(n)')                                    :(int.end)

*   _Int_ Returns _n_ if _n_ is an integer, or returns _n_ converted to an
*   integer if _n_ is real, or returns the value of a string written in exponential
*   (scientific) notation converted to its integer value.

int

    int = integer(n) n                                  :s(return)
    int = ident(datatype(n),'real') convert(n,'integer'):s(return)
    int = n
    n break('e')                                        :f(return)
    n break('e') . int 'e' =
    int = int * +('1' dupl('0',n))
    int = +int
                                                        :(return)

int.end

    define('integers(n)')                               :(integers.end)

*   _Integers_ returns the set containing the integers 1 .. _n_

integers

    integers = set('set',iterator(),table(n),table(n))

integers.next

    le(i = i + 1,n) add(integers,i)                     :s(integers.next)f(return)

integers.end

    define('intersection(a,b)this')                     :(intersection.end)

*   _Intersection_ returns the intersection of its argument sets.

intersection

*   Make _a_ the smaller

    le(#a,#b)                                           :s(intersection.next)
    a = b
    b = intersection
    intersection = new('set')
    loop(a)

intersection.next

    this = next(a)                                      :f(return)
    member(this,b) add(intersection,this)               :(intersection.next)

intersection.end

    define('is.plain(v)')                               :(is.plain.end)

*   Tests if _v_  has a plain type.
*   The plain types are 'integer', 'name', 'real', and 'string'.

is.plain

    ident(v)                                            :s(return)
    ident(datatype(v),'integer')                        :s(return)
    ident(datatype(v),'name')                           :s(return)
    ident(datatype(v),'real')                           :s(return)
    ident(datatype(v),'string')                         :s(return)
                                                        :(freturn)

is.plain.end

    define('join(s1,s2,s3)i,this')                      :(join.end)

*   _Join_ combines one of more sequences (strings) into a single sequence
*   (string) by joining all their elements together.

join

    s1 = differ(s1) ident(datatype(s1),'integer') convert(s1,'string')
    s2 = differ(s2) ident(datatype(s2),'integer') convert(s2,'string')
    s3 = differ(s3) ident(datatype(s3),'integer') convert(s3,'string')

    join = differ(s1) differ(s2) differ(s3) join(join(s1,s2),s3):s(return)
    ident(datatype(s1),'string')                        :s(join.string)
    join = new('seq')
    loop(s1)

join.s1

    push(join,value(next(s1)))                          :s(join.s1)

    ident(s2)                                           :s(return)

*   Test if second argument is sequence.

    ident(datatype(s2),'set') ident(set.kind(s2),'seq') :s(join.s2)

*   Here if not sequence, so just add it to result and return.

    push(join,s2)                                       :(return)

join.s2

*   Here to join elements in the second argument to the result.

    loop(s2)

join.s2.next

    push(join,value(next(s2)))                          :s(join.s2.next)f(return)

join.string

*   Here to join strings.

    join = s1 (differ(s2) s2, '') (differ(s3) s3,'')    :(return)

join.end

    define('less(str,sub)before,after')                 :(less.end)

*   _Less_ removes the first instance of each character in _sub_ from _str_,
*   where _sub_ is a substr of _str_.

less

    ident(str)                                          :s(return)
    less = str

less.ch
    sub len(1) . ch =                                   :f(return)
    less break(ch) . before  ch rem . after
    less = before after                                 :(less.ch)

less.end

    define('longest(set)this')                          :(longest.end)

*   Return longest string in set.

longest

    loop(set)

longest.next

    next(set)                                           :f(return)
    le(size(this),size(longest))                        :s(longest.next)
    longest = this
                                                        :(longest.next)

longest.end

    define('loop(set,thisname)iter')                    :(loop.end)

*   _Loop_ creates or updates the iterator of _set_ so that,
*   on the call to _next()_,  _iter.next_  will be
*   advanced to select the first element in the iteration.

*   If _thisname_ is not null, then _thisname_ is set to 'this'.
*   On each call to _next()_ during the iteration established
*   by _loop_, the value of the iterate will be assigned to _thisname_.

loop

    differ(datatype(set),'set') out('loop() unsupported argument type.')
    differ(datatype(set),'set') show(set)
    differ(datatype(set),'set')
.       error('loop() expects argument to be set, but given ' datatype(set))

    iter = iterator()

	ident(set.kind(set),'iter')                         :s(loop.iter)
    ident(set.kind(set),'int')                          :s(loop.int)
    ident(set.kind(set),'map')                          :s(loop.map)
    ident(set.kind(set),'seq')                          :s(loop.map)
    ident(set.kind(set),'set')                          :s(loop.set)
    error('unknown kind of iterator, ' set.kind(set))

loop.int

    iter.next(set) = set.block(iter) = set.offset(iter) = 0:(loop.finis)

loop.iter

*   When iterating over a set of kind 'iter', use the iterator
*   created when the set was created.

    iter = set.iter(set)                                :(loop.finis)
    iter.next(iter) = gt(iter.step(iter)) iter.start(iter) - iter.step(iter)
    iter.next(iter) = lt(iter.step(iter)) iter.start(iter) + iter.step(iter)
                                                        :(loop.finis)


loop.map
loop.seq
loop.set

loop.finis

    thisname = ident(thisname) .this
    thisname = ident(datatype(thisname),'string') .thisname
    iter.thisname(iter) = thisname
    set.iter(set) = iter                                :(return)

loop.end

    define('member(elem,set)kind,entry,i,iter,key,this,value,block)'):(member.end)

*   _Member_ tests if _elem_ is member of _set_.

member

*   Branch according to whether _set_ is set, map, or sequence.

    eq(#set)                                   :s(freturn)

*   Do not convert single space to integer.

    elem = differ(elem,' ') integer(elem) +elem
    ident(datatype(elem),'entry')                       :s(member.map)
    ident(set.kind(set),'int')                          :s(member.int)
    ident(set.kind(set),'iter')                         :s(member.iter)
    ident(set.kind(set),'set')                          :s(member.set)
    error('requesting member for unsupported set kind, ' kind )

member.int

*   To test for membership in set of kind _int_ get the block
*   for the element. If it is null then fail since element not
*   in the set. Otherwise see if character corresponding to the
*   value of _elem_ is '+'.

    block = elem / setl4.config.int
    this = +(remdr(elem,setl4.config.int) + 1)
    value = set.key(set)[block]
    ident(value)                                        :s(freturn)
    ident(substr(value,this,1),'+')                     :s(return)f(freturn)

member.iter

    integer(elem)                                       :f(freturn)
    iter = set.iter(set)
    lt(iter.step(iter)) lt(elem,iter.finis(iter))       :s(freturn)
    gt(iter.step(iter)) eq(remdr(elem - iter.start(iter),iter.step(iter))):s(return)
    lt(iter.step(iter)) eq(remdr(iter.start(iter) - elem,iter.step(iter))):s(return)
                                                        :(freturn)

member.map

    differ(set.key(set)[key(elem)])                     :s(return)f(freturn)

member.set

    differ(set.key(set)[elem])                          :s(return)f(freturn)

member.end

    define('multiple(n,m)')                             :(multiple.end)

*   _Multiple_ Tests if _n_ is a multiple of _m_.

multiple

    multiple = eq(remdr(n,m))                           :s(return)f(freturn)

multiple.end

    define('new(init,elem1,elem2)kind,i,index,iter,len,n,key,seq,val,values,words)'):(new.end)

*   _New_ constructs a new set with initial values determined by string _init_.

*   The first three characters in _init_ give the kind of the set:
*
*       'iter'          iterator, followed by iterator specification
*       'map'           map, followed by list of key/value pairs separated by colon
*       'set'           set, followed by list of initial members
*       'seq'           sequence, followed by list of initial values.

*   The set kind may optionally be followed by a number sign (#) followed by an integer, to
*   indicate an estimate of the number of elements in a set or map. The number need not be
*   accurate. Values that are too high will cause the program to expend space to save some time;
*   numbers that are too low will expend some time to save space.

*   _New_ returns the new object.

new

*   Assume kind is 'set' unless explicitly specified.

    kind = 'set'

    init span(' ') =
    ident(init)                                         :s(new.set)
    init = init ' '
    init break(' ') . kind span(' ') =
    kind = (gt,size(kind),3) substr(kind,1,3)
    begins('integers',kind)                             :s(new.kind)
    begins('iterator',kind)                             :s(new.kind)
    begins('map',kind)                                  :s(new.kind)
    begins('seq',kind)                                  :s(new.kind)
    begins('set',kind)                                  :s(new.kind)
    begins('string',kind)                               :s(new.kind)

*   If the kind is not given, then the kind is 'set' and _init_
*   is not null, it gives the initial element(s) to add to the set.

    kind = 'set'

new.kind

    kind = gt(size(kind),3) substr(kind,1,3)
    n = 0
    init span(' ') =
    n = setl4.config.table.int.table.size
    init '# ' span('0123456789') . n =                  :s(new.sized)
    init '#' span('0123456789') . n =

new.sized

*   Branch on kind to finish initialization of new set.

                                                        :($('new.' kind))
new.int

    new = set('set',iterator(),table(n),table(n))
    set.kind(new) = 'int'
    set.index(new) = table(1000)
    set.key(new) = table(1000)

new.int.next

    init break(' ') . key span(' ') =                   :f(new.init.elem)
    add(new,int(key))                                   :(new.int.next)

net.int.elem

    differ(elem1) add(new,elem1)
    differ(elem2) add(new,elem2)                        :(return)

new.ite
new.iter

    new = set('iter')
    iter = iterator()
    iter.thisname = .this
    set.iter(new) = iter
    iter.step(iter) = 1
    seq = new('seq ' init)

*   Ignore extra arguments to iterator constructor.

    set.size(seq) = gt(#seq,3)
    eq(#seq,1)                                 :s(new.iter.1)
    eq(#seq,2)                                 :s(new.iter.2)
    eq(#seq,3)                                 :s(new.iter.3)

new.iter.1

    iter.start(iter) = 1
    iter.finis(iter) = get(seq,1)
    iter.step(iter) =  1                                 :(new.iter.step)

new.iter.2

    iter.start(iter) = get(seq,1)
    iter.finis(iter) = get(seq,2)
    iter.step(iter) =  1                                 :(new.iter.step)

new.iter.3

    iter.start(iter) = get(seq,1)
    iter.finis(iter) = get(seq,2)
    iter.step(iter)  = get(seq,3)

new.iter.step

*   Make sure step negative if first argument to iter is greater than the second.

    lt(iter.step(iter)) out('new -step',iter.step(iter))
    iter.step(iter) = gt(iter.start(iter),iter.finis(iter))  gt(iter.step(iter)) - iter.step(iter)
    set.size(new) = ((iter.finis(iter) - iter.start(iter)) / iter.step(iter)) + 1
                                                        :(return)

new.map

    new = set('map',iterator(),table(n),table(n))
    set.encloser(new) = '{}'

*   If present, _init_ is a list consisting of a list of key/value pairs,
*   with a colon (:) separating the key and value.

    init = init ' '
    init span(' ') =
    ident(init)                                         :s(return)

new.map.next

    init break(char(58)) . key char(58) break(' ') . val span(' ') =:f(return)
    put(new,key,val)
                                                        :(new.map.next)

new.seq

    new = set(kind,iterator(),table(n),table(n))
    set.encloser(new) = '()'
    init span(' ') =
    ident(init)                                         :s(return)
    init = init ' '

new.seq.next

    init span(' ') =
    init break(' ') . val ' ' =                         :f(return)
    push(new,val)                                       :(new.seq.next)

new.set

    new = set('set',iterator(),table(n),table(n))
    set.kind(new) = 'set'
    set.encloser(new) = '{}'
    ident(init)                                         :s(return)

new.set.iter.next

    init break(' ') . key span(' ') =                   :f(new.set.elem)
    add(new,key)                                        :(new.set.iter.next)

new.set.elem

    differ(elem1) add(new,elem1)
    differ(elem2) add(new,elem2)

new.set.done

                                                        :(return)

new.end

    define('new.stack()')                               :(new.stack.end)

*   _New.stack_ returns a new stack.

new.stack

*   Don't allocate stack table when creating stack. Do that
*   when first add value to stack.

    new.stack = stack(,0)                               :(return)

new.stack.end

    define('next(set)iter,key,next,str,thisname,value') :(next.end)

*   _Next_ advances an iteration or fails if no more elements remain.

next

*   Branch on kind to find next iteration value.

    iter = set.iter(set)                                :($('next.' set.kind(set)))

next.int

*   Iteration over a set    of kind 'int' makes use of the following fields:
*
*       set.block      is current block for iteration
*       set.offset     is zero if this block not search, or else index of an
                       element of the set in this block
*       set.str        is set to the string of a block when advance to it.

*   Branch to get first block if _set.str_ is null.

    ident(set.str(set))                                 :s(next.int.block)

next.int.test

*   See if any members remain in this block, branching to _next.int.block_ if none.

next.int.block

*   Here to advance to next block, ending iteration if no more remain.

    set.block(set) = set.block(set) + 1
    gt(set.block(set),set.blocks(set))                  :s(freturn)
    set.str(set) = set.key(set)[set.index(set)[set.block(set)]]
    str = set.str(set)
    str break('+') . key                                :f(next.int.block)

*   Here when member found. Clear the membership character and return.

    set.str(set) = set.key(set)[block]
    set.str(set) = ne(set.offset(set))
.           substr(set.str(set),1,set.offset(set) - 1,'-','+')
.          '+'
.          substr(str,set.offset(set) + 1)
    set.str(set) = str
    next = (set.block(set) * setl4.config.int) + size(key):(next.finis)

next.iter

*   Here to find next element in iterator.

    eq(iter.step(iter)) error('iterator with step zero')
    next = iter.next(iter) = iter.next(iter) + iter.step(iter)
    gt(iter.step(iter)) gt(next,iter.finis(iter))       :s(freturn)
    lt(iter.step(iter)) lt(next,iter.finis(iter))       :s(freturn)
                                                        :(next.finis)

next.map
next.seq
next.tup

    next = iter.next(iter) = iter.next(iter) + 1
    le(next,#set)                              :f(freturn)
    key = set.index(set)[next]
    next = entry(key,set.key(set)[key])                 :(next.finis)

*next.seq
*
*    next = iter.next(iter) = iter.next(iter) + 1
*    le(next,#set)                             :f(freturn)
*    key = set.index(set)[next]
*    next = set.key(set)[next]                          :(next.finis)
*
next.set

    next = iter.next(iter) = +iter.next(iter) + 1
    le(next,#set)                              :f(freturn)
    next = set.index(set)[next]                         :(next.finis)

next.finis

*   Here to update _thisname_  to the next iteration value.

    thisname = iter.thisname(iter)
    thisname = ident(datatype(thisname),'string') .this
    $(thisname) = next                                  :(return)

next.end

    define('not(expr)')                                 :(not.end)

*   _Not_ returns the negation of a boolean expression.

not

    not = integer(expr) (eq(expr) 1, '')                :s(return)f(freturn)
    not = ident(expr) 1                                 :s(return)f(freturn)

not.end

    define('number(n)')                                 :(number.end)

*   Test if _n_ is a string with integer value or integer, returning its
*   value if so, or failing otherwise.

number

    number = integer(n) +n                              :s(return)f(freturn)

number.end

    define('odd(n)')                                    :(odd.end)

*   _Odd_ tests if its argument is odd.

odd

    integer(n)                                          :f(freturn)
    odd = ne(remdr(n,2))                                :s(return)f(freturn)

odd.end

    define('or(a,b)')                                   :(or.end)

*   _Or_ tests if either operand is true, fails otherwise, only evaluating
*   its second argument if necessary

or
    or = integer(a) ne(a)                               :s(return)
    or = integer(b) ne(b)                               :s(return)

*   Here if operands not both integers, so use ident/differ.

    or = differ(a)                                      :s(return)
    or = differ(b)                                      :s(return)f(freturn)

or.end

    define('out(text1,text2,text3)type1,type2')         :(out.end)

*   _Out_ writes a line to standard output  conisting of _text1_,
*   then _text2_ enclosed in brackets if _text2_ is not null, followed
*   by _text3_ if _text3_ is not null.

out

    text2 = is.plain(text2) plain(text2)
    output  = text1 (differ(text2) '[' text2 ']', '') (differ(text3) text3,''):(return)

out.end

    define('out.dt(v)')                                 :(out.dt.end)

*   Show datatype of _v_

out.dt

    out('Datatype ' v,eval('datatype(' v ')'))          :(return)

out.dt.end

    define('pack(seq)i')                                :(pack.end)

*   _Pack_ packs a sequence of strings into a single string.

pack

    loop(seq)

pack.next

    pack = pack value(next(seq))                        :s(pack.next)f(return)

pack.end

    define('plain(v,q)')                                :(plain.end)

*   Tests if _v_ is a plain type, where the plain types are _entry_, _integer_,
*   _pair_, _real_, and _string_. If _v_ is plain, then _plain_ returns its
*   value as a string. Otherwise, _v_ is returned as the value.

*   The value of a string is enclosed in quotes unless _q_ is not null.

plain

    ident(v)                                            :s(return)
    plain = v
    is.plain(v)                                         :f(return)
    plain = integer(v) +v                               :s(return)

*   Nothing to be done if argument is not string.

    ident(datatype(v),'string')                         :s(plain.string)
    error('unexpected input type to plain, ' datatype(v))

plain.string

*   Return string with no enclosing quotes if _q_ is not null.

    ident(q)                                            :s(plain.quote)
    plain = v                                           :(return)

plain.quote

*   Here to enclose string in quote characters.

    plain '"'                                           :s(return)
    plain "'"                                           :s(return)
    v break("'")                                        :s(plain.double)

*   Here if arguent does not contain a single quote, so use single quotes around it.

    plain = "'" v "'"                                   :(return)

plain.double

*   Here if arguent contains single quote, so use double quotes around it.

    plain = '"' v '"'                                   :(return)

plain.end

    define('pop(stack)')                                :(pop.end)

*   _Pop_ removes (pops) the top item from stack, or fails if the stack is empty.

pop

    pop = stack
    eq(#stack)                                          :s(freturn)
    pop = set.key(stack)[set.index(stack)[#stack]]
    set.size(stack) = #stack - 1                        :(return)

pop.end

    define('powerset(set)b,i,j,n,N,s,this')             :(powerset.end)

*   Return the powerset of _set_, defined as the set of all subsets of a set.

powerset

    powerset = new('set')

*   Let _n_ be the size of _set_.
*   The powerset of the empty set is the empty set.

    n = #set
    eq(n)                                               :s(return)

*   Compute _N_ = 2 to the powerset _n_.

    N = 1
    i = 0

powerset.N

    le(i = i + 1,n)                                     :f(powerset.N.done)
    N = N * 2                                           :(powerset.N)

powerset.N.done

*   Compute the powerset as follows:

*   Loop for i = 0 ... N - 1:
*       Let _b_ be the string containing the binary value of _i_, padded to length _n_.
*       Set _this_ to the empty set.
*       Loop for _j_ = _size(b)_ ... _1_
*           If the _j_-th character of _b_ is '1' then add
*           the _j_-th element of _set_ to _this_.
*       Add _this_ to _powerset_.

    i = -1

powerset.next.i

    lt(i = i + 1,N)                                     :f(return)
    b = binary(i,n)
    this = new('set')
    j = size(b) + 1

powerset.next.j

    gt(j = j - 1)                                       :f(powerset.j.done)
    s = substr(b,j,1)
    ident(s,'1') add(this,set.index(set)[j])
                                                        :(powerset.next.j)

powerset.j.done

    add(powerset,this)                                  :(powerset.next.i)

powerset.end
    define('prefix(str,pre)word')                       :(prefix.end)

*   _Prefix_ takes a list of the words in _str_, separated by spaces,
*   and prefixes each with the str _pre_.

prefix

    str = str ' ';* so each word followed by space

prefix.1

    str break(' ') . word span(' ')  =                  :f(return)
    add1(.prefixcount)
    prefix = append(prefix, pre word,'A')               :(prefix.1)

prefix.end

    define('prime(n)')                                  :(prime.end)

*   _Prime_ tests if _n_ is a prime integer.

prime

    n = integer(n) +n
    eq(n,2)                                             :s(return)
    even(n)                                             :s(freturn)
    exists(new('iter 3 ' square.root(n) ' 2'), 'multiple(n,this)'):s(freturn)f(return)

prime.end

    define('primes(n)this')                             :(primes.end)

*   _Primes_ returns the set of primes less than _n_.

primes

    primes = new('seq')
    primes = integer(n)                                 :f(return)
    primes = lt(n,3) new('set 2')                      :s(return)
    primes = filter(new('iter 2 ' (n - 1)),'prime(this)'):(return)
    primes = new('seq 2')
    iter = new('iter 2 ' (n - 1))
    loop(set)

primes.loop

    this = next(set)                                    :f(return)
    prime(this) push(primes,this)                       :(primes.loop)

primes.end

    define('product(seq,strings)partial,t1,slice1,set1,set2,this1,this2,tup,tmp,p1,p2'):(product.end)

*   _Product_ returns the Cartesian product.set of a sequence of strings or sets.

*   The product of an empty set is the empty set; the product
*   of a single set is itself; the product of more than two sets
*   is defined recursively; and the product of two sets is computed
*   element by element.

*   If argument _strings_ is not null then _sets_ is a sequence of strings.

product

    product = new('set')
    product = eq(#seq)                         :s(return)
    product = eq(#seq,1) copy(seq)             :s(return)

    set1 = get(seq,1)
    set2 = get(seq,2)
    eq(#seq,2)                                 :s(product.two)

*   Here to compute the product of three or more sets. First,
*   compute the partial product of all the sets except the last one,
*   and then compute the product of that partial product and the last set.

    set1 = product(slice(seq,1,#seq - 1),strings)
    set2 = top(seq)

product.two

*   Here to compute the product of two sets.

*   Loop over the first set. If an element is a tuple, then we are extending a
*   partial product. Otherwise we are interating over the first set in a product
*   and need to create a tuple from the element.

*   Then loop over the second set. For each element in the second set, add a new
*   element to the output that extends the tuples of the current element in the
*   first set.

    product = new('set')
    loop(set1,.this1)

product.set.next1

    next(set1)                                          :f(return)
    this1 = ident(strings) differ(datatype(this1),'set')  push(new('seq'),this1)

    loop(set2,.this2)

product.set.next2

    next(set2)                                          :f(product.set.next1)
    add(product,join(this1,this2))                      :s(product.set.next2)

product.end
    define('push(seq,val1,val2,val3,val4,val5)')        :(push.end)

*   _Push_ adds new value(s) to a seq or tuple, returning the updated
*   seq or tuple as its value.

push
    seq = ident(seq) new('seq')
    push = seq
    ident(val1)                                         :s(return)
    push.value(seq,val1)
    ident(val2)                                         :s(return)
    push.value(seq,val2)
    ident(val3)                                         :s(return)
    push.value(seq,val3)
    ident(val4)                                         :s(return)
    push.value(seq,val4)
    ident(val5)                                         :s(return)
    push.value(seq,val5)                                :(return)

push.end

    define('push.value(seq,value)n')                    :(push.value.end)

*   _Push.value_ adds _value_ to a seq or tuple, returning
*   the updated seq or tuple as its value.

push.value

    ident(seq) error('push() first argument is null.')
    differ(datatype(seq),'set')
.       error('push() first argument is not a set, but instance of ' datatype(seq))
    ident(set.kind(seq),'map')                          :s(push.value.add)
    ident(set.kind(seq),'seq')                          :s(push.value.add)
    error('first argument to push.value must be set or map, is ' datatype(seq))

push.value.add

    set.size(seq) = #seq + 1
    n = #seq
    set.index(seq)[n] = n
    value = differ(value,' ') integer(value) +value
    set.key(seq)[n] = value                             :(return)

push.value.end

    define('put(map,key,value)v')                       :(put.end)

*   _Put_ sets the value of the entry for key _key_ in map _map_ to be _val_,

put

    key = integer(key) +key
    value = integer(value) +value
    differ(set.key(map)[key])                           :s(put.value)

*   Here to create new entry in map, and then merge to set new value.

    set.size(map) = #map + 1
    set.index(map)[#map] = key

put.value

    set.key(map)[key] = value                           :(return)

put.end

    define('quicksort(seq)c,seq.eq,set.gt,seq.lt,pivot,this'):(quicksort.end)

*   _Quicksort_ sorts the sequence _seq_ using Hoare's quicksort algorithm.
*   _Seq_ must be sequence of integers or sequence of strings.

*   This program is for demonstrating SETL4.
*   Use the much more efficient _sorter_ for production use.

quicksort

    quicksort = le(#seq,1) seq                 :s(return)
    pivot = arbitrary(seq)
    number(pivot)                                       :f(quicksort.strings)

*   Here to sort sequence of integers.

    quicksort = join( quicksort(filter(seq,  'lt(value(this),pivot)')),
.                               filter(seq,  'eq(value(this),pivot)'),
.                     quicksort(filter(seq,  'gt(value(this),pivot)'))):(return)


*   Here to sort sequence of strings.

    quicksort = join( quicksort(filter(seq,  'llt(value(this),pivot)')),
.                               filter(seq,  'leq(value(this),pivot)'),
.                     quicksort(filter(seq,  'lgt(value(this),pivot)'))):(return)

quicksort.end

	define('random(n)')                                    :(random.end)

*	Return integer uniformly distributed in 1,2,...,n.
*	If n=0 returns real uniformly distributed in the interval [0,1].
*	The Algorithm is based on that in section 16.1 of "Algorithms in SNOBOL4,"
*	James F. Gimpel, John Wiley and Sons, 1976.

random

    ident(setl4.random.initialized) random.seed()
	setl4.random.value = remdr(setl4.random.value * 4676, 414971)
	random  = setl4.random.value / 414971.0
	random = ne(n) convert(random * n,'integer') + 1

*   Make sure random of integer never returns zero.

    random = integer(random) eq(random) 1
                                                        :(return)
random.end

	define('random.seed()s,c')                             :(random.seed.end)

*	Compute seed for random number generator from date and time.

random.seed
    differ(setl4.random.initialized)                    :s(return)
    setl4.random.initialized = 'TRUE'
	setl4.random.value =
	s = date()
	s = replace(s,'/                                       :-','123')

*	Get all the digits in s.

random.seed.loop

	s len(1) . c =                                         :f(random.seed.done)
	ident(c,' ')                                           :s(random.seed.loop)
	setl4.random.value = setl4.random.value c              :(random.seed.loop)

random.seed.done

*	Reverse the seed so digits depending on time come first.

	setl4.random.value = +reverse(setl4.random.value)
                                                        :(return)
random.seed.end

    define('range(map)elem,entry)')                     :(range.end)

*   _Range_ returns the range of map, which is the set of the values in _map_.

range

    range = new('set')
    loop(map)

range.next

    entry = next(map)                                   :f(return)
    add(range,value(key(entry)))                        :(range.next)

range.end

    define('reader(filename,undent)line')               :(reader.end)

*   _Reader_ returns a sequence of the lines in the file specified by _filename_.
*   Lines are read from standard input if _filename_ is null.
*   If _undent_ is not null, leading spaces in lines are eliminated.
*   _Reader_ ignores (skips over) lines that start with '*'.

reader

    line  = input
    out('first',line)
    ident(filename)                                     :s(reader.read)
    input(.file,setl4.config.channel.1,filename)        :s(reader.opened)
    out('unable to open reader file ' filename '.')     :(freturn)

reader.read

    reader = new('seq')

reader.next

    line = (ident(filename) input, file)                :f(reader.eof)
    out(line)
    ident(line)                                         :s(reader.next)
    line '*'                                            :s(reader.next)
    ident(undent)                                       :s(reader.add)
    line span(' ') =

reader.add

    push(reader,line)                                   :(reader.next)

reader.eof

*   Here at end of file; close temporary file if one was needed.

    differ(filename) endfile(setl4.config.channel.1)    :(return)

reader.end

    define('reader.str(str,delim)line')                 :(reader.str.end)

*   _Reader.str_ returns a sequence of the lines in _str_, where
*   the character _delim_ is used to indicate end of line.
*   If _delim_ is  not given, then '/' is understood.

reader.str

    delim = ident(delim) '/'
    reader.str = new('seq')

reader.str.next

    str break(delim) . line delim =                     :f(return)
    push(reader.str,line)                               :(reader.str.next)

reader.str.end

    define('remove(set,elem)i,iter,this')               :(remove.end)

*   _Remove_ removes the element _elem_  from the set _set_, or
*   does nothing if _elem_ is not a member of the set.
*   Note that _remove_ differs from _from_ in that modifies the set
*   in place, while _from_ returns a new set with an element removed.

*   If _elem_ is new, remove the most recently added element of a set or map.
*   If _set_ is a set, then remove _elem_ from _set_ if it is a member.
*   If _set_ is a map, remove the entry with key _value_.
*   _Remove_ returns the element removed.

remove

    eq(#set)                                   :s(freturn)
    ident(elem)                                         :s(remove.last)
    remove = elem
    ident(set.kind(set),'int')                          :s(remove.int)
    ident(set.kind(set),'map')                          :s(remove.map)
    ident(set.kind(set),'set')                          :s(remove.set)
    error('remove not defined for set of kind ' set.kind(set))

remove.int

    error("remove from set of kind 'int' not yet implemented.")

remove.last

    remove = set.index(set)[#set]
    #set = #set - 1                   :(return)

remove.map
remove.set

    ident(set.key(set)[elem])                           :s(return)

*   Find the entry with key _elem_, assuming it's more likely
*   to be a newer addition than one of the older elements.

    iter = new('iter ' #set ' 1')
    i = #set + 1

remove.find

    gt(i = i - 1)                                       :f(remove.error)
    ident(set.index(set)[i],elem)                       :f(remove.find)

*   Delete _elem_ from the key table, then move the entries
*   in the index table following this one down one position.
*   Nothing remains to be done if the set had only one element, or
*   if the element was the last in the index table.

    set.key(set)[elem] =
    #set = #set - 1
    eq(#set)                                   :s(return)

remove.next

    eq(i,#set)                                 :s(return)
    set.index(set)[i] = set.index(set)[i + 1]
    i = i + 1                                           :(remove.next)

remove.error

    error('remove.set unable to locate member')

remove.end

    define('shortest(set)this')                         :(shortest.end)

*   Return shortest string in set.

shortest

    loop(set)

shortest.next

    next(set)                                           :f(return)
    shortest = ident(shortest) this
    ge(size(this),size(shortest))                       :s(shortest.next)
    shortest = this
                                                        :(shortest.next)

shortest.end

    define('show(v,type,q)ara,i,kind,elem,entry,key,line,hdr,n,this,str,value'):(show.end)

*   _Show_ displays the value of its first argument in a form that is hopefully both
*   readable and pleasing to the eye.

*   If _type_ is not null, sets and maps are ranked in order given by _type_.
*   Otherwise sets and maps are increased in ascending value of members (set)
*   or keys (map).

*   If _q_ is not null, strings are not shown with enclosing quotes;
*   by default they are shown with enclosing quotes.

show

*   Show nothing by writing out nothing.

    ident(v)                                            :s(return)

    is.plain(v)  show.out(plain(v,q))                   :s(show.finis)

    ident(datatype(v),'array')                          :s(show.array)
    ident(datatype(v),'entry')                          :s(show.entry)
    ident(datatype(v),'table')                          :s(show.table)
    ident(datatype(v),'iterator')                       :s(show.iterator)
    differ(datatype(v),'set') error('unexpected datatype to show, ' datatype(v))

    type = ident(type) '+k'
    kind = set.kind(v)
    ident(kind,'int')                                   :s(show.int)
    ident(kind,'iter')                                  :s(show.iter)
    ident(kind,'map')                                   :s(show.map)
    ident(kind,'seq')                                   :s(show.seq)
    ident(kind,'set')                                   :s(show.set)
    error('show unknown set kind',kind,' quitting.')

show.array

    proto = prototype(ara)
    proto break(',')                                    :s(show.array.2)

*   Here for one dimensional array.

show.array.1
    first = ara[add1(.i)]                               :f(show.array.done)
    show.out(lpad(i,3) tab first)                       :(show.array.1)

show.array.2
    first = ara[add1(.i),1]                             :f(show.array.done)
    show.out(lpad(i,3) tab show(first,type) tab show(ara[i,2],type)):(show.array.2)

show.array.done

                                                        :(show.finis)

show.entry

    is.plain(key(v)) is.plain(value(v))                 :f(show.entry.notplain)
    show.out(plain(key(v),q) char(58) plain(value(v),q)):s(show.finis)

show.entry.notplain

    show(key(v))
    show.char(char(58))
    show(value(v))
                                                        :(show.finis)
show.iter

*   The iterator is the only meaningful part of a set of type iter
*   so reset _v_ to the iterator and show that.

    v = set.iter(v)
    show.out('{ iter')
    ne(+iter.start(v))  show.out(' start='  iter.start(v))
    ne(+iter.finis(v))  show.out(' finis='  iter.finis(v))
    ne(+iter.step(v))   show.out(' step='   iter.step(v))
    ne(+iter.next(v))   show.out(' next='   iter.next(v))
    show.out('} ')                                      :(show.finis)

show.iterator

    show.out('( iterator')
    ne(+iter.start(v))  show.out(' start='  iter.start(v))
    ne(+iter.finis(v))  show.out(' finis='  iter.finis(v))
    ne(+iter.step(v))   show.out(' step='   iter.step(v))
    ne(+iter.next(v))   show.out(' next='   iter.next(v))
    show.out(') ')                                      :(show.finis)

show.int
show.map
show.set
                                                        :(show.compound)

show.pair

    is.plain(first(v)) is.plain(second(v))              :f(show.pair.notplain)
    show.out('(' plain(first(v),q) ',' plain(second(v),q) ')'):(show.finis)

show.pair.notplain

    show.out(first(v))
    show.out(char(58))
    show(second(v))                                     :(show.finis)

show.seq


*   If the sequence has more than ten elements, change the encloser to '{}'

    set.encloser(v) = (le(#v,10) '()', '[]')
                                                        :(show.compound)

show.compound

    sorter(v,type)
    loop(v)
    show.out(substr(set.encloser(v),1,1))
    show.level = show.level + 1

show.compound.next

    elem = next(v)                                      :f(show.compound.done)
    is.plain(elem)     show(plain(elem,q),,q)           :s(show.compound.next)
    ident(kind,'int')  show(elem,,q)                    :s(show.compound.next)
    ident(kind,'iter') show(elem,,q)                    :s(show.compound.next)

*   show = ident(datatype(value(entry),'token'))
*               show  show.token(v,,'TRUE')             :s(show.map.check)

    ident(kind,'map')   show(elem,,q)                   :s(show.compound.next)

*   If showing a sequence, show only the value of element if less
*   than ten elements, otherwise show the element with the index.

    ident(kind,'seq') ident(set.encloser(v),'[]')   show(elem,,q):s(show.compound.next)
    ident(kind,'seq') ident(set.encloser(v),'()')   show(value(elem),,q):s(show.compound.next)

    ident(kind,'set')   show(elem,,q)                   :s(show.compound.next)

show.compound.done

    show.level = show.level - 1
    show.out(substr(set.encloser(v),2,1))
                                                        :(show.finis)

show.table

    show.out('[')
    ara = convert(v,'array')                            :f(show.table.error)
    i = 0
    prototype(ara) break(',') . n                       :(show.table.next)

show.table.error

    error('error converting table to array')

show.table.next

    le(i = i + 1,n)                                     :f(show.table.done)
    show(ara[i,1],,q)                                   :(show.table.next)

show.table.done

    show.out(']')                                       :(show.finis)

show.finis

    show.done()
                                                        :(return)

show.end

    define('show.char(ch)')                             :(show.char.end)

*   Show single character, not enclosed in blanks.

show.char

    show.line = show.line ch                            :(return)

show.char.end

    define('show.done()')                               :(show.done.end)

*   Write out _show.line_ unless in midst of showing compound object.

show.done

    le(size(show.line),72)                              :s(show.done.finis)

*   Here to write out long line.

    out(show.line)
    show.line =

show.done.finis

    gt(show.level)                                      :s(return)
    differ(show.line) out(show.line)
    show.line =                                         :(return)

show.done.end

    define('show.out(str)')                             :(show.out.end)

*   Append _str_ to _show.line_.

show.out

    str = differ(str,' ') integer(str) +str                             :s(show.out.show)
    differ(datatype(str),'string')
.       error('show.out expects argument to be string, but got ' datatype(str))

show.out.show

    show.line = show.line (differ(show.line) ' ', '') str
*   show.line = show.line  str
    le(size(show.line),72)                              :s(return)
    out(show.line)
    show.line =                                         :(return)

show.out.end

    define('show.b(e)')                                 :(show.b.end)

*   _Show.b_ shows the value if its argument as a boolean value: TRUE or FALSE

show.b

    integer(e) out((ne(e) 'TRUE', 'FALSE'))             :s(return)
    out((differ(e) 'TRUE', 'FALSE'))                    :(return)

show.b.end

    define('show.eval(expr)e')                          :(show.eval.end)

*   _Show.eval_ evaluates its argument and returns 'success' if
*   the evaluation succeeded, or 'failure' if not.

show.eval

    eval(expr)                                          :s(show.eval.success)
    show.eval = 'failure'                               :(show.eval.finis)

show.eval.success

    show.eval = 'success'

show.eval.finis

    out('eval ' expr ' ' show.eval)                     :(return)

show.eval.end

    define('show.lines(lines,number)i,line')            :(show.lines.end)

*   Show a sequence of lines, including the line number if _number_ not null.

show.lines

    loop(lines)

show.lines.next

    line = next(lines)                                  :f(return)
    i = i + 1
    gt(i,100) error('i too big')
    ident(number)    out(line)                          :s(show.lines.next)
    differ(number)   out(lpad(i,4) '  ' line)           :(show.lines.next)

show.lines.end

    define('show.plain(v)')                              :(show.plain.end)

*   _Show.plain_ yields same results as _show_ except that strings
*   are not enclosed in quotes.

show.plain

    show(v,,'NOQUOTE')                                  :(return)

show.plain.end

    define('slice(v,start,n)')                          :(slice.end)

*   _Slice_ returns a slice of a sequence, string or tuple.
*   For a string _slice_ is equivant to SPITBOL's _substr_.

slice

    slice = ident(datatype(v),'string') substr(v,start,n):s(return)

*   Here to compute slice of a string or tuple.

    slice = new(set.kind(v))
    n = ident(n) #v - start + 1
    lt(start,1)                                         :s(freturn)
    gt(start + n - 1,#v)                               :s(freturn)
    start = start - 1

slice.next

    push(slice,get(v,start = start + 1))
    gt(n = n - 1)                                       :s(slice.next)f(return)

slice.end


    define('sorter(set,type)ara,entry,i,key,index.table,map,n,seq,str,tbl,value.table,value'):(sorter.end)

*   _Sorter_ sorts the index table of _set_ according to _type_ to reflect
*   a desired sort of the elements of set, keys or maps, or values of map.
*   _Sorter_ doesn't create a new set, but just updates the index table so that,
*   going forward, entries will be visited in the order specified by _type_.

*   _Sorter_ can also be used to put a string in normal form by converting the string
*   into a sequence of the characters in the string and then sorting the range
*   of the sequence.

*   The argument _type_ specifies the ordering to be used:

*       '+index'    increasing order of when entry created (oldest first)

*       '-index'    decreasing order of when entry created (most recent first)

*       '+key'      increasing order of the values in the domain

*       '-key'      decreasing order of the values in the domain

*       '+value'    increasing order of the values in the range

*       '-value'    decreasing order of the values in the range

*   Types for keys and values may be abbreviated: "+key" may be written
*   as "+k" or "+ke", "+value" as "+v" or +"val", and so forth.

sorter

*   Here to detect cases for which sort has no meaning, in which case
*   return immediately. This includes the case 'int' which, though possible
*   to sort as desired, requires a complicated algorithm that has yet to be
*   thought through.

    ident(datatype(set),'set') ident(set.kind(set),'int'):s(return)
    ident(datatype(set),'set') ident(set.kind(set),'iter'):s(return)

*   Use _sorter.string_ if input is a string.

    sorter = ident(datatype(set),'string') sorter.string(set):s(return)

    ident(type) error('sorter null type.')
    ident(type,'no')                                    :s(return)
    n = #set
    index.table = set.index(set)

    type = get(sorter.types,type)

*   Nothing to do if set is empty or only has one element.

    le(n,1)                                             :s(return)
    differ(datatype(set),'set') error('sorter bad datatype ' datatype(set))
    ident(type) error('sorter null type')

    ident(type,'+v')                                    :s(sorter.value)
    ident(type,'-v')                                    :s(sorter.value)

    tbl = sorter.set(set,type)
    differ(datatype(tbl),'table') error('sorter result not table')
                                                        :(sorter.finis)
    i = 0

sorter.index.next

    error('why did we reach here')
    le(i = i + 1,n)                                     :f(sorter.finis)
    tbl[i] = set.index(set)[ara[i,1]]                   :(sorter.index.next)

sorter.value

*   Here to  sort by value: build table mapping index numbers into
*   the values associated with their keys, and sort that.

    tbl = compose(set.index(set),set.key(set))
    type = ident(type,'+v') '+k'
    type = ident(type,'-v') '-k'
    value.table = sorter.table(set,type,tbl)
    i = 0

*   The table is in proper order, so replace values with the keys
*   associated with that value.

sorter.value.next

    le(i = i + 1,n)                                     :f(sorter.finis)
    tbl[i] = value.table[i]                             :(sorter.value.next)

sorter.finis

    set.index(set) = tbl                                :(return)

sorter.end

    define('sorter.set(set,type)ara,i,index')           :(sorter.set.end)

*   _Setl4.table.sorter_ returns an index table derived from the
*   index table of _set_ that reflects the ordering given by _type_.

sorter.set

    le(#set,1)                                 :s(return)
    ara = ident(type,'+i')    sort( set.index(set), 1)  :s(sorter.set.1)
    ara = ident(type,'-i')    rsort(set.index(set), 1)  :s(sorter.set.1)
    ara = ident(type,'+k')    sort( set.index(set), 2)  :s(sorter.set.1)
    ara = ident(type,'-k')    rsort(set.index(set), 2)  :s(sorter.set.1)

    error('sorter.set unsupported key type              : ' type)

sorter.set.1

    differ(datatype(ara),'array')
.               error('sorter.set sort result not array :' datatype(ara))

    sorter.set = table(n)
    index = 0

sorter.set.set.next

    le(i = i + 1,n)                                     :f(return)
    index = ara[i,1]
    sorter.set[i] = set.index(set)[index]               :(sorter.set.set.next)

sorter.set.end

    define('sorter.string(str)ara,c,i,tbl')             :(sorter.string.end)

*   _Sorter_sorts a string into a string with all the characters
*   in lexical (alphabetic) order.

sorter.string

    tbl = table(size(str))

sorter.string.tbl

    c = substr(str,i = i + 1,1)                         :f(sorter.string.sort)
    tbl[i] = c                                          :(sorter.string.tbl)

sorter.string.sort

*   Sort the table and rebuild the string in sorter order.

    i = 0
    ara = sort(tbl,2)

sorter.string.next

    c = ara[i = i + 1,2]                                :f(return)
    sorter.string = sorter.string c                     :(sorter.string.next)

sorter.string.end

    define('sorter.table(set,type,tbl)ara,i,index')     :(sorter.table.end)

*   _Setl4.table.sorter_ returns an index table derived from the
*   index table of _set_ that reflects the ordering given by _type_.

sorter.table

    le(#set,1)                                 :s(return)

    ara = ident(type,'+i')    sort(tbl,1)               :s(sorter.table.1)
    ara = ident(type,'-i')    rsort(tbl,1)              :s(sorter.table.1)
    ara = ident(type,'+k')    sort(tbl,2)               :s(sorter.table.1)
    ara = ident(type,'-k')    rsort(tbl,2)              :s(sorter.table.1)
    error('sorter.table unexpected type                 :' type)

sorter.table.1

    sorter.table = table(n)
    index = 0

sorter.table.table.next

    le(i = i + 1,#set)                         :f(return)
    index = ara[i,1]                                    :f(sorter.table.error)
    sorter.table[i] = index.table[index]
                                                        :(sorter.table.table.next)
sorter.table.error

    error('sorter.table error, array out of bounds reference.')

sorter.table.end

    define('split.line(line)word')                      :(split.line.end)

*   _Split.lines_ splits a line into a sequence of words, where words are separated by one of more spaces.

split.line

    split.line = new('seq')
    line span(' ') =
    ident(line)                                         :s(return)
    line = line ' '

split.line.next

*   Here to split line into a sequence of its words.

    line break(' ') . word span(' ') =                  :f(return)
    push(split.line, word)                              :(split.line.next)

split.line.end

    define('split.string(str)c')                        :(split.string.end)

*   _Split.str_ returns a sequence of the characters in _str_.

split.string

    split.string = new('seq')
    str span(' ') =
    ident(str)                                          :s(return)

split.string.next

*   Here to split.stringing into a sequence of its characters.

    str len(1) . c =                                    :f(return)
    put(split.string,i = i + 1, c)                      :(split.string.next)

split.string.end

    define('square.root(n)')                            :(square.root.end)

*   _Square.root_ returns the square root of its argument, rounded up.

square.root

    square.root = int(sqrt(n)) + 1                      :(return)

square.root.end

    define('subset(a,b)elem')                           :(subset.end)

*   _Subset_ tests if its second argument is a subset of the first.

subset

    gt(#a,#b)                                           :s(freturn)
    loop(b)

subset.next

    elem = next(b)                                      :f(return)
    member(elem,a)                                      :s(subset.next)f(freturn)

subset.end

    define('this(set)')                                 :(this.end)

*   _This_ returns the value determined in the most recent call to next.

this

    this = iter.thisname(set)                           :(return)

this.end

    define('thousands(s)n')                             :(thousands.end)

*   _Thousands_ formats its argument by inserting comma's every three digits from right.

thousands

    n = size(s)
    thousands = le(n,3) s                               :s(return)
    thousands = thousands(substr(s,1,n - 3)) ',' substr(s, n - 2, 3):(return)

thousands.end

*#  Tokens: Lexical Scanning


*   A token is represented as an instance of the datatype _token_ as follows:

    data('token(lineno,col,type,text)')

*   where:
*           _lineno_        is the line number within the file;
*           _col_           is the index (column number) of the first character of the token in the line;
*           _type_          is the token's type, as described below; and
*           _text_          is the text of the token.

*   The type is represented by a single character, as follows:

*           'c'             comment, indicated by asterisk (*) in the first column.
*                           The text consists of the entire line.

*           'i'             integer, consisting of one or more digits ('0123456789')

*           'l'             left opener, one of '(<[{'

*           'p'             punctation, one of '.;,?!', or single quote (') or double quote ("),

*           'o'             other printable character, one of '~@#$%^&*_-+=`'.

*           'q'             quoted str, starting witn '"', and continuing to the next instance of the opening quote character.

*           'r'             right closer, one of ')>]}'

*           's'             space, consistine of one or more spaces (spaces)

*           't'             tab character

*           'u'             unprintable character, for example control-k

*           'w'             word, consisting of one of more letters in upper or lowercase, or "'" or "_".

*   The longest possible string meeting the rules is used when building a token.
*   For example, 'abc' is just the word 'abc', not 'a' followed by 'bc', and so forth.

*   It is recommended that the tab character NOT be used as an abbreviation for
*   one or more spaces in the input file. If tabs are used, then _col_ is ill-defined.
*   If tabs are not used, then _col_ indicates the true position in the line of
*   the first character of the token, and so error messages and references to the
*   token will be exact.  For example, _pos_ could be used to indicate where to give
*   emphasis to a token by underlining it, or enclosing it in '_' to generate
*   markdown format, and so forth.

    define('tokens(line)type,pos,text,lineno')          :(tokens.end)

*   _Tokens_ scans a line _line_ and returns a table of the tokens in the line.
*   The table has keys from 1..n, where _n_ is the number of tokens found.

*   This function is an instance of what is called a lexical scanner, or tokenizer.
*   This is the first stage in a programming language compiler, or for any program
*   that processes text files with a specified structure.

tokens

    tokens = new('seq')
    line '*'                                            :f(tokens.next)
    type = 'c'
    text = line
    line =                                              :(tokens.new)

tokens.next

    line ' '                                            :s(tokens.space)
    line any('0123456789')                              :s(tokens.integer)
    line any('(<[{')                                    :s(tokens.left)
    line any('.;,?!')                                   :s(tokens.punctuation)
    line '"'                                            :s(tokens.quote)
    line any('~@#$%^&*_-+=')                            :s(tokens.other)
    line any(')>]}')                                    :s(tokens.right)
    line char(9)                                        :s(tokens.tab)
    line any(&lcase &ucase)                             :s(tokens.word)

*   Here for unprintable
    error('unprintable?? fix in tokens')

tokens.integer

    type = 'i'
    line span('0123456789') . text =                    :(tokens.new)

tokens.punctuation

    type = 'p'                                          :(tokens.character)

tokens.other

    type = 'o'                                          :(tokens.character)

tokens.quote

    type = 'q'
    line '"' break('"') . text '"' =
    text = '"' text '"'                                 :(token.new)

tokens.right

    type = 'r'                                          :(tokens.character)

tokens.space

    type = 's'
    line span(' ')  . text =                            :(tokens.new)

tokens.tab

    type = 't'                                          :(tokens.character)

tokens.word

*TODO*
    type = 'w'
    line span(&ucase &lcase "_" "'") . text =           :(tokens.new)

tokens.character

*   Here if token is single character.

    line len(1) . text                                  :(tokens.new)

tokens.new

    setl4.add(tokens,token(lineno,pos,type,text))       :(tokens.next)

tokens.end

    define('tolower(s)')                                :(tolower.end)

*   _Lower.case_ converts argument to tolower.

tolower

    tolower = replace(s,&ucase,&lcase)                  :(return)

tolower.end

    define('top(seq)')                                  :(top.end)

*   _Top_ returns the last element of a sequence, or fails if the sequence is empty.

top

    differ(datatype(seq),'set')  error('argument to top is not a set')
    eq(#seq)                                   :s(freturn)
    ident(set.kind(seq),'seq')                          :s(top.get)
    error('argument to top() is not sequence or tuple.')

top.get

    top = get(seq,#seq)                        :(return)

top.end

    define('toupper(s)')                                :(toupper.end)

*   _Upper.case_ converts its argument to toupper.

toupper

    toupper = replace(s,&lcase,&ucase)                  :(return)

toupper.end

    define('traceoff()')                                :(traceoff.end)

*   _Traceoff_ ends tracing.

traceoff

    &ftrace = &trace =
    out('stop TRACING ')

traceoff.end

    define('traceon()')                                 :(traceon.end)

*   _Traceon_ begins tracing.

traceon

    out('start TRACING')
*   &ftrace = &trace = 1500000
    g.scoring = g.tracing = 1
                                                        :(return)
traceon.end

    define('true(e)')                                   :(true.end)

*   _True_ Tests if its operand is true (not null).

true

    e = integer(e) +e
    integer(e) ne(e)                                    :s(return)
    differ(e)                                           :s(return)f(freturn)

true.end

    define('union(a,b)elem')                            :(union.end)

*   _Union_ returns the union of sets _a_ and _b_.

union

*   Arrange so set _a_ is the larger

    ge(#a,#b)                                           :s(union.a)
    union = a
    a = b
    b = union

union.a

*   Make copy of _a_ to start things off.

    union = copy(a)
    loop(b)

union.b

    elem = next(b)                                      :f(return)
    add(union,elem)                                     :(union.b)

union.end

    define('unite(seq)this')                            :(unite.end)

*   Unites a sequence of characters into a single string.

unite

    loop(seq)

unite.next

    this = next(seq)                                    :f(return)
    unite = unite this                                  :(unite.next)

unite.end

    define('unpack(str)seq,ch')                         :(unpack.end)

*   Unpack string _str_ into sequence of its characters.

unpack

    unpack = new('seq')

unpack.next

    str len(1) . ch =                                   :f(return)
    push(unpack, ch)                                    :(unpack.next)

unpack.end

    define('visit(set,expr)this')                       :(visit.end)

*   _Visit_ loops over _set and calls _eval_ with argument
*   _expr_  for each of member of the set.

visit

    loop(set)

visit.next

    this = next(set)                                    :f(return)
    eval(expr)                                          :(visit.next)

visit.end

    define('words(line,w)pat,word')                     :(words.end)

*   _Words_ returns a sequence of the words in _line_, where _w_
*   is a string that defines the allowed characters in a word.
*   If _w_ is null, the a word consists of consecutive upper or
*   lower case letters.

words

    words = new('seq')
    w = ident(w) &ucase &lcase
    pat = span(w)

words.next

    line pat . word =                                   :s(words.add)

*   No word begins at this character, so move on to the next one.

    line len(1) =                                       :f(return)s(words.next)

words.add

    push(words, word)                                   :(words.next)

words.end

    define('writer(lines)')                             :(writer.end)

*   _Writer_ writes the lines in the sequence _lines_ to standard output.

writer

    loop(lines)

writer.next

    output = next(lines)                                :f(return)s(writer.next)

writer.end

*## SETL4 internal functions

*   Functions whose names begin with _setl4_ are for internal use only, and are
*   not meant to be called directly by the SETL4 user.

*   Their definitions and implmentations may change at any time, so use them
*   directly at your own peril.


    define('setl4.clear()')                             :(setl4.clear.end)

*   _Setl4.clear) clears the values of setl4 global variables,
*    in order to reduces amount of &dump output.

setl4.clear

    setl4.config.set.table.size = setl4.config.stack = setl4.config.set.table.size = setl4.config.int =
.   setl4.ascii.initialized = setl4.ascii.name = setl4.config.int.init =
.   setl4.ascii.value = setl4.random.initialized = setl4.any.digit = setl4.span.digits =
.   setl4.break.digit = setl4.break.letter = setl4.any.letter =
.   setl4.span.letters = setl4.span.spaces = setl4.break.space =
.   setl4.any.word = setl4.span.word = setl.sorter.map = sorter.types =
                                                        :(return)
setl4.clear.end

    define('setl4.show(set)iter')                       :(setl4.show.end)

*   Setl4.show_ shows  the fields of an instance of _set_ or _iterator_.

setl4.show

    ident(datatype(set),'iterator')                     :s(setl4.show.iter)
    ident(datatype(set),'set')                          :s(setl4.show.set)
                                                        :(return)

setl4.show.iter

    setl4.show =  out('(iterator '
.            (ne(iter.start(set)) ' start               :'     +iter.start(set), '')
.            (ne(iter.finis(set)) ' finis               :'     +iter.finis(set),'')
.            (ne(iter.step(set))  ' step                :'      +iter.step(set),'') ')' )
                                                        :(return)

setl4.show.map
setl4.show.seq
setl4.show.set

    iter = set.iter(set)
                                        out('{')
                                        out('  kind',     plain(set.kind(set)))
    ne(#set)                   out('  size',     #set)

    differ(set.index(set)) differ(set.key(set))
.                                       out('  has index and key tables')

*   differ(set.index(set))              out('  has index table')
*   differ(set.key(set))                out('  has key table')

*   differ(iter)                        out('  has iterator')
    differ(iter) ne(iter.start(iter))   out('  start',    iter.start(iter))
    differ(iter) ne(iter.finis(iter))   out('  finis',    iter.finis(iter))
    differ(iter) ne(iter.step(iter))    out('  step',     iter.step(iter))
                                        out('}')
    differ(set.index(set)) differ(datatype(set.index(set)),'table')
.           error(' set.index is not table')
    differ(set.key(set)) differ(datatype(set.key(set)),'table')
.           error('set.key is not table')
                                                        :(return)
setl4.show.end

    define('Out(text1,text2,text3)type1,type2')         :(Out.end)

*   _Out_ is just another name for _out_. Use it for debugging, as
*   will be the be easy to find calls to it, so can delete them
*   once they have served their purpose.

Out

    out(text1,text2,text3)                              :(return)

Out.end


*## SETL4 Global variables

    setl4.ascii.initialized =
    setl4.ascii.name =
    setl4.ascii.value =
    setl4.random.initialized =
    setl4.random.value = 2017

*   Useful patterns

    setl4.any.digit         =   any('0123456789')
    setl4.span.digits       =   span('0123456789')
    setl4.break.digit       =   break('0123456789')

    setl4.break.letter      =   break(&lcase &ucase)
    setl4.any.letter        =   any(&lcase &ucase)
    setl4.span.letters      =   span(&lcase &ucase)
    setl4.span.spaces       =   span(' ' char(9))
    setl4.break.space       =   break(' ' char(9))

    setl4.any.word          =   any(&lcase &ucase '0123456789')
    setl4.span.word         =   span(&lcase &ucase '0123456789')

    setl4.random.value      = 2017
*   sorter.types gives valid values for the argument _type_ in the function _sorter()_

    sorter.types = new('map '
.      '+:+k +k:+k +ke:+k +key:+k -:-k -k:-k -ke:-k -key:-k '
.      '+v:+v +va:+v +val:+v +valu:+v +value:+v -v:-v -va:-v -val:-v -valu:-v -value:-v '
.      '+i:+i +in:+i +ind:+ +inde:i+i +index:+i -i:-i -in:-i -ind:- -inde:i-i -index:-i')

*   Show.level is set non-zero when listing elements within a compound object.

    show.level = 0

*   _setl4.config.library.texts_ is a set of the names of the available texts.

    setl4.config.library.texts = new('set dictionary genesis hamlet new-testament old-testament romeo-and-juliet shakespeare sonnets')

*  _Setl4.opsyn_ uses _opsyn_ to define a SETL4 operator.

setl4.op

*  SETL4 uses some of the undefined SPITBOL operators for SETL4 functions.

*  Characters available for use by 'opsyn' to associate the character
*  with a function.

*  binary  &  @  #  %  ~
*  unary:  !  %  /  #  =  | /



    opsyn('=','this',       1)
    opsyn('@','filter',     2)
    opsyn('~','member',     2)

*   Here endeth the SETL4 code.
*   May you fare well using it.




*   Copyright 2017, David Shields
*   Licensed under the MIT license.

*   TODO LIST
*   Note that get() and put() can be used on sets due to implementation of sets.
*   Use eval when adding values to sets, including when initialized using new()


*   SETL4 is an implementation of SETL written in SPITBOL.


*   What is SPITBOL?
*   ----------------

*   SNOBOL is a general programming language with special emphasis on processing 
*   strings and text that was  developed at Bell Labs in the 1960's by a team 
*   led by Ralph Griswold. The final version was called SNOBOL4.

*   Macro SPITBOL, or SPITBOL, is a very efficient implementation of SNOBOL4.
*   Created by Robert B. K. Dewar and Ken Belcher in 1969, SPITBOL/360 
*   was written in IBM/360 assembly language, in what Dewar called
*   "aggressive assembly."
*
*   For example, SNOBOL4 requires maintaining a count of the number of 
*   statements executed and the ability to stop execution when a specified 
*   number of statements have been executed.  SPITBOL/360 does this by
*   computing an unnormalized floating point constant such that successive 
*   increments result in floating point overflow when the limit is reached.

*   Dewar and Belcher also wrote Realia COBOL, a COBOL compiler for Intel/x86 
*   written in COBOL. It produced very efficient code, better
*   code than, for example, that produced by IBM's product COBOL compiler.

*   Dewar ported SPITBOL/360 to several machines. Dewar joined the CIMS faculty
*   as a Professor in the early 1970's. In 1973, while working
*   with Anthony P. "Tony" McCann of Leeds University, he developed
*   Minimal, a portable assembly language. Dewar and McCann then rewrote
*   SPITBOL in Minimal, producing Macro SPITBOL, or SPITBOL. 
*   The implementation has proved very stable, with few changes in
*   several decades.

*   Macro SPITBOL is remarkably small. The code consists of about 28,000
*   lines: 2000 lines of comments defining Minimal, 5000 lines of constant/data 
*   declarations, and 21,000 lines of code.  Every line has a comment.
*   The executable for x86 Linux is 144 kilobytes.

*   SPITBOL was implemented for many machines and operating systems by
*   a small team that included Steve Duff, Mark Emmer, Bob Goldberg, and Dave Shields:
*   ICL 1900, Univac, CDC 6600, IBM PC, Apple Macintosh, SUN Solaris Sparc, 
*   Microsoft (DOS/NT/Windows), Intel x86_64 (Unix/Linux), and x86_64 Apple iOS.  
*   Special credit is due Mark Emmer, who led the project from the mid 1980's
*   to 2009. Dave Shieldsl has maintained SPITBOL since then.


*   What is SETL?
*   -------------

*   SETL (SET Language)  is  a programming language with  finite sets as 
*   the fundamental data type. It was created by Jacob T. "Jack" Schwartz 
*   of the Courant Institute of Mathematical Sciences (CIMS) of New York 
*   University (NYU).

*   Jack founded the SETL project in 1970. It was later funded by two 
*   five-year grants from the Office of Naval Research.

*   SETL was used to write NYU Ada/Ed, the first validated Ada compiler.
*   Devloped on the DEC Vax 11/780, Ada/Ed was ported to the IBM PC (DOS)
*   by a team led by Dave Shields.


*   Why the name SETL4?
*   -------------------

*   The SETL Project produced three implementations of SETL. The first was
*   written by Dave Shields in BALM, a language developed by Prof. Malcom 
*   Harrison of CIMS, the second by Henry S. "Hank" Warren in PL/I while on 
*   leave from IBM, and the third by Robert B. K. Dewar and Art Grand in LITTLE,
*   a low-level implementation language developed at CIMS.

*   SETL4 is the fourth implementation of SETL produced by a member 
*   (Dave Shields) of the NYU SETL project, hence the name SETL4.


*   Brief Introduction to SETL4
*   ---------------------------

*   SETL4 extends SPITBOL by adding the datatype _set_ to represent
*   finite sets. 

*   For example, the folowing SETL4 expression determines if the integer _P_ is prime:

*           !exists(|'int 2 P' @ 'multiple(P,this)')

*   where _multiple(a,b) is true if and only if _a_ is a multiple of _b_.

*   Sets in SETL4
*   -------------

*   SETL4 provides several kinds of sets.

*   Sets of kind 'set' are a collection of distinct members.

*   Sets of kind 'map' consist of a series or ordered pairs,
*   called entries. The first element of an enter is the key,
*    the second is the value.  No two entries in the map can 
*   have the same key but different values.

*   Sets of kind 'iterator' consist of positive integers of the form

*   low, low + step, ... high

*   For example 'iterator 5 25 5' is the set {5 10 15 20 25}.
*   Iterators support efficient iteration, and suppor only the
*   operations of iteration and membership.

*   Sets of kind 'integer' are intended or sets of integers
*   containing many elements. See below for more details.

*   The members usually, but not necessarily consist of a sequence
*   of integers with no gaps; for example 'sequence 5' is a map defined
*   on 1, 2, ... 5.

*   A sequence is a map defined on a set of positive integers
*   that usually, but not necessarily, consists of a consecutive sequence of integers.
*   Sequences are represented as a map. There are no sets of kind 'seq';
*   the string 'seq' is only used in the _new()_ function to provide an optional
*   list of initial values for the sequence.

*   Sets of kind 'string' consists of a map from integers to characters.

*   By convention, the kinds are writtten 'int', 'iter', 'map', and 'set'.

*   Additonal SETL4 data types
*   --------------------------

*   SETL4 provides the following data types in addtion to _set_: 

*       _line_   _token_

*   where 

*       line(mark,text)             is a line of text and an associated mark (tag); and
*       token(lineno,ndx,type,text) is a lexeme, or lexical token.

*   Show
*   ----

*   The function _show_ writes out the value of a SETL4 object in a readable 
*   form. Objects are shown in the order defined by the function _rank_.


*   SETL4 Binary Operators:
*   -----------------------

*   '@'     s @ e   Eval            Evaluates _e_ at current element of set _s_
*   '#'     s # e   Filter          Returns subset of set _s_ for which _e_ is true
*   '~'     m ~ s   Membership      Tests if _m_ is member of set _s_


*   SETL4 Unary Operators:
*   ----------------------

*   '='     =s      Iteration       Returns 'this', the current element of an iteration
*   '|'     |str    Constructor     Returns set specified by string _str_
*   '!'     !expr   Not             True if and only if _expr_ is false
*   '#'     #s      Size            Number of elements in set _s_
*   '/'     /s      Split           Splits a string into a sequence of words

*   The following operator definitions are not yet in effect, due to a need
*   to change the underlying SPITBOL implementation.

*   '&'     a & b   And             True if and only if both _a_ and _b_ are true
*   '^'     a ^ b   Or              True if and only if _a_ or _b_ is true

*   SETL4 Functions
*   ---------------
*
*   add(set,elem)                   Adds element to set, or the members of _elem_ if _elem_ is a set.
*   and(a,b)                        And: test if both operands are true
*   arb(n)                          Returns arbitary (randomly chosen) integer in 1 .. _n_
*   arb(set)                        Returns arbitary (randomly chosen) element of _set_
*   assert(expr)                    Tests that _expr_ is true, ends execution otherwise
*   assert.type(obj,type)           Tests that _obj_ has SPITBOL datatype _type_, ends execution otherwise
*   at(set,expr)                    Evaluates _expr_ for for current iterate of _set_
*   begins(str,sub)                 Tests if string _key_ begins with string _sub_
*   compose(a,b)                    Returns composition of two maps or tables.
*   defined(map,key)                Tests if a map is defined for a specified key
*   difference(a,b)                 Returns set of members of set _a_ not in the set _b_
*   domain(map)                     Returns set of elements in the domain of a map
*   equal(a,b)                      Tests if two SETL4 objects are equal
*   exists(set,expr)                Tests if an expression is true for at least one element in a set
*   from(set,elem)                  Returns set consisting of the members of a set except a specified member
*   get(map,key)                    Gets the value of map _map_ for _key_ for a map
*   get(set,i)                      Gets the i-th element in a set, or fails if no such element
*   false(e)                        tests if argument is false
*   forall(set,expr)                Tests if an expression is true for every element of a set
*   filter(set,expr)                Filter:; returns subset of _set_ for which _expr_ is true
*   int(s)                          Returns integer defined by _s_
*   integers(n)                     Returns set of integers 1 ... n
*   intersection(a,b)               Returns set of elements common to two sets
*   join(a,b)                       Joins two strings into a single string by concatenating them
*   loop(set)                       Set up iteration over _set_ using _next_
*   mark(line)                      Annotates, or marks, a line
*   member(elem,set)                Tests set membership
*   new(str)                        Returns new set specified by _st_
*   next(set)                       Returns next element in iteration defined by prevous _loop_, fails if no more elements
*   not(expr)                       Not: tests if operand is false
*   or(a,b)                         Or: tests if either operand is true
*   push(stack,value)               Push value onto a stack
*   pop(stack)                      Pop the top of a stack
*   put(map,key,val)                Defines the value of a map key
*   random(n)                       Returns random element
*   random.seed()                   Sets random number seed to initialize _random_
*   range(map)                      Returns set of elements in the range of a map
*   rank(set)                       Returns the rank, or normal form, of a set or string.
*   subset(a,b)                     Tests if the second set is a subset of the first set
*   union(a,b)                      Returns set consisting of all the members in two sets
*   set.size(set)                   Returns number of elements in set _set_
*   traceoff()                      Turns off tracing
*   show(v,nested)                  Show value of _v_, with _nested_ set non-zero when listing member of set
*   show.b(e)                       Show value of _b_ as boolean
*   show.line(line)                 Show string _line_ with spaces replaced by '.'
*   show.lines(lines,title)         Show non-empty lines in array of lines, with title 'title'
*   show.q(str)                     Show string enclosed in appropriate quote character (" or ') 
*   traceon()                       Turns on tracing
*   this(set)                       Returns current iteration value for _set_
*   true(e)                         Tests if operand is true
*   visit(set,expr)                 Visits each element of set _set_ and evaluates _expr_ for that element
*   words(str)                      Returns sequence of words, separated by spaces, in a string,


*   Set Data Type
*   -------------

*   A set is defined by the following datatype:

    data('set(set.index,set.key,set.kind,set.size,set.next,set.low,set.high,set.step,set.seq,set.this)')

*   where

*           _set.index_         SPITBOL table used to map the integer
*                               id assigned each element to the value of the element.
*                               It is needed to support fast iteration.

*           _set.key_           SPITBOL table mapping set elements to index entries.

*           _set.kind_          is the kind of the set, one of 'set', 'map', of 'int'. 
*                               The kind is  specified when the set is created. 
*                               The default kind is 'set'.

*           _set.size_          the current number of members.

*           _set.next           is iteration index when iterating over set
*                               when iterating over a 

*           _set.low_           lower bound of _int_ 

*           _set.high_          upper bound of _int_ 

*           _set.step_          number of values between members of set of kind _int_.

*           _set.this           the last value returned by the _next_ primitive


*   Both _set.index_ and _set_key_ tables are needed. New elements in the set are assigned
*   an integer id. The table _set.index_ maps the id to a key. The table _set.key_ maps
*   a key to its associate value.

*   The _set.index_ table is used to iterate over the set. The _set.key_ table is used
*   to retrieve element values.

*   Sets of integers
*   ----------------

*   SETL4 sets of kind _integers' provide an efficient implementation of a set with
*   many non-negative integers, such as  a set with more than a million integers.
*
*   The set is represented by a table of strings, each with  _setl4.config.int_ characters,
*   so that the first block represents the integers `0 .. _setl4_config.int_ -1 and so forth.
*   Addition to  the set is done by setting the appropriate character in a block to '+'.
*   New blocks are allocated only when necesary.
*   The SPITBOL function BREAK is used to find the next element 
*   in the set when iterating over the set.

*   Maps
*   ----

*   In mathematics, a map defined on a finite set is a set of 
*   ordered pairs, or entries,  that define a relation between the 
*   first element of an entry, its _key_, and the second element 
*   of the entry, the value of the map for _key_.

*   The SPITBOL datatype TABLE provides the machinery to implement maps.
*   SPITBOL provides no way to determine the number of entries in a table
*   other than converting the map to an array. This is the only way in 
*   SPITBOL to iterate over a SPITBOL table.

*   For this reason, maps are implemented using two tables: _index_ and _key_.
*   Each new entry added to a map is given an integer id, starting with one.  
*   The field _index_ maps the id's to the associated pairs.
*   The entries in _index_ allow efficient iteration over the  
*
*   The table _key_ maps keys in the map to the corresponding entry in the map.
*   The entries in _key_ permit efficient retrieval of the map's value for a given key.

*   SETL4 also provides the datatype _stack_ that implements a stack, providing
*   the funcitons _push_ and _pop_. Stacks are created by the function _new.stack_.

    data('stack(stack.stack,stack.top)')

*   Additional operations provided as an artifact of the implementation
*   -------------------------------------------------------------------
*   
*   The use of the tables _set.index_ and _set.key_ to implement a set makes it
*   possible to provide some operations not available in in standard set theory. 
*   For example, it is possible to retrieve elements using the function _get_. 
*   _Get(s,i)_ retrieves the i-th element in the set.

*   The function _rank_ can be used to determine the order in which the elements 
*   of a set are accessed during an iteration, or to 'sort' the tables implementing
*   the set. For example, _rank(s,'+v')_ sorts a map in increasing order of the
*   values of the map. _rank(s,'-v') sorts the values in descendng order, and
*   so forth. For example, here is the code to find the ten members with 
*   the largest values in a map:

*```
*       rank(map,'-v')
*       largest = new('set')
*       iter = new('iter 1 10')
*       loop(iter)
*   
*   largest.add
*   
*       add(largest,next(iter))               :s(largest.add)
*```

*   _Rank_ is used by the _show_ function to display the values of a set or
*   map in a standard order. For example, if _s_ is a set with the elements
*   'a', 'b' and 'c', then _show(s)_ yields `set 'a' 'b' 'c' }`, not 
*   `set 'b' 'c' 'a' }`.

*   SETL4 Configuration Options
*   ---------------------------

*   _setl4.include_ is directory containing setl4. If you have cloned github setl4
*   then no change is necessary. Otherwise adjust the definition.
*   Programs using setl4 

*   setl4.include = "~/setl4/"
*   Initial size of any hash tables created when constructing
*   a new instance of a 

*   _setl4.config.size_ is default size for the _index_ and _key_ tables of a set.

    setl4.config.size = 256

*   _setl4.config.int_ is number of characters in the block for an integer set.
*   _setl4.config.int.init_ is string of spaces of size _setl4.config.int_.
*   _setl4.config.int.table is size of index and key tables in set of kind 'int.' 


    setl4.config.int.table = 1000
    setl4.config.int = 1000
    setl4.config.int = 20
    setl4.config.int.init = dupl('-',setl4.config.int)


*   SETL4 needs a stack

    setl4.stack = stack()

*   SETL4 Global Variables
*   ----------------------

    setl4.ascii.initialized = 


*   SETL4 Function Definitions
*   --------------------------

    define('add(set,elem)block,str,this')           :(add.end)

*   Add _elem_ to set _set_ if not already present.
*   If _elem_ is a sequence, then add all the elements in the
*   sequence to the set. If _elem_ is an interator ('iter')
*   then add all the elements of the iterator to the set.


add

*   Convert _elem_ that is integer to integer.
*   Call _eval_ in case element given in exponential notation.

    elem = ident(datatype(elem),'string') eval(elem)
    elem = integer(elem) +elem

    ident(set.kind(set),'int')                      :s(add.int)
    
*   If  _kind_ is 'map', then we are adding new element to  sequence.

    ident(set.kind(set),'map')                      :s(add.seq)
    ident(set.kind(set),'set')                      :s(add.set)
    error('unexpected kind to add:' set.kind(set))

add.int

*   out('add.int adding',elem)
*   Here to test if _elem_ is already in set of kind _int_, 
*   and otherwise to add new integer to the set.
*   Set _block_ to the block for _elem_ and set _this_ to the
*   offset in the block's string corresponding to _elem_.
*   Use _set.step_ to count the number of blocks.
*
*   _Elem_ is not a member if the block is null. Otherwise see
*   if the character corresponding to _elem_ is '+'.

    block = elem / setl4.config.int
    this = +(remdr(elem,setl4.config.int) + 1)
    str = set.key(set)[block]
*   out()
*   out()
*   out('add.int adding elem',elem)
*   out('add.int block',block)
*   out('add.int this',this)
*   out('add.int str',str)
*   ident(str) out('add.int null str')
    ident(str)                                  :s(add.int.new)
*   out('add.int +',substr(str,this,1))
*   ident(substr(str,this,1),'+') out('already in set',elem)
*   ident(substr(str,this,1),'+') out()
    ident(substr(str,this,1),'+')               :s(return)f(add.int.update)

add.int.new

*   Create new block and merge to add the new element.

*   out('at add.int.new')
*   out('add.int before step update',set.step(set))
    set.step(set) = set.step(set) + 1
*   out('add.int creating new block',set.step(set))
*   out('add.int set size',set.size(set))
    set.index(set)[set.step(set)] = block
    set.key(set)[block] = setl4.config.int.init
*   out('add.int new block',block)

add.int.update
    
*   out('add.int.update')
    set.size(set) = set.size(set) + 1
    str = set.key(set)[block]
*   out('add.int.update block',+block)
*   out('add.int old this-1 ',this - 1)
*   out('add.int old str',str)
*   ne(this) out('add.int first','[' substr(str,1,this - 1) ']')
    str = (ne(this) substr(str,1,this - 1),'') 
.       '+' 
.       (lt(this,setl4.config.int) substr(str,this + 1),'')
*   out('add.int new str',str)
*   out('add.int new block',block)
*   out('add.int set.step',set.step(set))
*   show(set.key(set))
*   out('new str',str)
*   out('block now',block)
*   out()
*   out('showing index')
*   show(set.index(set))
*   out('showing key')
*   show(set.key(set))
*   out()
*   out('dt set.key',datatype(set.key(set)))
*   set.key(set)[block] = str
                                                :(return)

add.put

    set.key(set)[key] = elem                        :(return)

add.seq

*   Add element to sequence.

    set.size(set) = set.size(set) + 1
    set.index(set)[set.step(set)] = elem            :(add.put)

add.set

*   Here to add element to set.

    member(set,elem)                                :s(return)
    set.index(set)[set.size(set) = set.size(set) + 1] =
.       set.key(set)[elem] = elem                   :(return)
    
add.end

    define('and(a,b)')                              :(and.end)

*   Tests if both operand are true (not null), only 
*   evaluating the second oerand if necessary.

and

*   See if both operands are integers.

    and = integer(a) eq(a)                          :s(freturn)
    and = integer(a) integer(b) ne(a * b)           :s(return)f(freturn)

*   Here where at least one operand for 'and' is not integer, so
*   use ident/differ to evaluate.

    and = differ(a) differ(b)                       :s(return)f(freturn)

and.end

    define('arb(set)n,r')                           :(arb.end)

*   Returns arb (randomly selected) element of _set_.

arb

    arb = integer(set) random(+set)           :s(return)
    r = random(set.size(set))
    arb = differ(set.step(set))         set.low(set) + (r - 1) * step(set) :s(return)
    arb = set.index(set)[r]                         :(return)
arb.end

    define('assert(expr)')                          :(assert.end)

*   Test that expression is non null, ending execution otherwise.

assert

    true(expr)                                      :s(return)
    error('assertion failed, quitting') 

assert.end

    define('assert.type(obj,typ)')                  :(assert.type.end)

*   Verify that _obj_ has datatype _typ_, end execution if not.

assert.type

    assert(ident(datatype(obj),typ))                :s(return)
    error('assertion on datatype failed ' typ )
    

assert.type.end

    define('at(set,expr)this')                      :(at.end)

*   Evaluate _expr_ for the current element in an iteration.

at

    this = set.next(set)
    at = eval(expr)                                 :(return)

at.end

    define('compose(a,b)ara,i,key,n')               :(compose.end)

*   _Compose_ returns the composition of two maps or tables.

compose

    ident(datatype(a),'table')                      :s(compose.table)

*   Here to compose two maps.

    compose = set(table(set.size(a)),table(set.size(a)),'map')

compose.map.next

    le(i = i + 1,set.size(a))                       :f(return)
   compose[i] = set.key(set)[set.index(set)[i]]     :(compose.map.next)

compose.table

    ara = convert(a,'array')                        :f(show.table.error)
    prototype(ara) break(',') . n
    compose = table(n)

compose.table.next

    key = ara[i = i + 1,2]                          :f(return)
    compose[i] = b[key]                             :(compose.table.next)

compose.end

    define('defined(map,key)entry')                 :(defined.end)

*   Tests if the map _map_ has an entry for _key_.

defined
    key = integer(key) +key
    defined = set.key(map)[key]                     
    differ(defined)                                  :s(return)f(freturn)

defined.end

    define('difference(a,b)this')                   :(difference.end)

*   Returns set defined by set of elements of _a_ that are not in _b_.

difference

    difference = new()
    loop(a)

diference.next

    this = next(a)                                  :f(return)
    member(b,this)                                  :s(difference.next)
    add(difference,this)                            :(difference.next)

difference.end

    define('equal(a,b)entry,i,key,value')                        :(equal.end)

*   Tests if two objects are equal. Use DIFFER unless both are sets, in
*   which case use equality tests specified below.

equal
   
    ident(datatype(a),'set') ident(datatype(b),'set'):s(equal.setl4)
    ident(a,b)                                      :s(return)f(freturn)

equal.setl4

*   Here for equality test of two SETL4 objects.

    ident(set.kind(a),set.kind(b))                  :f(freturn)
    eq(set.size(a),set.size(b))                     :f(freturn)
            :($('equal.' set.kind(a)))

equal.int

    eq(set.low(a),set.low(b))                       :f(freturn)
    eq(set.high(a),set.high(b))                     :f(freturn)
    eq(set.step(a),set.step(b))                     :f(freturn)s(return)

equal.map

*   Two maps are equal if they have the same vaue at every element in the domain.

    gt(i = i + 1, set.size(a))                      :s(equal.true)
    entry = set.index(a)[i]
    ident(value(entry),get(b,key(entry)))           :f(freturn)s(equal.map)

equal.seq

*   Two sequences are equal if they have the same vaue at every element in the domain.

    gt(i = i + 1, set.size(a))                      :s(equal.true)
    ident(set.seq(a)[i], set.seq(b)[i])             :s(equal.seq)f(freturn)

equal.set

*   Two sets are equal if and only if each is a subset of the other.

    equal = and(set.subset(a,b),set.subset(b,a))    :f(freturn)s(return)

equal.end

    define('from(set,elem)this')                    :(from.end)

*   Return set consisting of all the elements of _a_ except _elem_.

from

    from = new()
    loop(set)

from.next

    this = next(set)                                :f(return)
    differ(this,elem) add(from,this)                :(from.next)

from.end

    define('domain(map)elem)')                      :(domain.end)

*   Return set of the keys in _map_.

domain

    domain = new()
    loop(map)

domain.next

    entry = next(map)                               :f(return)
    differ(entry) add(domain,key(entry))            :(domain.next)

domain.end

    define('error(str)')                            :(error.end)

*   Report cause of error and quit execution

error

    &dump = 2
    &dump = 3

*   Clear variables that need not appear in &dump output

    setl4.clear()
    out('Fatal error: ' str)                        :(end)

error.end

    define('exists(set,expr)this,e')                :(exists.end)

*   Tests if there is an element in _set such that _expr_ is true.

exists

    loop(set)

exists.loop

    this = next(set)                                :f(freturn)
    exists = eval(expr)                             :f(exists.loop)s(return)

exists.done

    output = 'exists loop ended, failing' :(freturn)

exists.end

    define('false(e)')                              :(false.end)

*   Tests if argument is false (null).

false

    e = integer(e) +e
    false = integer(e)  eq(e)                       :s(freturn)
    false = ident(e)                                :s(return)f(freturn)

false.end

    define('filter(set,expr)e,this')                :(filter.end)

*   According to Paul Halmos, in his book "Naive Set Theory,"
*   a major principle of set theory, often referred to by its
*   German name _Aussonderungsaxiom_, is the Axiom of Specification:

*   To every set _A_ and every condition _S(x)_ there corresponds
*   a set _B_ whose elements are exactly those elements _x_ of _A_
*   for which _S(x)_ holds.

*   In SETL4 we say that the expression '_A_ @ _S_' "filters"
*   _A_ by _S_. This can also be read as
*           "the subset of _A_ such that _S_ is true"

*   Returns the subset of set or map _set_ for which _expr_ is true.

filter

    filter = new('set')

    loop(set)

filter.loop

    this = next(set)                                :f(return)
    eval(expr) add(filter,this)                     :(filter.loop)

filter.end

    define('forall(set,expr)e')                     :(forall.end)

*   Tests if _expr_ is true for all elements of _set_.

forall

    loop(set)

forall.loop

    next(set)                                       :f(return)
    e = eval(expr)                                  :f(freturn)s(forall.loop)

forall.end


    define('get(map,key)val,entry')                 :(get.end)

*   Gets the value of the key _key_ in the map _map_, or gets
*   element _key_ in a set, failing if no such element.

get

    key = integer(key) +key
    differ(datatype(map),'set') error('get on unsupported type: ' datatype(map))
    ident(set.kind(map),'map')                      :s(get.map)
    ident(set.kind(map),'set')                      :s(get.set)
    error('get on unsupported kind of set: ' set.kind(map))

get.map

    get = set.key(map)[key]
    differ(get)                                     :s(return)f(freturn)

get.set

    get = set.index(map)[key]
    ident(get)                                      :s(freturn)f(freturn)
    get = set.key(map)[entry]                       :(return)

get.end

    define('int(n)')                                :(int.end)

*   Returns _n_ if _n_ is an integer.
*   Returns _n_ converted to an integer if _n_ is real.
*   Returns the value of a string written in exponential 
*   (scientific) notation into its integer value.

int

    int = integer(n) n                              :s(return)
    int = ident(datatype(n),'real') convert(n,'integer') :s(return)
    int = n
    n break('e')                                    :f(return)
    n break('e') . int 'e' =
    int = int * +('1' dupl('0',n))                  
    int = +int
                                                    :(return)

int.end

    define('integers(n)')                           :(integers.end)

*   Return set containing integers 1 .. _n_

integers

    integers = new()

integers.next

    le(i = i + 1,n) add(integers,i)                 :s(integers.next)f(return)

integers.end

    define('intersection(a,b)this')                 :(intersection.end)

*   Returns intersection of sets _a_ and _b_.

intersection

*   Make _a_ the smaller 

    le(set.size(a),set.size(b))                     :s(intersection.next)
    a = b
    b = intersection
    intersection = new()
    loop(a)

intersection.next

    this = next(a)                                  :f(return)
    member(b,this) add(intersection,this)           :(intersection.next)

intersection.end

    define('join(a,b)i')                             :(join.end)

*   _Join_ joins two strings by concatenating them. It joins
*   two sequences by returning a sequence consisting of the
*   elements of the first sequence followed by the elements 
*   of the second sequence.

    differ(datatype(a),datatype(b)) error('differing datatypes to join ' datatype(a)) 
    ident(datatype(a),'map')                     :s(join.map)
    differ(datatype(a),'string') error('join arguments must be strings or sets. ' datatype(a))

*   Here to join two strings.

    join = a b :(return)

join.map
   
    join = copy(a)

join.map.next

    le(i = i + 1,set.size(b))                       :f(return)
    put(join,set.size(a) + i,get(b,i))              :(join.map.next)

join.end

    define('loop(set)dt')                           :(loop.end)

*   Set up for loop. Set next field so that on first call to _next()_
*   the index will be advanced to the first element in the set.

loop

    out('enter loop')
    setl4.show(set)
    ident(set.kind(set),'int')                      :s(loop.int)
    set.next(set) = (differ(set.step(set)) set.low(set) - set.step(set),0) :(return)

loop.int

*   Here to start loop over set of kind 'int'. Set _set.low to -1                              

    out('loop.int')
    setl4.show(set)
*   out()
*   out('showing index')
*   show(set.index(set))
*   out('showing key')
*   show(set.key(set))
*   out()
                                                     :(return)

loop.end

    define('member(set,elem)kind,entry,i,key,this,value)') :(member.end)

*   Tests if _elem_ is member of _set_.

member

*   Branch according to whether _set_ is set or map.

    elem = integer(elem) +elem
    ident(datatype(elem),'entry')                   :s(member.map)
    ident(set.kind(set),'int')                      :s(member.int)
    ident(set.kind(set),'iter')                     :s(member.iter)
    ident(set.kind(set),'set')                      :s(member.set)
    error('member: unexpected kind ' kind )

member.int

*   To test for membership in set of kind _int_ get the block
*   for the element. If it is null then fail since element not
*   in the set. Otherwise see if character corresponding to the
*   value of _elem_ is '+'.

    key = set.key(set)[(elem - 1) / setl4.config.int]
    ident(key)                                      :s(freturn)
    i = remdr(elem,setl4.config.int)
    i = eq(i) setl4.config.int
    ident(substr(key,i,1),'+')                      :s(return)f(freturn)

*   Here to test set membership. Set _key_ to the block for element _elem_,
*   and use BREAK to test membership within the block.

    key = set.key(set)[(member / setl4.config.int) + 1]  :s(freturn)
    ident(key)                                      :s(freturn)
    key break('+')                                  :s(return)f(freturn)

member.iter

    integer(elem)                                   :f(freturn)
    elem = +elem
    lt(elem,set.low(set))                           :s(freturn)
    gt(elem,set.high(set))                          :s(freturn)
    eq(remdr(elem - set.low(set),set.step(set)))    :s(return)f(freturn)

member.set

    elem = integer(elem) +elem 
    differ(set.key(set)[elem])                      :s(return)f(freturn)

member.end

    define('new(init)kind,i,len,n,key,seq,val,words)'):(new.end)

*   Construct new set with initial values determined by string _init_.
*   The first three characters in _init_ determine the initial
*   members of the set.
*
*       'iter'           Sequence of integers low, low+step, ... high
*       'set'           set, followed by list of initial members
*       'map'           map, followed by list of key/value pairs separated by colon
*       'seq'           sequence, followed by list of initial values.

new

    new = set()
    ident(init)                                     :s(new.set)
    init = init ' '
    init span(' ') =
    init break(' ') . kind span(' ') =
    kind = (gt,size(kind),3) substr(kind,1,3)
    begins('integers',kind)                          :s(new.kind)
    begins('iterator',kind)                          :s(new.kind)
    begins('map',kind)                               :s(new.kind)
    begins('seq',kind)                               :s(new.kind)
    begins('set',kind)                               :s(new.kind)
    begins('string',kind)                            :s(new.kind)
    error('bad kind to new ' kind )

new.kind

    kind = gt(size(kind),3) substr(kind,1,3)
    init span(' ') =
    kind = (gt,size(kind),3) substr(kind,1,3)

*   Branch on kind to finish initialization of new set.

                                                    :($('new.' kind))
new.int
    
    new = set(table(setl4.config.int.table),table(setl4.config.int.table))
    set.kind(new) = 'int'

new.int.next

    init break(' ') . key span(' ') =              :f(return)
*   out('adding new.int key',key)
*   out('adding new.int int(key)',int(key))
    add(new,int(key))                              :(new.int.next)

new.ite

    set.kind(new) = 'iter'
    set.key(new) = set.index(new) =
    ident(init) error('new initialization information needed')
    set.step(new) = 1
    ident(init) error('no initializer data for new iterator')
    seq = new('seq ' init)

*   Ignore extra arguments to iterator constructor.

    set.size(seq) = gt(set.size(seq),3) 
    eq(set.size(seq),1)                             :s(new.iter.1)
    eq(set.size(seq),2)                             :s(new.iter.2)
    eq(set.size(seq),3)                             :s(new.iter.3)

new.iter.1


*   If one argument, low is one, high is the argument.
*   Use _eval_ to evalutate the arguments in case they are 
*   given in exponential notation.

    set.low(new) =  1
    set.high(new) = int(eval(get(seq,1)))
    set.step(new) = 1                               :(new.iter.done)

new.iter.2

*   If two arguments, low is first argument, high is the second.

    set.low(new) =  int(eval(get(seq,1)))
    set.high(new) = int(eval(get(seq,2)))
    set.step(new) = 1                               :(new.iter.done)

new.iter.3

*   If three arguments, low is first, high is second, step is third.
    set.low(new) =  eval(get(seq,1))
    set.high(new) = eval(get(seq,2))
    set.step(new) = eval(get(seq,3)) 

new.iter.done

    set.size(new) = ((set.high(new) - set.low(new)) / set.step(new)) + 1 :(return)

new.map
    
    new = set(table(setl4.config.size),table(setl4.config.size))
    set.kind(new) = 'map'

*   If present, _init_ is a list consisting of a list of key/value pairs,
*   with a colon (:) separating the key and value.

    init = init ' '
    init span(' ') =
    ident(init)                                     :s(return)

new.map.next

    init break(':') . key ':' break(' ') . val span(' ') =  :f(return)
    put(new,key,val)                                :(new.map.next)

new.seq

    new = set(table(setl4.config.size),table(setl4.config.size))
    set.kind(new) = 'map'
    init span(' ') =
    ident(init)                                     :s(return)
    init = init ' '

new.seq.next

    init span(' ') =
    init break(' ') . val ' ' =                     :f(return)
    put(new,i = i + 1,val)                          :(new.seq.next)

new.set

    new = set(table(setl4.config.size),table(setl4.config.size))
    set.kind(new) = 'set'
    ident(init)                                     :s(return)

new.set.next

    init break(' ') . key span(' ') =               :f(new.set.done)
    add(new,key)                                    :(new.set.next)

new.set.done

*   Clear _next_ field as it was set during loop above.

    set.next(new) =                                 :(return)

new.end

    define('new.stack()')                           :(new.stack.end)

*   Returns a new stack.

new.stack

*   Don't allocate stack table when creating stack. Do that
*   when first add value to stack.

    new.stack = stack(,0)                           :(return)

new.stack.end

    define('next(set)block,i,kind,key,next,str,value'):(next.end)

*   Advance iteration by setting field _next_.  Fail if no more elements remain.

next

*   Branch on kind to find next iteration value.

        :($('next.' set.kind(set)))

next.int

*   out('next.int ',setl4.show(set))
*   out('at next.int')
*   out('show index')
*   show(set.index(set))
*   out()
*   out('show key')
*   show(set.key(set))
    block = set.index(set)[i]
    str = set.key(set)[block]

*   Branch to find position if this block has an element in the set.

    str break('+')                              :s(next.int.search)


*   Here to advance iteration to next element of set of kind _int_
*   by incrementing _set.next_ until find element in the set.
*   
*   Iterate over blocks in turn. At the start, or when we have 
*   looked at all possible elements in a block, advance to the next 
*   block. Use _set.low to track the number of the current block.
*   Use _set.high_ to keep track of last element found in current
*   block.

*   Iteration over empty set ends here and now.

    eq(set.size(set))                              :s(freturn)

next.int.block

*   Here to advance to next block.

*   out('at next.int.block')
    i = i + 1
*   out('next.int.block i',i)
    block = set.index(set)[i]
*   out('next.int block next block', (eq(block) '0', +block))
*   setl4.show(set)

*   Done if no more blocks.

*   show(set.index(set))
*   show(set.key(set))
    str = set.key(set)[set.index(set)[i]]
*   out('next.int str','[' str ']')
    ident(str)                                      :s(freturn)

*   Here if this block may have an element in the set.
*   If so, want to set _next_ to value corresponding to the element.

*   If _set.high_ is nonzero, then it is the offset in _str_
*   of the most recent member of the set, in which case
*   look only at the remaining part of _str_ for the '+'
*   that indicates membership

*   out('next.int.block str ','[' str ']')
    str = ne(set.high(set)) lt(set.high(set),setl4.conig.int)
.        substr(str,set.high(set) + 1)
    str break('+') . key '+'                        :f(next.int.block)
    next = 0
*   out('next.int start search str', '[' str ']')

next.int.search

    gt(next = next  + 1, setl4.config.int)          :s(freturn)
*   out('next.int.search next',next)
*   out('next.int.search' char,substr(str,next,1))
    ident(substr(str,next,1),'+')                   :f(next.int.search)
     
*   Here with _next_ giving the index of next member within this block.
*   Set _set.high_ to save the position where '+' indicating membership was found.

    set.high(set) = next
    next = set.next(set) = (block * setl4.config.int) + next + set.high(set)
*   out('next.int',next)
                                                    :(return)

next.iter

*   Here to find next element in set of type _iter_.

    next = set.next(set) = set.next(set) + set.step(set)
    le(next,set.high(set))                          :f(freturn)

next.map
next.set

    next = set.next(set) = set.next(set) + 1
    le(next,set.size(set))                          :f(freturn)
    next = set.index(set)[next]
    set.this(set) = next
    this = next                                     :(return)

next.end

    define('not(expr)')                             :(not.end)

*   Returns not of boolean expression.

not

    not = integer(expr) (eq(expr) 1, '')            :s(return)f(freturn)
    not = ident(expr) 1                             :s(return)f(freturn)

not.end

    define('or(a,b)')                               :(or.end)

*   Tests if either operand is true, fails otherwise.
*   Only evaluates second operand if necessary

or
    or = integer(a) ne(a)                           :s(return)
    or = integer(b) ne(b)                           :s(return)

*   Here if operands not both integers, so use ident/differ.

    or = differ(a)                                  :s(return)
    or = differ(b)                                  :s(return)f(freturn)

or.end

    define('out(text1,text2,text3)type1,type2')     :(out.end)

*   Output a line conisting of TEXT1, TEXT2 enclosed
*   in brackets, followed by TEXT3.

out

    output = (text1 (ident(text2) '', '[' text2 ']') (differ(text3) text3, '')) :(return)

out.end

    define('pop(stack)')                            :(pop.end)

*   Pop the top item from the stack, or fail if the stack is empty.

pop

    eq(stack.top(stack)) error('attempt to pop from empty stack')
    pop = stack.stack(stack)[stack.top(stack)]
    stack.top(stack) = stack.top(stack) - 1         :(return)

pop.end

    define('push(stack,value)')                     :(push.end)

*   Push _value_ onto the stack _stack_.

push

    stack.stack(stack) = ident(stack.stack(stack)) table()
    stack.stack(stack)[stack.top(stack) = stack.top(stack) + 1] = value :(return)

push.end

    define('put(map,key,value)v')                   :(put.end)

*   Sets the value of the entry for key _key_ in map _map_ to be _val_,
*   creating a new entry if necessary.

put

    key = integer(key) +key
    value = integer(value) +value
    v = set.key(map)[key]
    differ(v)                                       :s(put.value)

*   Here to create new entry in map, and then merge to set new value.

    set.size(map) = set.size(map) + 1
    set.index(map)[set.size(map)] = key

put.value

    set.key(map)[key] = value                      :(return)

put.end

    define('range(map)elem)')                       :(range.end)

*   Return set of the values of _map_.

range

    range = new()
    loop(map)

range.next

    entry = next(map)                               :f(return)
    add(range,value(key(entry)))                    :(range.next)

range.end

    define('random(n)')                             :(random.end)

*   Return integer uniformly distributed in 1,2,...,n.
*   If n=0 returns real uniformly distributed in the interval [0,1].
*   The algorithm can be found in section 16.1 of "Algorithms in SNOBOL4,"
*   James F. Gimpel, John Wiley and Sons, 1976.

random

    setl4.random_var = remdr(setl4.random_var * 4676, 414971)
    random  = setl4.random_var / 414971.0
    random = ne(n) convert(random * n,'integer') + 1
                                                    :(return)
random.end

    define('random.seed()s,c')                      :(random.seed.end)

*   Compute seed for random number generator from date and time.

random.seed
    setl4.random_var =
    s = g.date
    s = replace(s,'/:-','   ')

*   Get all the digits in s.

random.seed.loop

    s len(1) . c =                                  :f(random.seed.done)
    ident(c,' ')                                    :s(random.seed.loop)
    setl4.random_var = setl4.random_var c           :(random.seed.loop)

random.seed.done

*   Reverse the seed so digits depending on time come first.

    setl4.random_var = +reverse(setl4.random_var    )
                                                    :(return)
random.seed.end

    define('rank(set,type)ara,entry,key,map,seq,str,tbl,value')    :(rank.end)

*   _Rank_ reorders the index table of a set to reflect a desired sort of elements
*   of set, keys of maps, or values of map.

*   _Rank_ can also be used to put a string in normal form by converting the string
*   into a sequence of the characters in the string and then sorting the range
*   of the sequence.

*   The argument _type_ specifies the ordering to be used:

*       '+key'      increasing order of the values in the domain

*       '-key'      decreasing order of the values in the domain

*       '+value'    increasing order of the values in the range

*       '-value'    decreasing order of the values in the range

*       '' (null)   order in which entries were created

*   Types for keys and values may be abbreviated: "+key" may be written
*   as "+k" or "+ke", "+value" as "+v" or +"val", and so forth.

rank

    str = ident(datatype(set),'string') set
    type = get(setl4.rank.types,type) 

*   If the first argument is a string, build a sequence
*   of the characters in the string, and rank the sequence.

    ident(datatype(set),'set') ident(set.kind(set),'int')  :s(return)
    ident(datatype(set),'set') ident(set.kind(set),'iter') :s(return)
    differ(str)                                            :s(rank.string)

rank.merge

*   If  _set_ is a string, will merge here when we have 
*   converted the string to a sequence.

    rank = set
    differ(datatype(set),'set') error('wrong type for rank')
    setl4.sort(set,set.size(set),type)                                    
                                                    :(return)

rank.table

    tbl[ara[i = i + 1,1]] = ara[i,2]                :s(rank.table)f(return)

rank.string

*   Rank a string by using split() to build a sequence of
*   the characters in the string, then go to the label 
*   _rank.merge_ to finish by ranking the map.

    set = split(str)                                
    type = '+v'                                     :(rank.merge)

rank.end

    define('show(v,label,nested)ara,i,kind,elem,ent,line,hdr,map,n,set,this') :(show.end)

*   Show the value of expression _v_.
*   _lev_ is non-zero when called to list element of a compound object.

show

    ident(v)                                        :s(return)
    differ(label) out('show: ' upper(label))
    differ(datatype(v),'set')                       :s($('show.' datatype(v)))

*   When showing a set, save _set.next_ and _set.this_ to avoid
*   disrupting possible existing iteration over the set.
    
    kind = set.kind(v)
    out('show kind',kind)
    ident(kind,'int')                               :s(show.int)
    ident(kind,'iter')                              :s(show.iter)
    ident(kind,'map')                               :s(show.map)
    ident(kind,'set')                               :s(show.set)
    error('show unknown set kind',kind,' quitting.')

show.array

    proto = prototype(ara)
    proto break(',')                                :s(show.array.2)

*   Here for one dimensional array.

show.array.1
    first = ara[add1(.i)]                           :f(show.array.done)
    out(lpad(i,3) tab first)                        :(show.array.1)

show.array.2
    first = ara[add1(.i),1]                         :f(show.array.done)
    out(lpad(i,3) tab show(first) tab show(ara[i,2])) :(show.array.2)

show.entry

    show = show ' ' show(key(v),,1)  ':' show(value(v,,1)) ' ' :(show.done)

show.iter

    show = '{iter: low ' set.low(v) ' high ' set.high(v) ' step ' set.step(v)  '} ' :(show.done)

show.integer

    show = v                                        :(show.done)

show.map

    show = '{ map'
    rank(v,'+k')
    setl4.save(v)
    loop(v)

show.map.next

    elem = next(v)                                  :f(show.map.done)
    show = show ' ' show(elem,,1) ':' show(get(v,elem),,1)
    lt(size(show),setl4.config.int)                              :s(show.map.next)
    out(show)
    show =                                          :(show.map.next)

show.map.done

    setl4.restore(v)
    show = show ' }'                                :(show.done)

show.pair

    show = '{' lineid(num(pair)) ',' "'"
.                       replace(line(pair),' ','.') "'" '}' :(show.done)

show.int

    show = '{ int'
    rank(v,'+k')
    setl4.save(v)
    loop(v)

show.int.next

    elem = next(v)                                :f(show.int.done)
    show = show ' ' show(elem,,1)
    lt(size(show),100)                            :s(show.int.next)
    out(show)
    show =                                        :(show.int.next)

show.int.done

    show = show ' }'                                :(show.done)

show.set

    show = '{ set'
    rank(v,'+k')
    setl4.save(v)
    loop(v)

show.set.next

    elem = next(v)                                :f(show.set.done)
    show = show ' ' show(elem,,1)
    lt(size(show),100)                            :s(show.set.next)
    out(show)
    show =                                        :(show.set.next)

show.set.done

    show = show ' }'                                :(show.done)

show.string

*   Don't quote string that is an integer.

    show = integer(v) v                             :s(show.done)

    show = show.q(v)                                :(show.done)

show.table

    show = 'table ['
    ara = convert(v,'array')                        :f(show.table.error)
    i = 0
*   out('table prototype ara',prototype(ara))
*   prototype(ara) break(',') . n                   
*   out('show.table n',n)
    prototype(ara) break(',') . n                   :(show.table.next)

show.table.error

    error('error converting table to array')

show.table.next

    le(i = i + 1,n)                                 :f(show.table.done)
    show = show ' ' show(ara[i,1],,1) ':' show(ara[i,2],,1)    
    lt(size(show),100)                              :s(show.table.next)
    out(show)
    show =                                          :(show.table.next)

show.table.done

    show = show ' ]'                                :(show.done)
 
show.string.quote

    show = '"'  v '"'                               :(show.done)

show.done

*   Write out result unless listing elements of compound object.

    eq(nested) out(show)                            :(return)

show.end

    define('show.b(e)')                             :(show.b.end)

*   Show value of _e_ as boolean: TRUE or FALSE

show.b

    integer(e) out((ne(e) 'TRUE', 'FALSE'))         :s(return)
    out((differ(e) 'TRUE', 'FALSE'))                :(return)

show.b.end

    define('show.eval(expr)e')                      :(show.eval.end)

*   Show result of evaulating _expr_ as success or fail.

show.eval

    eval(expr)                                      :s(show.eval.success)
    show.eval = 'failure'                           :(show.eval.finis)

show.eval.success
   
    show.eval = 'success'

show.eval.finis

    out('eval ' expr ' ' show.eval)                 :(return)

show.eval.end

    define('show.line(line)')                       :(show.line.end)

*   Show a line with spaces replaced by '.'

show.line

    show.line = replace(line,' ','.')               :(return)

show.line.end

    define('show.lines(lines,title)i,line,titled')  :(show.lines.end)

*   Show the lines that are not empty in an array of lines

show.lines

    title  = 'lines' (differ(title) ' ' title, '')
    out(title)

show.lines.n

    line = lines[add1(.i)]                          :f(return)
    empty(line)                                     :s(show.lines.n)
    differ(titled)                                  :s(show.lines.titled)

*   Do not list header unless at least one non-empty line

    out('    123456789012345')
    titled = 1

show.lines.titled

    out(lpad(lineid(i),2) ' ' replace(line,' ','.')) :(show.lines.n)

show.lines.end

    define('show.q(str)')                           :(show.q.end)

*   Show string _str_ enclosed in quotes

show.q

    str break("'")                                  :s(show.q.single)

*   Here if string does not contain a single quote, so use single quotes around it.

    show.q = "'" str "'"                            :(return)

show.q.double

*   Here if string contains single quote, so use double quotes around it.

    show.q = '"' str '"'                            :(return)

show.q.end

    define('subset(a,b)member')                     :(subset.end)

*   Tests if the second set is a subset of the first.

subset

    gt(set.size(b),set.size(a))                     :s(freturn)
    loop(b)

subset.next

    member = next(b)                                :f(return)
    member(a,member)                                :s(subset.next)f(freturn)

subset.end

    define('this(set)')                             :(this.end)

*   Returns value found in most recent call to next.

this

    this = set.this(set)                            :(return)

this.end

    define('true(e)')                               :(true.end)

*   Tests if operand is true

true

    e = integer(e) +e
    integer(e) ne(e)                                :s(return)
    differ(e)                                       :s(return)f(freturn)

true.end

    define('union(a,b)elem')                        :(union.end)

*   Returns union of sets _a_ and _b_.

union

*   Arrange so set a is the larger 

    ge(set.size(a),set.size(b))                     :s(union.a)
    union = a
    a = b
    b = union

union.a

*   Make copy of a by making copy of a's table.

    union = copy(a)
    loop(b)

union.b

    elem = next(b)                                  :f(return)
    add(union,elem)                                 :(union.b)

union.end

    define('visit(set,expr)')                       :(visit.end)

*   _Visit_ loops over _set and calls _eval_ with argument
*   _expr_  for each of its members.

visit

    loop(set)

visit.next

    this = next(set)                                :f(return)
    eval(expr)                                      :(visit.next)

visit.end

*   The following functions with names beginning with 'setl4' are
*   for internal use only. There is no reason for a user to invoke
*   them save for debugging. Otherwise use them ar your peril

    define('setl4.clear()')                         :(setl4.clear.end)

*   Clear values of setl4 global variables. This reduces amount of &dump output.

setl4.clear

    setl4.config.size = setl4.config.stack = setl4.config.size = setl4.conig.int =
.   setl4.stack = setl4.ascii.initialized = setl4.ascii.name = setl4.config.int.init =
.   setl4.ascii.value = setl4.random_var = setl4.any.digit = setl4.span.digits = 
.   setl4.break.digit = setl4.break.letter = setl4.any.letter =
.   setl4.span.letters = setl4.span.spaces = setl4.break.space =
.   setl4.any.word = setl4.span.word = setl.rank.map = setl4.rank.types = 
                                                    :(return)
setl4.clear.end

    define('setl4.restore(s)')                      :(setl4.restore.end)

*   Restore _next_ and _this_ fields of argument.

    set.this(s) = pop(setl4.stack)
    set.next(s) = pop(setl4.stack)                 :(return)

setl4.restore

    set.this(s) = pop(setl4.stack)
    set.next(s) = pop(setl4.stack)                  
    set.index(s) = pop(setl4.stack)                :(return)

setl4.restore.end

    define('setl4.save(s)')                         :(setl4.save.end)

*   Save _next_ and _this_ fields of argument.

setl4.save

    push(setl4.stack,set.index(s))
    push(setl4.stack,set.next(s))
    push(setl4.stack,set.this(s))                   :(return)

setl4.save.end

    define('setl4.show(set,label)')                 :(setl4.show.end)

*   Show the fields of an instance of _set_.

setl4.show

    differ(label)          out(' setl4.show: '         str.upper(label))
                           out('{')
                           out('  kind',          set.kind(set))
    differ(set.index(set)) out('  has index table')
    differ(set.key(set))   out('  has key table')
    ne(set.size(set))      out('  size',          set.size(set))
    differ(set.next(set))  out('  next',          set.next(set))
    ne(set.low(set))       out('  low',           set.low(set))
    ne(set.high(set))      out('  high',          set.high(set))
    ne(set.step(set))      out('  step',          set.step(set))
                           out('}')
                                                    :(return)
setl4.show.end

    define('setl4.set.size(set)')                   :(setl4.size.end)

*   Return size of operand.

setl4.size

    setl4.size = ident(datatype(set),'string') size(set)    :s(return)
    setl4.size = differ(set.step(set)) (set.high(set) - set.low(set) / set.step(set)) + 1 :s(return)
    setl4.size = set.size(set)                      :(return)

setl4.size.end

    define('setl4.sort(set,n,type)i,key,sort,itbl')  :(setl4.sort.end)

*   _setl4.sort_ sorts the _index_ table of set _set_ according 
*   to _type_ and updates the _set.index_ field to reflect the 
*   desired order.
*
*   _setl4.sort_ doesn't create a new set. It just updates 
*   the index table so that going forward entries will be 
*   visited in the order defined by _type_.

setl4.sort

*   Nothing to do if set is empty or only has one element.

    le(n = set.size(set),1)                         :s(return)
    differ(datatype(set),'set') error('setl4.sort bad datatype ' datatype(set))
    setl4.sort = table(n)
    ident(type)                                     :s(setl4.sort.null)
    ident(type,'+k')                                :s(setl4.sort.key)
    ident(type,'-k')                                :s(setl4.sort.key)
    ident(type,'+v')                                :s(setl4.sort.value)
    ident(type,'-v')                                :s(setl4.sort.value)
    error('setl4.sort unsupported type ' type)

setl4.sort.key

*   If sorting by key, just need to sort the index table.

    setl4.sort = table(n)
    tbl = setl4.sort.table(set.index(set),n,type)

setl4.sort.key.next

    le(i = i + 1,n)                                 :f(setl4.sort.done)
    setl4.sort[i] = set.index(set)[ara[i,1]]        :(setl4.sort.key.next)
    
setl4.sort.value

*   Here to  sort by value: build table mapping index numbers into
*   the values associated with their keys, and sort that.

    tbl = compose(set.index(set),set.key(set))
    type = ident(type,'+v') '+k'
    type = ident(type,'-v') '-k'
    tbl = setl4.sort.table(tbl,n,type)

setl4.sort.value.next

*   The table is in proper order, so replace values with the keys
*   associated with that value.

    le(i = i + 1,n)                                 :f(setl4.sort.done)
    setl4.sort[i] = set.index(set)[tbl[i]]          :(setl4.sort.value.next)
    
setl4.sort.null

*   Here to sort on the order in which entries were created.

    show(set.index(set),'setl4.sort index')
    tbl = setl4.sort.table(set.index(set),n)        :(setl4.sort.done)

setl4.sort.done

    set.index(set) = tbl                            :(return)

setl4.sort.end

    define('setl4.sort.table(table,n,type)i,key,sort,itbl,vtbl') :(setl4.sort.table.end)

*   _Setl4.sort.table_ sorts a table of size _n_ that  maps
*   integers into values according to the value of _type_ , returning 
*   a table reflecting the sort.  The first element in the result
*   is the index (key) in the input table that corresponds to the
*   first value in the sorted order, and so forth.


setl4.sort.table

    le(n,1)                                         :s(return)
    type = substr(type,1,1)
    ara = ident(type)        sort(table,1)          :s(setl4.sort.table.ok)
    ara = ident(type,'+')    sort(table,2)          :s(setl4.sort.table.ok)
    ara = ident(type,'-')    rsort(table,2)         :s(setl4.sort.table.ok)

setl4.sort.table.ok

    setl4.sort.table = table(n)

setl4.sort.table.next
    le(i = i + 1,n)                                  :f(return)
    setl4.sort.table[i] = ara[i,2]                  :(setl4.sort.table.next)

setl4.sort.table.error

    error('error in setl4.sort.table converting table to array')

setl4.sort.table.end

    define('traceoff()')                            :(traceoff.end)

*   Initiate tracing.

traceoff
    &ftrace = &trace =

    g.scoring = g.tracing = 0
    out('stop TRACING ')

traceoff.end

    define('traceon()')                             :(traceon.end)

*   Initiate tracing.

traceon

    out('start TRACING')
*   &ftrace = &trace = 1500000
    g.scoring = g.tracing = 1
                                                    :(return)
traceon.end

*   SETL4 uses some of the undefined SPITBOL operators for SETL4 functions.

*   Characters available for use by 'opsyn' to associate the character
*   with a function.

*   binary  &  @  #  %  ~
*   unary:  !  %  /  #  =  | /

*   define('setl4.op(ch,proc,n)')                   :(setl4.op.end)
*
**  Use _opsyn_ to define SETL4 operator.
*
*setl4.op
*
*   opsyn(ch,proc,n)                                :s(return)
*   error('fatal problem with opsyn for ' ch ')
*
*setl4.op.end

    :(opsyn.bypass)
    output = 'at opsyn'
*   SETL4 binary operators

*    opsyn('&','and',        2)
    opsyn('@','at',         2)
    opsyn('#','filter',     2)
    opsyn('~','member',     2)
*   opsyn('^','or',        2)

*   SETL4 unary operators:

    opsyn('=','this',       1)
    opsyn('|','new',        1)
    opsyn('!','not',        1)
    opsyn('#','setl4.size', 1)
    opsyn('/','split',      1)

*   Use of opsyn for 'and' and 'or' deferred since supporting them requires
*   mucking about with bol4.

opsyn.bypass

*   Utility Functions
*   ---------------

*   In addition to set-theoretic functions SETL4 provides 
*   the following utility functions.

*   cardinal(n)                 Returns 'one' if _n_ is one, else _number(n)_ followed by 's'.
*   dictionary                  Returns set of the (approximately 170,000) words in the ENABLE word list.
*   even(n)                     Tests if _n_ is even
*   factorial(n)                Returns n!  = n * (n -1) * ... * 1
*   multiple(n,m)               Tests if _n_ is a multiple of _m_
*   number(n)                   Returns _n_ as one or two words if possible, else returns _n_
*   odd(n)                      Tests if _n_ is odd
*   prime(n)                    Tests if _n_ is prime
*   primes(n)                   Returns set of primes less than _n_
*   square.root(n)              Returns integer square root on _n_
*   thousands(s)
*   append(str,w,ch)            Appends _ch_ (or space if _ch_ is null) to _str_, then appends _w_
*   ascii(line)                 Returns the text of line with every ascii character identified
*   datename(date)              Returns string based on current time suitable for use as filename
*   digits()                    Returns list of digits: '0 1 2 .. 9'
*   frequency(str)              Returns map giving frequency of characters in _str_
*   letters()                   Returns list of letters : 'a b c ... z A B ... Z''
*   less(str,sub)               Removes the first instance of each character in _sub_ from _str_,
*   lletters()                  Returns list of lower case letters : 'a b c ... z'
*   lower(s)                    Returns _s_ with upper case letters replaced by lower case equivalent
*   out(text1,text2,text3)      Outputs _text1_, then _text2_ enclosed in '[]' if _text2_ not null,
*                               then _text3_ if _text3_ is not null.
*   prefix(str,pre)             Takes a list of space-separated words in _str_ and prefixes each
*                               with the string _pre_
*   reader(filename,expr)       Returns sequence of lines in file _filename_, using _expr_ (if given)
*                               to filter out lines to be ignored.
*   reader(str,delim)           Like _reader(filename..)_ but reads lines from a string with lines
*                                   separated by delimiter _delim_
*   slice(str,first,last)       Same as SPITBOL _substr(str,first,last)_
*   tokens(line)                Returns sequence of the tokens in _line_
*   uletters()                  Returns list of upper case letters : 'A B C ... Z''
*   upper(s)                    Returns _s_ with lower case letters replaced by upper case equivalent
*   writer(lines)               Writes sequence _lines_ to standard output.

    define('cardinal(n,word)')           :(cardinal.end)

*   If _n_ is one, returns 'one' followed by _word_.
*   Otherwise returns _number(n)_ followed by _word_ and the letter 's'.

cardinal

    cardinal = (eq(n,1) 'one ' word, number(n) ' '  word 's'):(return)

cardinal.end

	define('dictionary(filename)file,word')	    :(dictionary.end)

*	Initialize the global dictionary dictionary.

dictionary

    dictionary = new('set')
    set.index(dictionary)  =    table(10000)
    set.key(dictionary)  =      table(10000)
    

*	Read in dictionary from  the dictionary file, with one word per line.

	filename = ident(filename) './data/dict.txt'
	input(.file,3,filename)		                :s(dictionary.next)
	error('unable to open dictionary file ',filename)	:(freturn)

dictionary.next

	word = file					                :f(dictionary.done)
    add(dictionary,word)                        :(dictionary.next)

dictionary.done

	endfile(3)				                    :(return)

dictionary.end

    define('even(n)')                           :(even.end)

*   Tests if _n_ is even.

even

    eq(remdr(n,2))                              :s(return)f(freturn)

even.end

    define('factorial(n)')                      :(factorial.end)

*   Returns n! = n*(n-1)*(n-2) ... 1

factorial

    factorial = (eq(n,1) 1, n * factorial(n -1))    :(return)

factorial.end

    define('multiple(n,m)')                     :(multiple.end)

*   Tests if _n_ is a multiple of _m_.

multiple

    multiple = eq(remdr(n,m))                   :s(return)f(freturn)

multiple.end

    define('number(n)')                         :(number.end)

*  If _n_ can be represented as a string of one or two words then return that string. Otherwise return _n_.

number
    error('number not implemented, quitting.' )
    number = eq(n) 'zero'                       :s(return)
    number = g.numbers[n]
    differ(number)                              :s(return)
    number = n                                  :(return)

number.end

    define('odd(n)')                            :(odd.end)

*   Tests if _n_ is odd.

odd

    odd = ne(remdr(n,2))                        :s(return)f(freturn)

odd.end

    define('prime(n)iter,this')                 :(prime.end)

*   Tests if _n_ is a prime integer.

prime

    n = integer(n) +n
    eq(n,2)                                     :s(return)
    even(n)                                     :s(freturn)
    exists(new('iter 3 ' square.root(n) ' 2'), 'multiple(n,this)') :s(freturn)f(return)

prime.end

    define('primes(n)iter,this')                :(primes.end)

*   Returns set of primes less than _n_.

primes

    primes = filter(new('iter 2 ' (n - 1)),'prime(this)') :(return)
    primes = new('set')
    iter = new('iter 2 ' (n - 1))
    loop(iter)

primes.loop
   
    this = next(iter)                           :f(return)
    prime(this) add(primes,this)                :(primes.loop)

primes.end

    define('square.root(n)')                    :(square.root.end)

*   Returns square root of integer _n_, rounded up.

square.root
   
    square.root = int(sqrt(n)) + 1              :(return)

square.root.end

    define('thousands(s)n')                     :(thousands.end)

*   Format s with comma's every three digits from right.

thousands

    n = size(s)
    thousands = le(n,3) s                       :s(return)
    thousands = thousands(substr(s,1,n - 3)) ',' substr(s, n - 2, 3):(return)

thousands.end

    define('append(str,w,ch)')                  :(append.end)

*   _Appends _ch_, or ' ' if _ch_ is null, to _str_ and then appends _w_.

append

    append = str (ident(str) w, (ident(ch) ' ' , ch) w):(return)

append.end

    define('ascii(line)c,n,name,nul,num,pos')   :(ascii.end)

*   Return the text of line with every ascii character identified.

ascii

    differ(ascii.initialized)                   :s(ascii.initialized)

*   Here to initialize the needed maps.
    
    ascii.init()
    ascii.initialized = 1

ascii.initialized

    nul = substr(&alphabet,1,1)

ascii.next

*   Add space after previous character if result not null.

    ascii = differ(ascii) ascii ' '
    c = substr(line,1,1)                        :f(ascii.done)
    ident(c,nul)                                :s(ascii.null)
    line any('0123456789')                      :s(ascii.integer)
    line any(&lcase &ucase)                     :s(ascii.letter)
    line ' '                                    :s(ascii.space)

*   Check for control character (code <=26)

    &alphabet break(c) . pos                    :f(ascii.other)
    pos = size(pos)
    gt(pos,26)                                  :s(ascii.other)
*TODO here fix g. usage
    ascii = ascii g.ascii.name[c] '(^'
               substr('ABCDEFGHIJKLMNOPQRSTUVWXYZ',pos,1) ')'
    line len(1) =                               :(ascii.next)

ascii.integer

    line span('0123456789') . text =
    ascii = ascii  text                         :(ascii.next)

asciiletter

    line span(&lcase &ucase) . text =
    ascii = ascii  text                         :(ascii.next)

ascii.null

    ascii = ascii 'NUL'                         :(ascii.next)

ascii.other

*   Here if none of the other cases apply, so just list the ascii name.

    ascii = ascii ascii.name[c]
    line = substr(line,2)                       :(ascii.next)

ascii.space

    line span(' ') . text =

    ascii =  ascii 'SPC'
    ascii = gt(size(text),1) ascii 'SPC*' size(text)
    ascii = ascii
                                                :(ascii.next)
ascii.done

    ascii = trim(ascii)                     :(return)

ascii.end

    define('ascii.init(init)entry,name,value') :(ascii.init.end)

*   Initialize maps for use by _ascii_.
*   Since space (ascii 32) prints as space, use the name SPC for 32.

ascii.init


    ascii.init = new('map '
.      '0:NUL 16:DLE 32:SPC 48:0 64:@ 80:P  96:` 112:p '
.      '1:SOH 17:DC1 33:!   49:1 65:A 81:Q  97:a 113:q '
.      '2:STX 18:DC2 34:"   50:2 66:B 82:R  98:b 114:r '
.      '3:ETX 19:DC3 35:#   51:3 67:C 83:S  99:c 115:s '
.      '4:EOT 20 DC4 36:$   52:4 68:D 84:T 100:d 116:t '
.      '5:ENQ 21:NAK 37:%   53:5 69:E 85:U 101:e 117:u '
.      '6:ACK 22:SYN 38:&   54:6 70:F 86:V 102:f 118:v '
.      "7:BEL 23:ETB 39:'   55:7 71:G 87:W 103:g 119:w "
.      '8:BS  24:CAN 40:(   56:8 72:H 88:X 104:h 120:x '
.      '9:HT  25:EM  41:)   57:9 73:I 89:Y 105:i 121:y '
.      '10:LF 26:SUB 42:*   58:  74:J 90:Z 106:j 122:z '
.      '11:VT 27:ESC 43:+   59:; 75:K 91:[ 107:k 123:{ '
.      '12:FF 28:FS  44:,   60:< 76:L 92:\ 108:l 124:| '
.      '13:CR 29:GS  45:-   61:= 77:M 93:] 109:m 125:} '
.      '14:SO 30:RS  46:.   62:> 78:N 94:^ 110:n 126:~ '
.      '15:SI 31:US  47:/   63:? 79:O 95:_ 111:o 127:DEL ')

    ascii.name = .map(efault.size)
    ascii.value = .map(efault.size)
    loop(ascii.init)

ascii.init.next

    entry = setl4.l.next(ascii.init)                :(ascii.init.finis)
*   Correct entry for 0 to be NUL, the NUL character
    ascii.name[substr(&alphabet,+v + 1,1)] = name
    ascii.value[name] = +value                      :(ascii.init.next)
    ascii.name[] = 'NUL'
    ascii.value['NUL'] = 0
    ascii.name[' '] = 'SPC'
    ascii.value['SPC'] = 32                         :(return)

ascii.init.end

    define('begins(str,init)')                      :(begins.end)

*   Tests if string _str_ begins with string _init_.

begins

    ident(str,init)                                 :s(return)
    gt(size(init),size(str))                        :s(return)
    ident(substr(str,1,size(init)),init)            :s(return)f(freturn)

    ident(substr(str,1,size(init)),init)            :f(freturn)

begins.end

    define('datename(date)s')                       :(datename.end)

*   Convert date to form with no spaces, just dashes, to be
*   suitable for use as part of a file name.

datename

    datename = replace(date,' :/','---')
    datename = substr(datename,12,8) '-' substr(datename,1,10)
                                                    :(return)
datename.end

    define('digits()str,ch')                        :(digits.end)

*   Return string consisting of the digits 0 .. 9 separated by a space.

digits

    digits = 
    str = '0123456789'
    
digits.next

    str len(1) . ch =                               :f(return)
    digits = append(digits,ch)                      :(digits.next)

digits.end

    define('less(str,sub)before,after')             :(less.end)

*   Removes the first instance of each character in _sub_ from _str_,
*   where _sub_ is a substr of _str_.

less

    ident(str)                                      :s(return)
    less = str

less.ch
    sub len(1) . ch =                               :f(return)
    less break(ch) . before  ch rem . after
    less = before after                             :(less.ch)

less.end

    define('lletters()str,ch')                      :(lletters.end)

*   Returns string consisting of the lower case letters in _str_ separated by a space.

lletters

    lletters = 
    str = &lcase
    
lleters.next

    str len(1) . ch =                               :f(return)
    lletters = append(lletters,ch)                  :(lleters.next)

lletters.end

    define('letters(str)ch')                        :(letters.end)

*   Returns string consisting of the letters in string _str_ separated by a space.
*   Letters can be used to build a sequence of the non-blank letters in a string: _new('seq ' letters(str))_

letters

    str len(1) . ch =                               :f(return)
    ident(ch,' ')                                   :s(letters)
    letters = letters (differ(letters) ' ', '') ch  :(letters)

letters.end

    define('lower(s)')                              :(lower.end)

*   Converts argument to lower case.

lower

    lower = replace(s,&ucase,&lcase)                :(return)

lower.end

    define('prefix(str,pre)word')                   :(prefix.end)

*   Prefix takes a list of space-separated words _str_ and prefixes each
*   with the str _pre_.

prefix

    str = str ' ';* so each word followed by space

prefix.1

    str break(' ') . word span(' ')  =              :f(return)
    add1(.prefixcount)
    prefix = append(prefix, pre word,'A')           :(prefix.1)

prefix.end

    define('uletters()str,ch')                      :(uletters.end)

*   Returns string consisting of the upper case letters separated by a space.

uletters

    uletters = 
    str = &ucase
    
ulleters.next

    str len(1) . ch =                               :f(return)
    uletters = append(uletters,ch)                  :(ulleters.next)

uletters.end


*   Lines
*   -----

*   Lines can be just strings or, in some cases, a line is represented by a pair:

    data('line(mark,text)')

*   where

*           _mark_ is defined by the value returned by an instance
*           of the _eval_ function ...

*           _text_ is the text of the line.

*   For example, the _reader_ function reads a file and returns a
*   sequence of _lines_.

    define('reader(filename,expr)line,mark')        :(reader.end)

*   _Reader_ returns a sequence of the lines in the file specified by _filename_.
*   If _expr_ is not null, then _eval_ is called just after each
*   line is read, with the variable _pair_ set to the associated pair.
*   If _eval_ fails the line is skipped.  Otherwise returns a new pair
*   to be entered in the input seq.

reader

    differ(filename) input(.file,g.channel.temp,filename):s(reader.opened)
    out('unable to open reader file ' filename '.') :(freturn)

reader.opened

    reader = new('map')

reader.next

    add(map, (ident(filename) input, file))                             :f(reader.eof)s(reader.next)

reader.eof

*   Here at end of file; close temporary file if one was needed.

    differ(filename) endfile(g.channel.temp)                            :(return)

reader.end

    define('reader.str(str,delim)line')             :(reader.str.end)

*   Returns a sequence of the lines in _str_,
*   where the delimiter character _delim_ is used to mark
*   the end of a line. One intended use of _reader.str_
*   is to assist in the construction of test programs.

reader.str

    delim = ident(delim) '/'
    reader.str = setl4..seq()

reader.str.next

    str break(delim) . line delim =                 :f(return)
    add(reader.str,line)                            :(reader.str.next)

reader.str.end

    define('slice(str,first,last)')                 :(slice.end)

slice

    slice = substr(str,first,last)                  :(return)

slice.end


    define('split(str)i,word')                       :(split.end)

*   If the string _str_ has no spaces, _split_ returns a sequence of
*   the characters in _str_. Otherwise, _split_ returns a sequence
*   of the words in _str_, where the words are separated by 
*   whitespace (one of more consecutive spaces or tabs).

split

    split = new('map')
    str break(' ')                                   :f(split.str)

split.next

*   Here to split string into a sequence of its words.

*    str break(' ') . word ' ' =                     :f(return)
    str break(' ') . word ' ' =                     :f(split.str.done)
    put(split,i = i + 1, word)                      :(split.next)

split.str
    
    split = new('map')
    str =  letters(str) ' '

split.str.next

    str span(' ') =
    str break(' ') . word ' ' =                     :f(split.str.done)
*    str break(' ') . word ' ' =                     :f(return)
    put(split,i = i + 1, word)                      :(split.str.next)

split.str.done
*    show(split)             
                                        :(return)

split.end

*   Tokens: Lexical Scanning
*   ------------------------


*   A token is represented as an instance of the datatype _token_ as follows:

    data('token(lineno,ndx,type,text)')

*   where:
*           _lineno_        is the line number within the file;
*           _ndx_           is the index of the first character of the
*                           token in the line;
*           _type_          is the token's type, as described below; and
*           _text_          is the text of the token.

*   The type is represented by a single character, as follows:

*           'c'             comment, indicated by asterisk (*) in the first column.
*                           The text consists of the entire line.

*           'i'             integer, consisting of one or more digits ('0123456789')

*           'l'             left opener, one of '(<[{'

*           'p'             punctation, one of '.;,?!', or single quote ('),
*                           or double quote ("),

*           'o'             other printable character, one of '~@#$%^&*_-+=`'.

*            'q'            quoted str, starting witn '"', and continuing
*                           to the next instance of the opening quote character.

*           'r'             right closer, one of ')>]}'

*           's'             space, consistine of one or more spaces (spaces)

*           't'             tab character

*           'u'             unprintable character, for example control-k

*           'w'             word, consisting of one of more letters in
*                           upper or lower case or "'" or "_".

*   The longest possible str meeting the rules is used when building a token.
*   For example, 'abc' is just the word 'abc', not 'a' followed by 'bc', and so forth.

*   It is recommended that the tab character NOT be used as an abbreviation for
*   one or more spaces in the input file. If tabs are used, then _pos_ is ill-defined.
*   If tabs are not used, then _pos_ indicates the true position in the line of
*   the first character of the token, and so error messages and references to the
*   token will be exact.  For example, _pos_ could be used to indicate where to give
*   emphasis to a token by underlining it, or enclosing it in '_' to generate
*   markdown format, and so forth.

    define('tokens(line)type,pos,text,lineno')  :(tokens.end)

*   Strtokens scans _line_ and returns a table of the tokens in the line.
*   The table has keys from 1..n, where _n_ is the number of tokens found.

*   This function is an instance of what is called a lexiical scanner, or tokenizer,
*   which is the first stage in a programming language compiler, or for any program
*   that processes text files with a specified structure.

tokens

    tokens = setl4..seq()
    line '*'                                        :f(tokenl.next)
    type = 'c'
    text = line
    line =                                          :(tokenl.new)

tokenl.next

    line ' '                                        :s(tokens.space)
    line any('0123456789')                          :s(tokens.integer)
    line any('(<[{')                                :s(tokenl.left)
    line any('.;,?!')                               :s(tokens.punctuation)
    line '"'                                        :s(tokens.quote)
    line any('~@#$%^&*_-+=')                        :s(tokens.other)
    line any(')>]}')                                :s(tokens.right)
    line char(9)                                    :s(tokens.tab)
    line any(&lcase &ucase)                         :s(tokens.word)

*   Here for unprintable
    error('unprintable?? fix in tokens')

tokens.integer

    type = 'i'
    line span('0123456789') . text =                :(tokenl.new)

tokens.punctuation

    type = 'p'                                      :(tokens.character)

tokens.other

    type = 'o'                                      :(tokens.character)

tokens.quote

    type = 'q'
    line '"' break('"') . text '"' =
    text = '"' text '"'                             :(token.new)

tokens.right

    type = 'r'                                      :(tokens.character)

tokens.space

    type = 's'
    line span(' ')  . text =                        :(tokenl.new)

tokens.tab

    type = 't'                                      :(tokens.character)

tokens.word

*TODO*
    type = 'w'
    line span(&ucase &lcase "_" "'") . text =       :(tokenl.new)

tokens.character

*   Here if token is single character.

    line len(1) . text                              :(tokenl.new)

tokenl.new

    setl4.add(tokens,token(lineno,pos,type,text))   :(tokenl.next)

tokens.end

    define('upper(s)')                              :(upper.end)

*   Convert argument to upper case.

upper

    upper = replace(s,&lcase,&ucase)                :(return)

upper.end

    define('writer(lines)')                         :(writer.end)

*   Writes the lines in the sequence _lines_ to standard output.

writer

    loop(lines)

writer.next

    output = next(lines)                            :f(return)s(writer.next)

writer.end

*   SETL4 Global variables
*   ----------------------

    setl4.ascii.name = 
    setl4.ascii.value =  
    setl4.random_var =

*   Useful patterns

    setl4.any.digit         =   any('0123456789')
    setl4.span.digits       =   span('0123456789')
    setl4.break.digit       =   break('0123456789')

    setl4.break.letter      =   break(&lcase &ucase)
    setl4.any.letter        =   any(&lcase &ucase)
    setl4.span.letters      =   span(&lcase &ucase)
    setl4.span.spaces       =   span(' ' char(9))
    setl4.break.space       =   break(' ' char(9))

    setl4.any.word          =   any(&lcase &ucase '0123456789')
    setl4.span.word         =   span(&lcase &ucase '0123456789')

*   setl4.rank.types gives valid values for the argument _type_ in the function _rank()_

    setl4.rank.types = new('map '
.      '+:+k +k:+k +ke:+k +key:+k -:-k -k:-k -ke:-k -key:-k '
.      '+v:+v +va:+v +val:+v +valu:+v +value:+v -v:-v -va:-v -val:-v -valu:-v -value:-v')

*   Here endeth the SETL4 code.
*   May you fare well using it.


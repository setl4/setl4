*   Copyright 2017, David Shields
*   Licensed under the MIT license.

*TODO - need separate out iterator from set data structure. May have multiple loops over same set at onece.
*TODO - need equal for general equality test on sets, maps, etc.

*   SETL4 is an implementation of SETL written in SPITBOL.


*   What is SPITBOL?
*   ----------------

*   SNOBOL is a general programming language with special emphasis on 
*   processing strings and text. *   It was  developed at Bell Labs 
*   in the 1960's by a team led by Ralph Griswold.
*   Their final version was called SNOBOL4.

*   Macro SPITBOL, or SPITBOL, is a very efficient implemenation of SNOBOL4.
*   Created by Robert B. K. Dewar and Ken Belcher in 1969, SPITBOL/360 
*   was written in IBM/360 assembly language, in what Dewar called
*   "aggressive assembly."
*
*   For example, SNOBOL4 requires maintaining a count of the number of 
*   statements executed and the ability to stop execution when a specified 
*   number of statements have been executed.  SPITBOL/360 does this by
*   computing an unnormalized floating point constant such that successive 
*   increments result in floating point overflow when the limit is reached.

*   Dewar and Belcher also wrote Realia COBOL, a COBOL compiler for Intel/x86 
*   written in COBOL. It produced very efficient code, better
*   code than, for example, that produced by IBM's product COBOL compiler.

*   Dewar ported SPITBOL/360 to several machines. Around 1973, while working
*   with Anthony P. (Tony) McCann of Leeds University, he developed
*   Minimal, a portable assembly language. Dewar and McCann then rewrote
*   SPITBOL in Minimal, producing Macro SPITBOL, or SPITBOL. 
*   The implementation has proved very stable, with few changes in
*   several decades.

*   Macro SPITBOL is remarkably small. The code consists of about 28,000
*   lines: 2000 lines of comments defining Minimal, 5000 lines of constant/data 
*   declarations, and 21,000 lines of code.  Every line has a comment.
*   The executable for x86 Linux is 144 kilobytes.

*   SPITBOL was implemented for many machines and operating systems by
*   a small team that included Steve Duff, Mark Emmer, Bob Goldberg, and Dave Shields:
*   ICL 1900, Univac, CDC 6600, IBM PC, Apple Macintosh, SUN Solaris Sparc, 
*   Microsoft (DOS/NT/Windows), Intel x86_64 (Unix/Linux), and x86_64 Apple iOS.  


*   What is SETL?
*   -------------

*   SETL is  a programming language with  finite sets as the fundamental data type.
*   It was created by Jacob T. "Jack" Schwartz of the Courant Institute of 
*   Mathematical Sciences (CIMS) of New York University (NYU).

*   Jack founded the SETL project in 1970. It was later funded by two 
*   five-year grants from the Office of Naval Research.

*   SETL was used to write NYU Ada/Ed, the first validated Ada compiler.
*   Devloped on the DEC Vax 11/780, Ada/Ed was ported to the IBM PC (DOS)
*   by a team led by Dave Shields.


*   Why the name SETL4?
*   -------------------

*   The SETL Project produced three implementations of SETL. The first was
*   written by Dave Shields, the second by Henry S. (Hank) Warren while on 
*   leave from IBM, and the third by Robert B. K. Dewar and Art Grand.

*   SETL4 is the fourth implementation of SETL produced by a member 
*   (Dave Shields) of the NYU SETL project, hence the name SETL4.


*   Brief Introduction to SETL4
*   ---------------------------

*   SETL4 extends SPITBOL by adding the datatype _set_ to represent
*   finite sets. 

*   SETL4 supports a variety of sets. Each has a kind, one of:

*       _int_   _map_   _seq_   _set_   _str_

*   For each kind, SETL4 provides set-theoretic functions, 
*   as well as other functions that have proven to be useful.

*   For example, the folowing SETL4 expression determines if the integer _P_ is prime:

*           !exists(|'int 2 P' @ 'multiple(P,this)')

*   where _multiple(a,b) is true if and only if _a_ is a multiple of _b_.

*   Additonal SETL4 data types
*   --------------------------

*   SETL4 provides the following data types in addtion to _set_: 

*       _entry_   _line_   _pair_    _token_

*   where 

*       pair(first,second)          is ordered pair of two objects;
*       entry(key,value)            is an entry in a map;
*       line(mark,text)             is a line of text and an associated mark (tag); and
*       token(lineno,ndx,type,text) is a lexeme, or lexical token.

*   Int: Set of kind 'int'
*   ----------------------'

*   A set of kind _int_ represents a sequence of positive integers.
*   The set cannot be changed once it is created. You can only loop 
*   over a set of kind _int_ or test for membership.


*   Map: Set of kind 'map'
*   ----------------------
*   A map is a set of ordered pairs.


*   Seq: Set of kind 'seq'
*   ---------------------

*   A sequence (_seq_) is a map on the positive integers 1 .. n
*   Sequences are implemented using SPITBOL arrays, and so are very efficient.


*   Set: Set of kind 'set'
*   ----------------------

*   A set is a collection of distinct elements.


*   Str: Set of kind 'str'
*   ----------------------

*   A string sequence (_str_) is a sequence of characters.


*   Show
*   ----

*   The function _show_ writes out the value of a SETL4 object in a readable 
*   form. Objects are shown in the order defined by the function _rank_.


*   SETL4 Binary Operators:
*   -----------------------

*   '&'     a & b   And             True if and only if both _a_ and _b_ are true
*   '@'     s @ e   Eval            Evaluates _e_ at current element of set _s_
*   '#'     s # e   Filter          Returns subset of set _s_ for which _e_ is true
*   '~'     m ~ s   Membership      Tests if _m_ is member of set _s_
*   '^'     a ^ b   Or              True if and only if _a_ or _b_ is true


*   SETL4 Unary Operators:
*   ----------------------

*   '='     =s      Iteration       Returns the current element of an iteration
*   '|'     |'str'  Constructor     Returns set specified by string _str_
*   '!'     !expr   Not             True if and only if _expr_ is false
*   '#'     #s      Size            Number of elements in set _s_
*   '/'     /s      Split           Splits a string into a sequence of words


*   Global variables
*   ----------------

    setl4.ascii.name = 
    setl4.ascii.value =  
    setl4.random_var =


*   Boolean Logic
*   -------------

*   Boolean logic is an algebra with just two values: true and false.
kkkk
*   In SPITBOL, the algebra is defined on strings: the null string is "false" 
*   and all other strings are "true".  The SPITBOL function IDENT is used 
*   to test for true, DIFFER for false. 
*   Each signals their result by success (true) or failure (false).

*   In SETL4, the algebra is defined both on integers and non-integers.  
*   For integers, zero is "false" and all other integers are "true." 
*   For non-integers, the null string ('') is true, and all other values are false.

*   SPITBOL comparison functions report their results by success or failure, so SETL
*   provides the following functions which return TRUE or FALSE.


*   SETL4 Functions
*   ---------------
*
*   and(a,b)                        And: true if and only if _a_ and _b_ are true
*   arb(n)                          Returns arbitary (randomly chosen) integer in 1 .. _n_
*   arb(set)                        Returns arbitary (randomly chosen) element of _set_
*   assert(expr)                    Tests that _expr_ is true, ends execution otherwise
*   assert.type(obj,type)           Tests that _obj_ has SPITBOL datatype _type_, ends execution otherwise
*   at(set,expr)                    Evaluates _expr_ for for current iterate of _set_
*   binary.search(tbl,value)        Binary search
*   concatenate(a,b)                Concatenates strings _a_ and _b_
*   exists(set,expr)                Tests if _expr_ is true for at least one element in set _set_
*   false(e)                        Returns TRUE if and only if _e_ is FALSE
*   forall(set,expr)                Tests if _expr_ is true for at all elements in set _set_
*   filter(set,expr)                Filter:; returns subset of _set_ for which _expr_ is true
*   iskind(kind,kind1,kind2,kind3,kind3,kind4)  Tests if _kind_ is one of the specfied kinds: _kind1_, _kind2_, ...
*   i.eq(a,b)                       integer is equal to 
*   i.ge(a,b)                       integer greater than or equal
*   i.gt(a,b)                       integer greater than 
*   i.le(a,b)                       integer less than or equal
*   i.lt(a,b)                       integer less than 
*   i.ne(a,b)                       integer not equal

*   loop(set)                       Set up iteration over _set_ using _next_
*   map.domain(map)                 Returns set of elements in the domain of _map_
*   map.first(map)                  Returns the first element in a map
*   map.get(map,key)                Gets the value of map _map_ for _key_
*   map.last(map)                   Returns the last element in a map.
*   map.put(map,key,val)            Sets the value of map _map_ for key _key_ to be _value_
*   map.range(map)                  Returns set of elements in the range of _map_
*   map.defined(map,key)            Tests if map _map_ if defined for _key_
*   mark(line)                      Annotates, or marks, a line
*   member(elem,set)                Tests if _elem_ is a member of set _set_
*   new(str)                        Returns new set specified by _st_
*   next(set)                       Returns next element in iteration defined by prevous _loop_,
*                                   fails if no more elements
*   not(expr)                       Not: true if and only if _expr_ is false
*   or(a,b)                         Or: true if and only if _a_ of _b_ is true
*   random(n)                       Returns random element
*   random.seed()                   Sets random number seed to initialize _random_
*   rank(set)                       Returns the rank, or normal form, of a set or string.
*   seq.add(seq,val)                Adds _val_ to sequence _seq)
*   seq.get(seq,i)                  Returns value of element _i_ of sequence _seq_
*   seq.integers(n)                 Returns sequence consiting of integers 1 .. n
*   seq.push(seq,val)               Adds _val to sequence _seq_
*   seq.pop(seq)                    Removes last element of sequence _seq_ and returns its value
*   seq.put(seq,i,val)              Sets value of elment _i_ in sequence _seq_ to _val)
*   seq.range(seq)                  Returns set of range values of sequence _seq
*   set.add(set,elem)               Adds element _elem_ to set _set_ if not yet a member of the set.
*   set.difference(a,b)             Returns set of members of set _a_ not in the set _b_
*   set.first(set)                  Returns first element in set
*   set.from(set,elem)              Returns set consisting of members of _set_ except for_elem_
*   set.integers(n)                 Returns set of integers 1 ... n
*   set.intersection(a,b)           Returns set of members which belong to both sets _a_ and _b_
*   set.last(set)                   Returns last element in set
*   set.subset(a,b)                 Tests if every member of _b_ is also a member of _a_
*   set.union(a,b)                  Returns set consisting of all the members of _a_ and _b_
*   setl4.ascii.init(init)
*   setl4.size(set)                 Returns number of elements in set _set_
*   traceoff()                Turns off tracing
*   show(v,lvl)                     Show value of _v_, with _lvl_ set non-zero when listing member of set
*   show.b(e)                       Show value of _b_ as boolean (TRUE or FALSE)
*   show.line(line)                 Show string _line_ with spaces replaced by '.'
*   show.lines(lines,title)         Show non-empty lines in array of lines, with title 'title'
*   show.q(str)                     Show string with enclosed in appropriate quote character (" or ') 
*   show.words(words)               Show a sequence of words, separated by space character
*   traceon()                 Turns on tracing
*   this(set)                       Returns current iteration value for _set_
*   true(e)                         Returns TRUE if and only if _e_ is TRUE
*   visit(set,expr)                 Visits each element of set _set_ and evaluates _expr_ for that element


*   Set Data Type
*   -------------

*   A set is defined by the following datatype:

    data('set(set.kind,set.index,set.key,set.size,set.next,set.low,set.high,set.step,set.text,set.seq,set.this)')

*   where

*           _kind_          the kind of _set_: 'int', 'map', 'seq', 'set', or 'str'.

*           _index_         a SPITBOL table used to map the integer
*                           id assigned each element to the value of the element.
*                           It is used to support fast iteration.

*           _high_          upper bound of _int_ set.

*           _low_           lower bound of _int_ set.

*           _key_           a SPITBOL table mapping set elements to index entries.

*           _next           is iteration index when iterating over set
*                           when iterating over a set.
*           _seq_           is the array used to maintain a sequence.

*           _size_          the current number of members.

*           _step_          number of values between members of set of kind _int_.

*           _text_          is the text of the set of kind _str_

*           _this           the last value returned by the _next_ primitive


*   Note that the null value is not allowed as an element of a set or the
*   value of a map key, but can be used as the value of an element in a seq.

*   The _key_ table is needed to provide constant time bounds for iterating over
*   a set, in all of its forms.

*   Since the _key_ table is needed, a set can be indexed using the key table.
*   This allows the definition of 'get' and 'put' on sequences.

*   Sequences are currently implemented using SPITBOL arrays, extending
*   the array length dynamically as needed.

*   New elements can be added to a sequence using the 'push' primitive,
*   and the most recent element can be deleted using the 'pop' primitive.


*   SETL4 Configuration Options
*   ---------------------------

*   Initial size of any hash tables created when constructing
*   a new instance of a set.

*   Use large value for now, to avoid need for expansion during initial testing.
*    setl4.config.size = 16
    setl4.config.size = 120

*   SETL4 Constants
*   ---------------

*   The values of the following variables should NEVER be changed, lest chaos ensue.

    FALSE = 0
    TRUE = 1

*   SETL4 Global Variables
*   ----------------------

    setl4.ascii.initialized = false
    setl4.break.whitespace = break(' ' char(9))
    setl4.span.whitespace =  span(' ' char(9))


*   SETL4 Function Definitions
*   --------------------------

    define('and(a,b)')                              :(and.end)

*   Returns true iff (if and only if) both arguments are true.
*   Only evaluates _b_ if necessary

and

*   See if both operands are integers.

    and = FALSE
    and = integer(a) eq(a)                          :s(return)
    and = integer(a) integer(b) (ne(+a * +b) TRUE, FALSE)    :s(return)

*   Here where at least one operand for 'and' is not integer, so
*   use ident/differ to evaluate.

    and = differ(a) differ(b) true                  :s(return)
    and = FALSE                                     :(return)

and.end

    define('arb(set)kind,n,r')                           :(arb.end)

*   Returns arb (randomly selected) element of _set_.

arb

    kind = set.kind(set)
    arb = integer(set) random(+set)           :s(return)
    r = random(set.size(set))
    arb = (
.       iskind(kind,'int')         set.low(set) + (r - 1) * set.step(set),
.       iskind(kind,'map','set')   set.index(set)[r],
.       iskind(kind,'seq')         set.seq(set)[r],
.       iskind(kind,'str')         substr(set.text(set),r,1),
.       ident(datatype(set),'string') substr(set,r,1))
                                                    :(return)
arb.end

    define('assert(expr)')                          :(assert.end)

*   Verify that _expr_ is TRUE, end execution otherwise.

assert

    true(expr)                                      :s(return)
    error('assertion failed, quitting') 

assert.end

    define('assert.type(obj,typ)')                  :(assert.type.end)

*   Verify that _obj_ has datatype _typ_, end execution if not.

assert.type

    assert(ident(datatype(obj),typ))                :s(return)
    error('assertion on datatype failed ' typ )
    

assert.type.end

    define('at(set,expr)this')             :(at.end)

*   Evaluate _expr_ 

at

    this = set.next(set)
    at = eval(expr)                         :(return)

at.end

    define('concatenate(a,b)')              :(concatenate.end)

*   Concatenate argument strings.

concatenate

    concatenate = a b :(return)

concatenate.end

    define('error(str)')                            :(error.end)

*   Report cause of error and quit execution

error

    &dump = 2
    output = 'Fatal error: ' str                    :(end)

error.end

    define('exists(set,expr)this,e')                     :(exists.end)

*   Tests if there is an element in _set such that _eval(expr)_ is TRUE.

exists

    str.out('exists EXPR',show.q(expr))
    loop(set)

exists.loop

    this = next(set)                                       :f(exists.fail)
    str.out('exists.loop this',this)
    e = eval(expr)                                  :f(exists.loop)
    str.out('exists E',e)
    integer(e) eq(+e)                               :s(exists.loop)
    ident(e) 				                        :s(exists.loop)
    exists = TRUE                                   :(return)

exists.fail

    exists = FALSE                                  :(return)

exists.end

    define('false(e)')                              :(false.end)

*   Returns TRUE if its argument is false, or else FALSE.

false

    e = integer(e) +e
    false = integer(e) (eq(e) TRUE,FALSE)           :s(return)
    false = (ident(e) TRUE, FALSE)                  :(return)

false.end

    define('filter(set,expr)e,this')           :(filter.end)

*   According to Paul Halmos, in his book "Naive Set Theory,"
*   a major principle of set theory, often referred to by its
*   German name _Aussonderungsaxiom_, is the Axiom of Specification:

*   To every set _A_ and every condition _S(x)_ there corresponds
*   a set _B_ whose elements are exactly those elements _x_ of _A_
*   for which _S(x)_ holds.

*   In SETL4 we say that the expression '_A_ @ _S_' "filters"
*   _A_ by _S_. This can also be read as
*           "the subset of _A_ such that _S_ is true"

*   Returns the subset of set or map _set_ for which _expr_ is true.

filter

    setl.filter = set.new(set.kind(set))

    loop(set)

filter.loop

    this = next(set)                                :f(return)
    e = eval(expr)                                  :f(filter.loop)
    false(e)                                        :s(set.4.filter.loop)
    iskind(set.kind(set),'set') setl4.add(filter,this)        :(filter.loop)
    map.put(filter,key(this),value(this))           :(filter.loop)

filter.end

    define('forall(set,expr)e')                     :(forall.end)

*   Tests if _expr_ is true for all elements of _set_.

forall

    loop(set)

forall.loop

    next(set)                                       :f(forall.true)
*    str.out('forall.loop.next',set.next(set))
    e = eval(expr)                                  :f(forall.loop)
*    str.out('forall.loop',e)
    integer(e) eq(+e)                               :s(forall.false)
    ident(e)                                        :s(forall.false)
    						    :(forall.loop)

forall.false

    forall = FALSE                                   :(return)

forall.true

    forall = TRUE				     :(return)

forall.end

    define('iskind(kind,kind1,kind2,kind3,kind4,kind5)') :(iskind.end)

*   Tests if the kind of _set_ is one of kind1, kind2, .... Returns true if so,
*   false otherwise.

iskind

    differ(kind1) ident(kind,kind1)                :s(return)
    differ(kind2) ident(kind,kind2)                :s(return)
    differ(kind3) ident(kind,kind3)                :s(return)
    differ(kind4) ident(kind,kind4)                :s(return)
    differ(kind5) ident(kind,kind5)                :s(return)
                                                   :(freturn)

iskind.end

    define('loop(set)dt')                           :(loop.end)

*   Set up for loop. Set set.next field so that on first call to _next()_
*   the index will be advanced to the first element in the set.

loop

    set.next(set) = (iskind(set,'int') set.low(set) - set.step(set),0) :(return)

loop.end

*   Maps
*   --------------

*   In mathematics, a map, or function, defined on a finite set is a set of 
*   ordered pairs that define a relation between the first element of a pair, 
*   its _key_, and the second element of the pair, the value of the map for _key_.

*   An ordered _pair_ is represented in SETL4 by the following data type:

    data('pair(first,second)')

*   where _key_ is the key, and _value_ is the value of the map for _key_.

*   The SPITBOL datatype TABLE provides the machinery to implement maps.
*   SPITBOL provides no way to determine the number of entries in a table
*   other than converting the map to an array. This is the only way in 
*   SPITBOL to iterate over a SPITBOL table.

*   For this reason, maps are implemented using two tables: _set.index_ and _set.key_.
*   Each new entry added to a map is given an integer id, starting with one.  
*   The field _set.index_ maps the id's to the associated pairs.
*   The entries in _set.index_ allow efficient iteration over the map. 
*
*   The table _set.key_ maps keys in the map to the corresponding id in _set.index_,
*   from which the entry for the key can be found. The entries in _set.key_
*   permit efficient retrieval of the map's value for a given key.


    define('map.defined(map,key)')                 :(map.defined.end)

*   Tests if the map _map_ has an entry for _key_.

map.defined

    map.defined = (differ(set.key(map)[key]) TRUE,FALSE) :(return)

map.defined.end

    define('map.domain(map)elem)')                 :(map.domain.end)

*   Return set of the keys in _map_.

map.domain

    map.domain = set.new()
    loop(map)

map.domain.next

    set.add(map.domain,key(next(map)))             :s(map.domain.next)f(return)

map.domain.end

    define('map.first(map)')                       :(map.first.end)

*   Returns first element in _map_.

map.first

    map.first = set.key(map)[1]                    :(return)

map.first.end

    define('map.get(map,key)val)id')                :(map.get.end)

*   Gets the value of the key _key_ in the map _map_.

map.get

    id = set.key(map)[key]
    ident(id)                                       :s(return)
    map.get = value(set.index(map)[id])             :(return)

map.get.end

    define('map.last(map)')                         :(map.last.end)

*   Returns last element in _map_.

map.last

    output = 'enter map.last'
    map.last = set.key(map)[set.size(map)]           :(return)

map.last.end

    define('map.put(map,key,value)v')               :(map.put.end)

*   Sets the value of the entry for key _key_ in map _map_ to be _val_,
*   creating a new entry if necessary.

map.put

    key = integer(key) +key
    value = integer(value) +value
    v = set.key(map)[key]
    differ(v)                                       :s(map.put.value)

*   Here to create new entry in map, and then merge to set new value.

    set.size(map) = set.size(map) + 1
    set.key(map)[key] = set.size(map)

map.put.value

    set.index(map)[set.key(map)[key]] = entry(key,value):(return)

map.put.end

    define('map.range(map)elem)')                  :(map.range.end)

*   Return set of the values in _map_.

map.range

    map.range = set.new()
    loop(map)

map.range.next

    set.add(map.range,value(next(map)))             :s(map.range.next)f(return)

map.range.end

    define('member(set,elem)kind,entry,i,key,this,value)') :(member.end)

*   Tests if _elem_ is 'elem' of _set, where:

*   _elem_ is element of 'int' if in range, and

*   _elem_ is element of 'int' if in range, and
*   meets requirement if 'step' in nonzero

*   _elem_ is element of map _set if _map_ has entry _elem_.

*   _elem_ is element of sequence _set if _set has entry _elem)

*   _elem_ is element of set _set if _set.in(elem,set)_ is true.

*   _elem_ is element of string _set if _set contains instance of _elem.

member

    differ(datatype(set),'set') str.out('member',set)
    member = FALSE
    kind = set.kind(set)
    iskind(kind,'int')                              :s(member.int)
    iskind(kind,'map')                              :s(member.map)
    iskind(kind,'seq')                              :s(member.seq)
    iskind(kind,'set')                              :s(member.set)
    iskind(kind,'str')                              :s(member.str)
    iskind(kind,'string')                           :s(member.string)
    iskind(kind,'map')                              :s(member.map)
    error('member wrong kind ' kind ' , quitting')

member.int

    member = lt(elem,set.low(set)) FALSE              :s(return)
    member = gt(elem,set.low(set)) FALSE              :s(return)
    member = (eq(remdr(elem - set.low(set),set.step(set))) TRUE, FALSE):(return)

member.map

    key = key(elem)

*   Cannot be member if no entry in _key_ table.

    ident(set.key(set)[key])                        :s(return)

*   There is entry for _key_, see if it has right value.

    equal(set.index[set.key(set)[key]],value)       :f(return)s(member.true)

member.seq

    i = i + 1
    le(i,set.size(set))                             :f(return)
    this = set.seq(set)[i]                          :f(return)
*    equal(this,elem)                                :s(member.true)f(member.seq) 
    ident(this,elem)                                :s(member.true)f(member.seq) 

member.set

    member = (differ(set.key(set)[elem]) TRUE, FALSE) :(return)

member.str

    set break(elem)                                 :f(return)s(member.true)

member.string

    string break(elem)                              :f(return)s(member.true)

member.true

    member = TRUE                                   :(return)

member.end


    define('new(str)init,kind,i,len,n,key,seq,val)')   :(new.end)

*   Construct new set with initial values determined by string _init_.

new
    init = str
    kind = substr(init,1,3)
    ne(size(kind),3) error('new missing kind specification')
    iskind(kind,'int','map','seq','set','str')         :s(new.init)
    error('bad kind to new ' kind )

new.init

*   Strip leading spaces from remaining part of _init_.

    init = substr(init,4)
    init span(' ') =

*   Branch on set kind to finish initialization.

                                                    :($('new.' kind))
new.int

    new = set('int')
    set.index(new) = set.key(new) =                        
    ident(init) error('new initialization information needed')
    set.step(new) = 1
    seq = str.words(init)

*   Ignore extra arguments to int constructor.

    set.size(seq) = gt(set.size(seq),3) 3
    eq(set.size(seq),1)                             :s(new.int.1)
    eq(set.size(seq),2)                             :s(new.int.2)
    eq(set.size(seq),3)                             :s(new.int.3)

new.int.1

*   If one argument, low is one, high is the argument.

    set.low(new) =  1
    set.high(new) = seq.get(seq,1)            
    set.step(set) = 1
                                                    :(new.int.done)

new.int.2

*   If two arguments, low is low, high is second.

    set.low(new) =  +seq.get(seq,1)
    set.high(new) = +seq.get(seq,2)             
    set.step(set) = 1
                                                    :(new.int.done)

new.int.3

*   If three arguments, low is first, high is second, step is third.

    set.low(new) =  +seq.get(seq,1)
    set.high(new) = +seq.get(seq,2)             
    set.step(new) = +seq.get(seq,3)            
                                                    :(new.int.done)

new.int.done

*   Set _next_ so that  incrmenting it on first call to _next_  
*   will point to first element in set

    set.next(new) = set.low(new) - set.step(new) 
                                                    :(return)
new.map
    
    new = set('map',table(setl4.config.size),table(setl4.config.size))

*   If present, _init_ is a list consisting of a list of key/value pairs,
*   with a colon (:) between the key and value.

    ident(init)                                     :s(return)
    init = init ' '

new.map.next

    init break(':') . key ':' break(' ') . val span(' ') =  :f(return)
    map.put(new.map,key,val)                  :(new.map.next)

new.seq

    new = set('seq')
    set.seq(new) = array(setl4.config.size)
    str.out('new seq')
    show(new)
                                                    :(return)
new.set

    str.out('new.set init',show.q(init))
    new = set('set',table(setl4.config.size),table(setl4.config.size))
    ident(init)                                     :s(return)
    init = init ' '

new.set.init

    str.out('new.set.init',show.q(init))
*    init break(' ') . key setl4.span.whitespace =   :f(return)
    init ' ' =
    init break(' ') . key ' '    =   :f(return)
    str.out('new.set.init key',key)
    set.add(new,key)
    show(new)
                                                    :(new.set.init)

new.str

    new = set('seq')
    str.text(new) = init                            :(return)

new.str.init

    init len(1) . key ' ' =                         :f(return)
    seq.push(new,key)                               :(new.str.init)

new.end

    define('next(set)kind,key,next,value')          :(next.end)

*   Advance iteration by setting field _set.next_.
*   Fail if no more elements remain.


next

    differ(kind = set.kind(set),'int')              :s(next.notint)

*   Here to find next element in set of type _int_.

    next = set.next(set) = set.next(set) + set.step(set)
    le(next,set.high(set))                          :f(freturn)

next.notint

    next = set.next(set) = set.next(set) + 1
    le(next,set.size(set))                          :f(freturn)
    set.this(set) = 
.       (
.       iskind(kind,'int')          next,
.       iskind(kind,'map','set')    set.index(set)[next],
.       iskind(kind,'seq')          set.seq(set)[next],
.       iskind(kind,'str')          substr(set.text(set),next,1)
.       ident(datatype(set),'string')   substr(set,next,1)
.       )
        next = set.this(set)
    str.out('next',next)
    str.out('this',this)
                                                    :(return)

next.end

    define('not(expr)')                             :(not.end)

*   Returns not of boolean expression.

not

    not = integer(expr) (ne(expr) FALSE, TRUE)      :s(return)
    not = (differ(expr) FALSE, TRUE)                :(return)

not.end

    define('or(a,b)')                               :(or.end)

*   Returns true iff (if and only if) _a_ or _b_ is true.
*   Only evaluates _b_ if necessary

or
    or = integer(a) ne(a) TRUE                      :s(return)
    or = integer(b) ne(b) TRUE                      :s(return)

*   Here if operands not both integers, so use ident/differ.

    or = (differ(a) TRUE, differ(b) TRUE, FALSE)    :(return)

or.end

    define('random(n)')                             :(random.end)

*   Return integer uniformly distributed in 1,2,...,n.
*   If n=0 returns real uniformly distributed in the interval [0,1].
*   The algorithm can be found in section 16.1 of "Algorithms in SNOBOL4,"
*   James F. Gimpel, John Wiley and Sons, 1976.

random

    setl4.random_var = remdr(setl4.random_var * 4676, 414971)
    random  = setl4.random_var / 414971.0
    random = ne(n) convert(random * n,'integer') + 1
                                                    :(return)
random.end

    define('random.seed()s,c')                      :(random.seed.end)

*   Compute seed for random number generator from date and time.

random.seed
    setl4.random_var =
    s = g.date
    s = replace(s,'/:-','   ')

*   Get all the digits in s.

random.seed.loop

    s len(1) . c =                                  :f(random.seed.done)
    ident(c,' ')                                    :s(random.seed.loop)
    setl4.random_var = setl4.random_var c           :(random.seed.loop)

random.seed.done

*   Reverse the seed so digits depending on time come first.

    setl4.random_var = +reverse(setl4.random_var    )
                                                    :(return)
random.seed.end

    define('rank(set)ara,freq,i,entry,key,seq,str,value')    :(rank.end)

*   Rank returns a sorted version of its operand such that
*   elements are in increasing order. For example,
*           rank('asxybza') is 'aabsxyz'.
*   Sets are ranked in increasing order of their members.
*   Maps are ranked in increasing order of their keys.
*   Sequences (seq's) and int's are always maintained in rank order.

rank
 :(return)
    str.out('rank kind',set.kind(set))
    set = copy(set)
    iskind(set,'int','seq')                         :s(rank.seq)
    setl4kind(set,'map','set','str')                :s($('rank.' setl4kind(set)))
    ident(datatype(set),'string')                   :s(rank.string)
    error('rank unsupported operand type ' datatype(set) )

rank.map

    ara = sort(set.key,1)
    rank = map.new()

rank.map.next

    entry = ara[i = i + 1,1]                        :f(return)
    map.put(rank,key(entry),value(entry))           :(rank.map.next)

rank.seq
rank.int

*   Sequences and strings are always in rank order

                                                    :(return)

rank.set

    ara = sort(set.key,1)
    rank = set.new()

rank.set.next

    set.add(rank,ara[i = i + 1,1])                  :f(return)s(rank.set.next)

rank.str

    str = set.text(set)

rank.str.string

    freq = str.frequency(str)
    seq = set.new()

rank.str.collect

    str len(1) . i =                                :f(rank.str.set)
    set.add(seq,i)                                  :(rank.str.collect)

rank.str.set

    seq = rank(seq)
    loop(seq)

rank.l.next
    
    i = next(seq)                                   :f(return)
    rank.str = rank.str dupl(i,freq[i])             :(rank.l.next)

rank.string

    str = set                                       :(rank.str.string)

rank.end

*   Sequences:
*   ----------

*   A sequence, or 'seq', is a map defined on the positive integers
*   1,2, ... ,n. Sequences are implemented using SPITBOL arrays,
*   which are grown in size when adding a new element for which
*   no room remains in the array.


*   Sets
*   ____


    define('set.add(set,elem)')                     :(set.add.end)

*   Add _elem_ to set _set_ if not already present.

set.add

    elem = integer(elem) +elem
    str.out('enter set.add',elem)
    differ(set.key(set)[elem])                      :s(return)
    set.size(set) = set.size(set) + 1
    set.index(set)[set.size(set)] = elem

*   Set _set.key(set)_ to indicate _elem_ is in the set.

    str.out('adding set elem',elem)
    set.key(set)[elem] = 1                        :(return)

set.add.end

    define('set.difference(a,b)elem')               :(set.difference.end)

*   Returns set defined by set of elements of _a_ that are not in _b_.

set.difference

    set.difference = a @ !'set.member(=a,b)'       :(return)

set.difference.end

    define('set.from(set,elem)this')               :(set.from.end)

*   Return set consisting of all the elements of _a_ except _elem_.

set.from

    set.from = set.copy(set)
    loop(set)

set.from.next

    this = next(set)                               :f(return)
    ident(this,elem)                               :s(set.from.next)
    set.add(set.from,this)                         :(set.from.next)

set.from.end

    define('set.integers(n)i')                      :(set.integers.end)

*   Return set containing integers 1 .. _n_

set.integers

    set.integers = set.new(n)
    i = 0

set.integerl.next

    gt(i = i + 1,n)                                 :s(return)
    set.add(set.integers,i)                         :(set.integerl.next)

set.integers.end

    define('set.intersection(a,b)elem')             :(set.intersection.end)

*   Returns intersection of sets _a_ and _b_.

set.intersection

*   Make _a_ the smaller set.

    le(set.size(a),set.size(b))                     :s(set.intersection.next)
    set.intersection = a
    a = b
    b = set.intersection
    set.intersectino = set.new('set')
    loop(a)

set.intersection.next

    next(a)                                         :f(return)
    set.member(=a,b)                                :f(set.intersection.next)
    set.add(set.intersection,=a)                    :(set.intersection.next)

set.intersection.end

    define('set.subset(a,b)member')                 :(set.subset.end)

*   Tests if _b_ is a subset of _a_.

set.subset

    set.subset = FALSE
    gt(set.size(b),set.size(a))                     :s(return)
    loop(b)

set.subset.next

    member = set.next(b)                            :f(set.subset.true)
    member(member,a)                                :s(set.subset.next)f(return)

set.subset.true

    set.subset = true                               :(return)

set.subset.end

    define('set.union(a,b)elem')                    :(set.union.end)

*   Returns union of sets _a_ and _b_.

set.union

*   Arrange so set a is the larger set.

    ge(set.size(a),set.size(b))                     :s(set.union.a)
    set.union = a
    a = b
    b = set.union

set.union.a

*   Make copy of a by making copy of a's table.

    set.union = copy(a)
    loop(b)

set.union.b

    elem = set.next(b)                              :f(return)
    set.add(set.union,elem)                         :(set.union.b)

set.union.end

    define('show(v,label,lvl)i,kind,elem,ent,line,hdr')        :(show.end)

*   Show the value of expression _v_.
*   _lev_ is non-zero when called to list elem or element
*   of a compound object.

show

    differ(label) str.out('show: ' str.upper(label))

*   If not set, branch on datatype, else branch on kind of set.

    ident(datatype(v),'set') iskind(set.kind(v),'int','map','seq','set','str')  :s($('show.' set.kind(v)))
                                                    :($('show.' datatype(v)))
show.array

    proto = prototype(ara)
    proto break(',')                                :s(show.array.2)

*   Here for one dimensional array.

show.array.1
    first = ara[add1(.i)]                           :f(show.array.done)
    out(lpad(i,3) tab first)                        :(show.array.1)

show.array.2
    first = ara[add1(.i),1]                         :f(show.array.done)
    str.out(lpad(i,3) tab show(first) tab show(ara[i,2])) :(show.array.2)

show.entry

    show = show ' ' show(key(v))  ':' show(value(v)) ' ' :(show.done)

show.int

    show = '[int: low ' set.low(v) ' high ' set.high(v) ' step ' set.step(v)  '] ' :(show.done)

show.integer

    show = v                                        :(show.done)

show.map

*   Call _rank_ so entries listed in rank order.

    map = rank(map)
    loop(v)
    show = '{ map'

show.map.next

    elem = next(v)                                :f(show.map.done)
    show = show ' ' show(elem,,1)
    lt(set.size(show),100)                          :s(show.map.next)
    output = show ' '
    show =                                          :(show.map.next)

show.map.done

    show = show ' }'
                                                    :(show.done)

show.pair

    show = '{' lineid(num(pair)) ',' "'"
.                       replace(line(pair),' ','.') "'" '}' :(show.done)

show.seq

    show = ('[seq')

show.seq.next

    gt(i = i + 1,set.size(v))                   :s(show.seq.done)
    elem = set.seq(v)[i]
    show = (ident(show) '', show ' ') show(elem,,1)
    lt(size(show),100)                          :s(show.seq.next)
    output = show ' '
    show =                                          :(show.seq.next)

show.seq.done

    show = show ' ]'                                :(show.done)

show.set

*   Call _rank_ so entries listed in rank order.

*    set = rank(v)
    str.out('show.set size',set.size(v))
    show = '{ set'
    loop(v)

show.set.next

    key = next(v)                                   :f(show.set.done)
    key = datatype(key,'string') show.q(key)
    str.out('key',key)
    str.out('set.next elem ',elem)
    show = (ident(show,'{') '{ ', show ' ') show(elem,,1)
    show = show ' '  show(elem,,1)
    lt(set.size(v),100)                             :s(show.set.next)
    output = show
    show =                                          :(show.set.next)

show.set.done

    show = show ' }'
                                                    :(show.done)
show.str

    show = show.str(str.text(set))                :(show.done)

show.string

*   Don't quote string that is an integer.

    show = integer(v) v                             :s(show.done)

    show = show.q(v)                            :(show.done)


show.table

    t = convert(v,'array')

show.table.next

    key = t[i = i + 1,1]                            :f(show.done)
    value = t[i,2]

    output = tab show(key)    ' -> ' show(value)
                                                    :(show.table.next)
show.string.quote

    show = '"'  v '"'                               :(show.done)

show.done

    output = eq(lvl) show
                                                    :(return)

show.end
    
    define('show.b(e)')                             :(show.b.end)

*   Show value of _e_ as boolean: TRUE or FALSE

show.b

    integer(e) str.out((ne(e) 'TRUE', 'FALSE'))     :s(return)
    str.out((differ(e) 'TRUE', 'FALSE'))            :(return)

show.b.end

    define('show.line(line)')                       :(show.line.end)

*   Show a line with spaces replaced by '.'

show.line

    show.line = replace(line,' ','.')               :(return)

show.line.end

    define('show.lines(lines,title)i,line,titled')  :(show.lines.end)

*   Show the lines that are not empty in an array of lines

show.lines

    title  = 'lines' (differ(title) ' ' title, '')
    out(itle)

show.lines.n

    line = lines[add1(.i)]                          :f(return)
    empty(line)                                     :s(show.lines.n)
    differ(titled)                                  :s(show.lines.titled)

*   Do not list header unless at least one non-empty line

    out('    123456789012345')
    titled = 1

show.lines.titled

    out(lpad(lineid(i),2) ' ' replace(line,' ','.')) :(show.lines.n)

show.lines.end

    define('show.q(str)')                           :(show.q.end)

*   Show string _str_ enclosed in quotes

show.q

    str break("'")                                  :s(show.q.double)

    show.str = "'" str "'"                          :(return)

show.q.double

    show.q = '"' str '"'                            :(return)

show.q.end

    define('show.words(words)i,pos')                :(show.words.end)

*   Show results of words() call.

show.words

    pos = words[add1(.i),1]                         :f(return)
    out('words ' lpad(pos,2) ' ' words[i,2])        :(show.words)

show.words.end


    define('this(set)')                       :(this.end)

*   Returns value found in most recent call to next.

this

    this = set.this(set)                       
    str.out('this',this)
                                                    :(return)

this.end

    define('true(e)')                              :(true.end)

*   Returns TRUE if _e_ is true, or else FALSE.

true

    e = integer(e) +e
    true = integer(e) (ne(e) TRUE,FALSE)            :s(return)
    true = (differ(e) TRUE, FALSE)                  :(return)

true.end

    define('visit(set,expr)')                       :(visit.end)

*   _Visit_ loops over _set and calls _eval_ with argument
*   _expr_  for each of its members.

visit

    loop(set)

visit.next

    next(set)                                       :f(return)
    eval(expr)                                      :(visit.next)

visit.end

    define('setl4.seq.room(seq)len')                :(setl4.seq.room.end)

*   Ensures that sequence _seq_ has room for a new entry, expanding it if necessary.

setl4.seq.room

    len = prototype(set.seq(seq))
    le(set.size(seq),len)                           :s(return)

*   Here to extend length of array by fifty per cent.

    setl4.seq.extend(seq,(3 * len) / 2)             :(return)

setl4.seq.room.end
    
    define('setl4.show(set,label)')                 :(setl4.show.end)

*   Show the fields of an instance of _set_.

setl4.show

                               str.out('{')
    differ(label)              str.out('show: ' str.upper(label))
                               str.out('kind',set.kind(set))
    ne(set.size(set))          str.out('size',set.size(set))
    differ(set.index(set))     str.out('size(set.index(set))', size(set.index(set)))
    differ(set.key(set))       str.out('size(set.key(set))', size(set.key(set)))
    differ(set.next(set))      str.out('next',set.next(set))
    ne(set.low(set))           str.out('low',set.low(set))
    ne(set.step(set))          str.out('high',set.high(set))
    ne(set.high(set))          str.out('step',set.low(set))
    differ(set.text(set))      str.out('text',set.text(set))
    differ(set.seq(set))       str.out('seq',prototype(set.seq(set)))
                               str.out('}')

                                                    :(return)
setl4.show.end

    define('setl4.size(set)')                       :(setl4.size.end)

*   Return size of operand.

setl4.size

    setl4.size = ident(datatype(set),'string') size(set)    :s(return)
    kind = iskind(set)
    setl4.size = iskind(kind,'int')
.               set.high(set) - set.low(set) + 1    :s(return)
    setl4.size = set.size(set)                      :(return)

setl4.size.end

    define('traceoff()')                      :(traceoff.end)

*   Initiate tracing.

traceoff
    &ftrace = &trace =

    g.scoring = g.tracing = 0
    out('stop TRACING ')

traceoff.end

    define('traceon()')                       :(traceon.end)

*   Initiate tracing.

traceon

    out('start TRACING')
*   &ftrace = &trace = 1500000
    g.scoring = g.tracing = 1
                                                    :(return)
traceon.end

*   SETL4 uses some of the undefined SPITBOL operators for SETL4 functions.

*   Characters available for use by 'opsyn' to associate the character
*   with a function.

*   binary  &  @  #  %  ~
*   unary:  !  %  /  #  =  | /

*   define('setl4.op(ch,proc,n)')                   :(setl4.op.end)
*
**  Use _opsyn_ to define SETL4 operator.
*
*setl4.op
*
*   opsyn(ch,proc,n)                                :s(return)
*   error('fatal problem with opsyn for ' ch ')
*
*setl4.op.end

*   SETL4 binary operators

    opsyn('&','and',        2)
    opsyn('@','at',         2)
    opsyn('#','filter',     2)
    opsyn('~','member',     2)
*   opsyn('^','or',        2)

*   SETL4 unary operators:

    opsyn('=','this',       1)
    opsyn('|','new',        1)
    opsyn('!','not',        1)
    opsyn('#','setl4.size', 1)
    opsyn('/','split',      1)

*   Here endeth the SETL4 code.
*   May you fare well using it.

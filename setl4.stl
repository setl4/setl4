*    Copyright 2017, David Shields
*   Licensed under the MIT license.

*   TODO LIST

*   Fix problem in initializing random. Bol4 date() isn't working.

*   Exploit fact that library/dictionary sorted by increasing
*   order of word size?


*## SETL4 is an implementation of SETL written in SPITBOL.


*## What is SPITBOL?

*   SNOBOL is a general programming language with special emphasis on processing 
*   strings and text that was  developed at Bell Labs in the 1960's by a team 
*   led by Ralph Griswold. The final version was called SNOBOL4.

*   Macro SPITBOL, or SPITBOL, is a very efficient implementation of SNOBOL4.
*   Created by Robert B. K. Dewar and Ken Belcher in 1969, SPITBOL/360 
*   was written in IBM/360 assembly language, in what Dewar called
*   "aggressive assembly."
*
*   For example, SNOBOL4 requires maintaining a count of the number of 
*   statements executed and the ability to stop execution when a specified 
*   number of statements have been executed.  SPITBOL/360 does this by
*   computing an unnormalized floating point constant such that successive 
*   increments result in floating point overflow when the limit is reached.

*   Dewar and Belcher also wrote Realia COBOL, a COBOL compiler for Intel/x86 
*   written in COBOL. It produced very efficient code, better
*   code than, for example, that produced by IBM's product COBOL compiler.

*   Dewar ported SPITBOL/360 to several machines. Dewar joined the CIMS faculty
*   as a Professor in the early 1970's. In 1973, while working
*   with Anthony P. "Tony" McCann of Leeds University, he developed
*   Minimal, a portable assembly language. Dewar and McCann then rewrote
*   SPITBOL in Minimal, producing Macro SPITBOL, or SPITBOL. 
*   The implementation has proved very stable, with few changes in
*   several decades.

*   Macro SPITBOL is remarkably small. The code consists of about 28,000
*   lines: 2000 lines of comments defining Minimal, 5000 lines of constant/data 
*   declarations, and 21,000 lines of code.  Every line has a comment.
*   The executable for x86 Linux is 144 kilobytes.

*   SPITBOL was implemented for many machines and operating systems by
*   a small team that included Steve Duff, Mark Emmer, Bob Goldberg, and Dave Shields:
*   ICL 1900, Univac, CDC 6600, IBM PC, Apple Macintosh, SUN Solaris Sparc, 
*   Microsoft (DOS/NT/Windows), Intel x86_64 (Unix/Linux), and x86_64 Apple iOS.  
*   Special credit is due Mark Emmer, who led the project from the mid 1980's
*   to 2009. Dave Shieldsl has maintained SPITBOL since then.

*   SETL4 requires a modified version of standard SPITBOL called BOL4.
*   BOL4 differs from standard SPITBOL as follows:
*
*-  There is no automatic case folding. In standard SPITBOL the names 'x' and 'X' are the same.
*   In BOL4 they are different.
*-  The default case is lower case.
*-  The function _set()_ has been renamed to _zet_, so that _set_ can be used as an identifier.
*-  The default value of _&anchor_ is 1. The default value of _&trim_ is 1.

*   The file `bin/setl4' is the executable for _bol4_.

*## What is SETL?

*   SETL (SET Language)  is  a programming language with  finite sets as 
*   the fundamental data type. It was created by Jacob T. "Jack" Schwartz 
*   of the Courant Institute of Mathematical Sciences (CIMS) of New York 
*   University (NYU).

*   Jack founded the SETL project in 1970. It was later funded by two 
*   five-year grants from the Office of Naval Research.

*   SETL was used to write NYU Ada/Ed, the first validated Ada compiler.
*   Devloped on the DEC Vax 11/780, Ada/Ed was ported to the IBM PC (DOS)
*   by a team led by Dave Shields.


*## Why the name SETL4?

*   The SETL Project produced three implementations of SETL. The first was
*   written by Dave Shields in BALM, a language developed by Prof. Malcom 
*   Harrison of CIMS, the second by Henry S. "Hank" Warren in PL/I while on 
*   leave from IBM, and the third by Robert B. K. Dewar and Art Grand in LITTLE,
*   a low-level implementation language developed at CIMS.

*   SETL4 is the fourth implementation of SETL produced by a member 
*   (Dave Shields) of the NYU SETL project, hence the name SETL4.


*## Brief Introduction to SETL4

*   SETL4 extends SPITBOL by adding the datatype _set_ to represent
*   finite sets. 

*   A set is a collection of distinct elements: for example,  _{a,b,c}_ is a set,
*   as is _{a,b,c,a}_; however, _{a,b,c,a}_ has only three elements, and is 
*   equal to _{a,b,c}_.

*   For example, the folowing SETL4 expression determines if the integer _P_ is prime:

*           !exists(|'int 2 P' @ 'multiple(P,this)')

*   where _multiple(a,b) is true if and only if _a_ is a multiple of _b_.

*## Sets in SETL4

*   SETL4 provides several kinds of sets.

*   Sets of kind 'set' are a collection of distinct members.

*   Sets of kind 'map' consist of a series or ordered pairs,
*   called entries. The first element of an enter is the key,
*    the second is the value.  No two entries in the map can 
*   have the same key but different values.

*   Sets of kind 'iterator' consist of  integers of the form
*```
*   low, low + step, ... high
*```

*   or

*```
*   high, high - step ... low
*```

*   For example 'iterator 5 25 5' is the set {5 10 15 20 25};
*   iteration over the iterator will go in order 5, 10 ... 25.
*   'iterator 25 5 -5' is the same set; but iteration will
*   go in the order 25,20 ... 5.
*
*   If _high_ is less than _low_, then a negative step is undersood,
*   even if it is given as a positive value. For example, both
*   `iter 25 5 -5` and `iter 25 5 5' go in order "25, 20 ... 1"
    
*   Iterators support efficient iteration, but they provide only
*   the operations of iteration and membership; you cannot
*   add or remove an element from an iterator.

*   Sets of kind 'integer' are intended or sets of integers
*   containing many elements. See below for more details.

*   The members usually, but not necessarily consist of a sequence
*   of integers with no gaps; for example 'sequence 5' is a map defined
*   on 1, 2, ... 5.

*   A sequence is a map defined on a set of positive integers
*   that usually, but not necessarily, consists of a consecutive sequence of integers.
*   Sequences are represented as a map. There are no sets of kind 'seq';
*   the string 'seq' is only used in the _new()_ function to provide an optional
*   list of initial values for the sequence.

*   Sets of kind 'string' consists of a map from integers to characters.

*   By convention, the kinds are writtten 'int', 'iter', 'map', and 'set'.


*## Set Data Type

*   A set is a collection unequall objects, and is represented in SETL4 by the datatype _set_:

    data('set(set.kind,set.iter,set.index,set.key,set.kind,set.size,set.this,'
.        'set.block,set.blocks,set.offset,set.str)')

*   where

*- _set.index_         SPITBOL table used to map the integer
*id assigned each element to the value of the element.
*It is needed to support iteration.

*- _set.iter_ iterator for controlling iteration over the set.

*- _set.key_  SPITBOL table mapping set elements to index entries.

*- _set.kind_ 
*is the kind of the set, one of 'int', 'iter', 'map', or 'set.'
*The kind is  specified when the set is created. 
*The default kind is 'set'.

*- _set.size_ the current number of members.

*- _set.str_           is used for sets of kind 'int'

*- _set.this_          the most recent value returned by the set's iterator


*   The following fields are used only for sets of kind 'int':

*- _set.block_         block 

*- _set.blocks_        number of blocks

*- _set.offset_        offset within block corresponding to a given integer

* _set.str_           used to update the current block's membersip string


*   New elements in the set are assigned an integer id.
*   The table _set.index_ maps the id to a key;
*   it is used to iterate over the set.
*   The table _set.key_ maps a key to its associated value;
*   it is used to retrieve element values.

*## Sets of integers
*   ----------------

*   SETL4 sets of kind _integers' provide an efficient implementation of a set with
*   many non-negative integers, such as  a set with more than a million integers.
*
*   The set is represented by a table of strings, each with  _setl4.config.int_ characters,
*   so that the first block represents the integers `0 .. _setl4_config.int_ -1 and so forth.
*   Addition to  the set is done by setting the appropriate character in a block to '+'.
*   New blocks are allocated only when necesary.

*   The SPITBOL function BREAK is used to find the next element 
*   in the set when iterating over the set.

*## Ordered Pairs
*   -------------

*   In set theory, sets are not ordered. The set _{a,b}_ is the same as (equal to)
*   the set _{b,a}_.

*   Although sets are not ordered, sets can be used to define an ordered pair:

    data('pair(first,second)')

*   by defining _pair(a,b)_ to be
*
*       _{a,{a,b}}_
*
*   It is easy to prove that, given this definition, _pair(a,b)_ is equal
*   to _pair(c,d)_ if and only if _a_ is equal to _c_ and _b_ is equal to _d_.


*## Maps
*   ----

*   A map defined on a finite set is a set of ordered pairs,
*   or entries, that define a relation between the first element of an entry,
*   its _key_, and the second element of the entry, the value of the map for _key_.

    data('entry(key,value)')

*   A set of ordered pairs is a map if and only if there do not exist two entries
*   _entry(a,b)_ and _entry(c,d)_ such that _a_ is equal to _c_ and _b_ is not equal to _d_.
*   For example, the map defined by the set _{[one,1],[2,two],[one,1]}_ is valid, but
*   one cannot define a map based on the set _{[one,1],[2,two],[one,3]}_.

*   However, SETL4 does allow the use of a set of pairs that would not 
*   be allowed in stanard set theory to define a map. If two of more pairs
*   have the same first value, the the last such pair encountered defines the
*   value to be used. For exampe, the set _{entry(one,1),entry(2,two),entry(one,3)}_ produces
*   the same map as _{entry(one,3),entry(2,two)}_.

*   Though you can use _entry to give a key and its associated value, the
*   preferred convention is separate a key and its value with a ':'
*   allows you to write "key:value," so that 
*```
*       new('map' one:1 two:2 three:3')

*```
*   instead of

*```
*       new('map' entry('one',1) ' ' entry('two',2) ' ' entry('three',3) )
*```

*   Though in set theory, maps are defined in terms of sets, in the SETL4
*   implementation, sets are represented are maps, by mapping each element
*   to itself. For example, the set _{a,b,c}_ is kept as the map: {a:a,b:b,c:c}.

*   SETL4 supports adding entries to a set of kind _map_ by using the
*   key and value in the entry to define the value of the map for _key(entry)_
*   to be _value(entry)_.

*   The SPITBOL datatype TABLE provides the machinery to implement maps.
*   SPITBOL provides no way to determine the number of entries in a table
*   other than converting the map to an array. This is the only way in 
*   SPITBOL to iterate over a SPITBOL table.

*   For this reason, maps are implemented using two tables: _index_ and _key_.
*   Each new entry added to a map is given an integer id, starting with one.  
*   The field _index_ maps the id's to the associated pairs.
*   The entries in _index_ allow efficient iteration over the  
*
*   The table _key_ maps keys in the map to the corresponding entry in the map.
*   The entries in _key_ permit efficient retrieval of the map's value for a given key.

*   SETL4 supports stacks by implementing them as a sequence. The fuction
*   _push()_ pushes a value on to the stack; the function _pop_ removes the
*   top value.


*## Loops, Iterators

*   Loops in SPITBOL have the form of a test followed by the loop body,
*   with the body with a branch back to the test.

*  For example, here is a loop that prints the first one hundred integers:

*```
*test
*       i = i + 1
*       le(i,100)                       :f(done)
*       output = i                      :(test)
*done
*```

*   This can also be written as:

*```
*test
*       output = le(i = i + 1,100) i    :s(test)
*```

*   SETL4 provides the datatype _iterator_ to control iteration over a 
*   range of integers, over a set, or over a map.

    data('iterator(iter.next,iter.start,iter.finis,iter.step,'
.                 'iter.block,iter.blocks,iter.offset,iter.str)')

*   where

*-  _iter.next last value returned by the iterator.

*-  The following fields are used to iterate over a range:

*-  _iter.start_ starting value for iteration

*-  _iter.finis_ finishing value for iteration

*-  _iter.step_  difference between values of an iteration

*   Loops in SETL4 are constructed using the _loop_ and _next_ statements. 
*   For example, the program to display the first one hundred integers can
*   be written as:

*```
*   set = integers(100)
*   loop(set)
*next
*   this = next(set)                  :f(done)
*   output = this                     :s(test)
*done
*```

*   The _loop_ statement creates an instance of _iterator_ to control the
*   iteration. The _next_ statement advances the iteration by producing the
*   next element or failing if no more elements remain.
*   The variable _this_ is set to the next element in an iteration if a call
*   to _next_ succeeds, so the loop can be written in SETL4 as:

*```
*   set = integers(100)
*   loop(set)
*test
*   output = next(set)                  :s(test)
*```

*   See the functions _prime_ and _primes_ defined below to see _loop_
*   and _next_ in action. See also the code for _exists_ and _forall_.

*## Additional Operations Provided as an Artifact of the Implementation
    
*   The use of the tables _set.index_ and _set.key_ to implement a set makes it
*   possible to provide some operations not available in in standard set theory. 
*   For example, it is possible to retrieve elements using the function _get_. 
*   _Get(s,i)_ retrieves the i-th element in the set.

*   The function _rank_ can be used to determine the order in which the elements 
*   of a set are accessed during an iteration, or to 'sort' the tables implementing
*   the set. For example, _rank(s,'+v')_ sorts a map in increasing order of the
*   values of the map. _rank(s,'-v')_ sorts the values in descendng order, and
*   so forth. For example, here is the code to find the ten members with 
*   the largest values in a map:

*```
*       rank(map,'-v')
*       largest = new('set')
*       iter = new('iter 1 10')
*       loop(set)
*   
*   largest.add
*   
*       add(largest,next(set))               :s(largest.add)
*```

*   _Rank_ is used by the _show_ function to display the values of a set or
*   map in a standard order. For example, if _s_ is a set with the elements
*   'a', 'b' and 'c', then _show(s)_ yields `set 'a' 'b' 'c' }`, not 
*   `set 'b' 'c' 'a' }`.

*## SETL4 Configuration Options

*   _setl4.config.channel.1_ is channel number for temporary files, that is,
*   files created on entry to a procedure and closed before returning from
*   the procedure.

    setl4.config.channel.1 = 3

*   Define initial sizes of tables when creating a set.

*   _setl4.config.set.table.size_ is default size for the _index_ and _key_ tables of a set.

    setl4.config.set.table.size = 1024

*   _setl4.config.int.table.size_ is size of index and key tables in set of kind 'int.' 

    setl4.config.int.table.size = 1000

*   _setl4.config.int_ is number of characters in the block for an integer set.
*   _setl4.config.int.init_ is string of spaces of size _setl4.config.int_.

    setl4.config.int = 1000
    setl4.config.int = 20
    setl4.config.int.init = dupl('-',setl4.config.int)

*## Additonal SETL4 data types

*   SETL4 provides the following data types in addtion to _set_: 

*       _line_   _token_

*   where 

*       line(mark,text)             is a line of text and an associated mark (tag); and
*       token(lineno,ndx,type,text) is a lexeme, or lexical token.

*## Show

*   The function _show_ writes out the value of a SETL4 object in a readable 
*   form. Objects are shown in the order defined by the function _rank_.



*   '@'     s @ e   Eval            Evaluates _e_ at current element of set _s_
*   '#'     s # e   Filter          Returns subset of set _s_ for which _e_ is true
*   '~'     m ~ s   Membership      Tests if _m_ is member of set _s_


*## SETL4 Unary Operators:

*   '='     =s      Iteration       Returns 'this', the current element of an iteration
*   '|'     |str    Constructor     Returns set specified by string _str_
*   '!'     !expr   Not             True if and only if _expr_ is false
*   '#'     #s      Size            Number of elements in set _s_
*   '/'     /s      Split           Splits a string into a sequence of words

*   The following operator definitions are not yet in effect, due to a need
*   to change the underlying SPITBOL implementation.

*   '&'     a & b   And             True if and only if both _a_ and _b_ are true
*   '^'     a ^ b   Or              True if and only if _a_ or _b_ is true

*## SETL4 Functions
*
*-  add(set,elem)                   Adds element to set
*-  and(a,b)                        And: test if both operands are true
*-  arbitrary(n)                    Returns arbitary (randomly chosen) integer in 1 .. _n_
*-  arbitrary(set)                  Returns arbitary (randomly chosen) element of _set_
*-  assert(expr)                    Tests that _expr_ is true, ends execution otherwise
*-  assert.type(obj,type)           Tests that _obj_ has SPITBOL datatype _type_, ends execution otherwise
*-  at(set,expr)                    Evaluates _expr_ for for current iterate of _set_
*-  begins(str,sub)                 Tests if string _key_ begins with string _sub_
*-  compose(a,b)                    Returns composition of two maps or tables.
*-  defined(map,key)                Tests if a map is defined for a specified key
*-  difference(a,b)                 Returns set of members of set _a_ not in the set _b_
*-  domain(map)                     Returns set of elements in the domain of a map
*-  equal(a,b)                      Tests if two SETL4 objects are equal
*-  exists(set,expr)                Tests if an expression is true for at least one element in a set
*-  from(set,elem)                  Returns set consisting of the members of a set except a specified member
*-  get(map,key)                    Gets the value of map _map_ for _key_ for a map
*-  get(set,i)                      Gets the i-th element in a set, or fails if no such element
*-  false(e)                        tests if argument is false
*-  forall(set,expr)                Tests if an expression is true for every element of a set
*-  filter(set,expr)                Filter:; returns subset of _set_ for which _expr_ is true
*-  int(s)                          Returns integer defined by _s_
*-  integers(n)                     Returns set of integers 1 ... n
*-  intersection(a,b)               Returns set of elements common to two sets
*-  join(a,b)                       Joins two strings into a single string by concatenating them
*-  loop(set)                       Set up iteration over _set_ using _next_
*-  mark(line)                      Annotates, or marks, a line
*-  member(elem,set)                Tests set membership
*-  new(str)                        Returns new set specified by _st_
*-  next(set)                       Returns next element in iteration defined by prevous _loop_, fails if no more elements
*-  not(expr)                       Not: tests if operand is false
*-  or(a,b)                         Or: tests if either operand is true
*-  push(stack,value)               Push value onto a stack
*-  pop(stack)                      Pop the top of a stack
*-  put(map,key,val)                Defines the value of a map key
*-  random(n)                       Returns random element
*-  random.seed()                   Sets random number seed to initialize _random_
*-  range(map)                      Returns set of elements in the range of a map
*-  rank(set)                       Returns the rank, or normal form, of a set or string.
*-  remove(set,elem)                Remove arbitary element from set, or most recent entry from map.
*-  subset(a,b)                     Tests if the second set is a subset of the first set
*-  union(a,b)                      Returns set consisting of all the members in two sets
*-  set.size(set)                   Returns number of elements in set _set_
*-  traceoff()                      Turns off tracing
*-  show(v,nested)                  Show value of _v_, with _nested_ set non-zero when listing member of set
*-  show.b(e)                       Show value of _b_ as boolean
*-  show.line(line)                 Show string _line_ with spaces replaced by '.'
*-  show.lines(lines,title)         Show non-empty lines in array of lines, with title 'title'
*-  show.q(str)                     Show string enclosed in appropriate quote character (" or ') 
*-  traceon()                       Turns on tracing
*-  this(set)                       Returns current iteration value for _set_
*-  true(e)                         Tests if operand is true
*-  visit(set,expr)                 Visits each element of set _set_ and evaluates _expr_ for that element


*   SETL4 Function Definitions
*   --------------------------

    define('add(set,elem)ara,i,n,str')              :(add.end)

*   _Add_ adds an element to a set if it not already a member.
*   If the set has kind _map_ and _elem_ has the data type _entry_
*   the map is updated using the key and value of the entry.

add

    elem = integer(elem) +elem
    differ(set.kind(set),'map')                     :s(add.set)
    differ(datatype(elem),'entry') error("can only add 'entry' elements to a map.")
    put(set,key(elem),value(elem))                  :(return)


add.set
    member(set,elem)                                :s(return)
    set.size(set) = set.size(set) + 1
    set.index(set)[set.size(set)] = elem
    set.key(set)[elem] = elem                       :(return)
    
add.end

    define('and(a,b)')                              :(and.end)

*   _And_ tests if both operand are true (not null), only 
*   evaluating the second argument when necessary.

and

*   See if both operands are integers.

    and = integer(a) eq(a)                          :s(freturn)
    and = integer(a) integer(b) ne(a * b)           :s(return)f(freturn)

*   Here where at least one operand for 'and' is not integer, so
*   use ident/differ to evaluate.

    and = differ(a) differ(b)                       :s(return)f(freturn)

and.end

    define('arbitrary(set)iter,n,r')                :(arbitrary.end)

*   _Arbtrary_ returns an arbitrary (randomly selected) element of a set, or
*   if the argument is an integer, then _arbitrary_ returns a random
*   integer in the range 1 .. _set_.

arbitrary

    arbitrary = integer(set) random(+set)           :s(return)
    r = random(set.size(set))
    ident(set.kind(set),'iter')                     :s(arbitrary.iter)
    arbitrary = set.index(set)[r]                   :(return)

arbitrary.iter

    iter = set.iter(set)
    arbitrary = iter.starbitraryitrary(iter) + (r - 1) * iter.step(iter) :(return)

arbitrary.end

    define('assert(expr)')                          :(assert.end)

*   _Assert_ tests that its argument expression is non null, ending execution otherwise.

assert

    true(expr)                                      :s(return)
    error('assertion failed, quitting') 

assert.end

    define('assert.type(obj,typ)')                  :(assert.type.end)

*   _Assert.type_ tests that _obj_ has datatype _typ_, and ends execution if not.

assert.type

    assert(ident(datatype(obj),typ))                :s(return)
    error('assertion on datatype failed ' typ )
    

assert.type.end

    define('at(set,expr)this')                      :(at.end)

*   _At_ evaluates _expr_ for the current element in an iteration over _set_.

at

    this = iter.next(set)
    at = eval(expr)                                 :(return)

at.end

    define('compose(a,b)ara,i,key,n')               :(compose.end)

*   _Compose_ returns the composition of two maps or tables.

compose

    ident(datatype(a),'table')                      :s(compose.table)

*   Here to compose two maps.

    compose = set('map',iterator(),table(set.size(a)),table(set.size(a)))

compose.map.next

    le(i = i + 1,set.size(a))                       :f(return)
    compose[i] = set.key(set)[set.index(set)[i]]    :(compose.map.next)

compose.table

    ara = convert(a,'array')                        :f(show.table.error)
    prototype(ara) break(',') . n
    compose = table(n)

compose.table.next

    key = ara[i = i + 1,2]                          :f(return)
    compose[i] = b[key]                             :(compose.table.next)

compose.end

    define('defined(map,key)entry')                 :(defined.end)

*   _Defined_ tests if the map _map_ has an entry for _key_.

defined
    key = integer(key) +key
    defined = set.key(map)[key]                     
    differ(defined)                                  :s(return)f(freturn)

defined.end

    define('difference(a,b)this')                   :(difference.end)

*   _Difference_ returns the set defined by the set of elements of _a_ that are not in _b_.

difference

    difference = new()
    loop(a)

diference.next

    this = next(a)                                  :f(return)
    member(b,this)                                  :s(difference.next)
    add(difference,this)                            :(difference.next)

difference.end

    define('equal(a,b)entry,i,key,value')                        :(equal.end)

*   _Equals_ tests if two objects are equal. Use DIFFER unless both are sets, in
*   which case use equality tests specified below.

equal
  
    ident(datatype(a),'set') ident(datatype(b),'set'):s(equal.sets)
    ident(a,b)                                      :s(return)f(freturn)

equal.setl4

*   Here for equality test of two SETL4 objects.

    ident(set.kind(a),set.kind(b))                  :f(freturn)
    eq(set.size(a),set.size(b))                     :f(freturn)
            :($('equal.' set.kind(a)))

equal.int

    eq(iter.start(a),iter.start(b))                       :f(freturn)
    eq(iter.finis(a),iter.finis(b))                     :f(freturn)
    eq(iter.step(a),iter.step(b))                     :f(freturn)s(return)

equal.map

*   Two maps are equal if they have the same vaue at every element in the domain.

    gt(i = i + 1, set.size(a))                      :s(equal.true)
    entry = set.index(a)[i]
    ident(value(entry),get(b,key(entry)))           :f(freturn)s(equal.map)

equal.seq

*   Two sequences are equal if they have the same vaue at every element in the domain.

    gt(i = i + 1, set.size(a))                      :s(equal.true)
    ident(set.seq(a)[i], set.seq(b)[i])             :s(equal.seq)f(freturn)

equal.sets
   
   
    lt(set.size(a),set.size(b))                     :s(freturn)
    ident(set.kind(a),set.kind(b))                  :f(freturn)
    ident(set.kind(set),'int')                      :s(equal.int)
    ident(set.kind(set),'iter')                     :s(equal.iter)
    ident(set.kind(set),'map')                      :s(equal.map)
    ident(set.kind(set),'set')                      :s(equal.set)
    error('equal mismatched kinds')             


equal.set

*   Two sets are equal if and only if each is a subset of the other.
    subset(a,b)                                     :f(freturn)
    subset(b,a)                                     :f(freturn)
                                                    :(return)
    equal = and(subset(a,b),subset(b,a))            :f(freturn)s(return)

equal.end

    define('from(set,elem)this')                    :(from.end)

*   _From_ removes an (existing) element from a set.

from

    from = new()
    loop(set)

from.next

    this = next(set)                                :f(return)
    differ(this,elem) add(from,this)                :(from.next)

from.end

    define('domain(map)elem)')                      :(domain.end)

*   _Domain_ returns the domain of map, which is the set of the keys in _map_.

domain

    domain = new()
    loop(map)

domain.next

    entry = next(map)                               :f(return)
    differ(entry) add(domain,key(entry))            :(domain.next)

domain.end

    define('error(str)')                            :(error.end)

*   _Error_ writes out its argument string and ends execution.

error

    &dump = 2
    &dump = 3

*   Clear variables that need not appear in &dump output

    setl4.clear()
    out('Fatal error: ' str)                        :(end)

error.end

    define('exists(set,expr)this,e')                :(exists.end)

*   _Exists_ tests if there is an element in _set such that _expr_ is true.

exists

    loop(set)

exists.loop

    this = next(set)                                :f(freturn)
    exists = eval(expr)                             :f(exists.loop)s(return)

exists.done

    output = 'exists loop ended, failing' :(freturn)

exists.end

    define('false(e)')                              :(false.end)

*   _False_ tests if its argument is false (null).

false

    e = integer(e) +e
    false = integer(e)  eq(e)                       :s(freturn)
    false = ident(e)                                :s(return)f(freturn)

false.end

    define('filter(set,expr)e,this')                :(filter.end)

*   According to Paul Halmos, in his book "Naive Set Theory,"
*   a major principle of set theory, often referred to by its
*   German name _Aussonderungsaxiom_, is the Axiom of Specification:

*   To every set _A_ and every condition _S(x)_ there corresponds
*   a set _B_ whose elements are exactly those elements _x_ of _A_
*   for which _S(x)_ holds.

*   In SETL4 we say that the expression '_A_ @ _S_' "filters"
*   _A_ by _S_. This can also be read as
*           "the subset of _A_ such that _S_ is true"

*   Returns the subset of set or map _set_ for which _expr_ is true.

filter

    filter = new('set')

    loop(set)

filter.loop

    this = next(set)                                :f(return)
    eval(expr) add(filter,this)                     :(filter.loop)

filter.end

    define('forall(set,expr)e')                     :(forall.end)

*   _Forall_ tests if _expr_ is true for all elements of _set_.

forall

    loop(set)

forall.loop

    next(set)                                       :f(return)
    e = eval(expr)                                  :f(freturn)s(forall.loop)

forall.end


    define('get(map,key)val,entry')                 :(get.end)

*   _Get_ gets the value of the key _key_ in the map _map_, or gets
*   element _key_ in a set, failing if no such element.

get

    key = integer(key) +key
    ident(set.kind(map),'int')                      :s(get.int)
    ident(set.kind(map),'map')                      :s(get.map)
    ident(set.kind(map),'set')                      :s(get.set)
    error('get on unsupported kind of set: ' set.kind(map))

get.int

    error("get on set of kind 'int' not yet supported.")

get.map

    get = set.key(map)[key]
    differ(get)                                     :s(return)f(freturn)

get.set

*   out('dt set',datatype(map))
*   out('set.kind',set.kind(map))
    ident(set.kind(map),'iter')                     :s(get.int)
    get = set.index(map)[key]
    ident(get)                                      :s(freturn)f(freturn)
    get = set.key(map)[entry]                       :(return)

get.end

    define('int(n)')                                :(int.end)

*   _Int_ Returns _n_ if _n_ is an integer, or returns _n_ converted to an
*   integer if _n_ is real, or returns the value of a string written in exponential 
*   (scientific) notation converted to its integer value.

int

    int = integer(n) n                              :s(return)
    int = ident(datatype(n),'real') convert(n,'integer') :s(return)
    int = n
    n break('e')                                    :f(return)
    n break('e') . int 'e' =
    int = int * +('1' dupl('0',n))                  
    int = +int
                                                    :(return)

int.end

    define('integers(n)')                           :(integers.end)

*   _Integers_ returns the set containing the integers 1 .. _n_

integers

    integers = set('set',iterator(),table(n),table(n))

integers.next

    le(i = i + 1,n) add(integers,i)                 :s(integers.next)f(return)

integers.end

    define('intersection(a,b)this')                 :(intersection.end)

*   _Intersection_ returns the intersection of its argument sets.

intersection

*   Make _a_ the smaller 

    le(set.size(a),set.size(b))                     :s(intersection.next)
    a = b
    b = intersection
    intersection = new()
    loop(a)

intersection.next

    this = next(a)                                  :f(return)
    member(b,this) add(intersection,this)           :(intersection.next)

intersection.end

    define('join(a,b,c)i')                             :(join.end)

*   _Join_ joins strings by concatenating them, and sequences
*   by returning a new sequence consisting of all the elements of
*   the first followed by all the elements of the second.

*   If called with three arguments, the result returned is the same as join(join(a,b),c)`

join

    ident(a)                                        :s(return)
    ident(datatype(a),'string')                     :s(join.string)
*   out('joining maps')
    join = copy(a)
    ident(b)                                        :s(return)

*   Here to join first and second argument sequences.

join.map.b.next

    le(i = i + 1,set.size(b))                       :f(join.map.c)
    put(join,set.size(a) + i,get(b,i))              :(join.map.b.next)

join.map.c

    ident(c)                                        :s(return)
    i = 0

join.map.c.next

    le(i = i + 1,set.size(c))                       :f(return)
    put(join,set.size(a) + i,get(c,i))              :(join.map.c.next)

join.string

*   Here to join strings.

    out('join a',a)
    out('join b',b)
    out('join c',c)
    join = a (differ(b) b, '') (differ(c) c,'')     :(return)

join.end

    define('loop(set)iter')                         :(loop.end)
*   _Loop_ creates or updates the iterator of _set_ so that,
*   on first call to _next()_,  _iter.next_  will be 
*   advanced to select the first element in the iteration.

loop

    ident(set.kind(set),'iter')                     :s(loop.iter)
    ident(set.kind(set),'int')                      :s(loop.int)
    ident(set.kind(set),'map')                      :s(loop.map)
    ident(set.kind(set),'set')                      :s(loop.set)
    error('unknown kind of iterator: ' set.kind(set))

loop.int

    set.iter(set) = iterator()
    iter.next(set) = set.block(iter) = set.offset(iter) = 0 :(return)

loop.iter

*   When iterating over a set of kind 'iter', use the iterator
*   created when the set was created.

    iter = set.iter(set)
    differ(set.kind(set),'iter') error("loop.iter requires kind 'iter'")
    iter.next(iter) = gt(iter.step(iter)) iter.start(iter) - iter.step(iter)
    iter.next(iter) = lt(iter.step(iter)) iter.start(iter) - iter.step(iter)
                                                    :(return)

loop.map

    set.iter(set) = iterator()                     :(return)

loop.set

    set.iter(set) = iterator()                     :(return)

loop.end

    define('member(set,elem)kind,entry,i,iter,key,this,value,block)') :(member.end)

*   _Member_ tests if _elem_ is member of _set_.

member

*   Branch according to whether _set_ is set or map.

    eq(set.size(set))                               :s(freturn)
    elem = integer(elem) +elem
    ident(datatype(elem),'entry')                   :s(member.map)
    ident(set.kind(set),'int')                      :s(member.int)
    ident(set.kind(set),'iter')                     :s(member.iter)
    ident(set.kind(set),'set')                      :s(member.set)
    error('member: unexpected kind ' kind )

member.int

*   To test for membership in set of kind _int_ get the block
*   for the element. If it is null then fail since element not
*   in the set. Otherwise see if character corresponding to the
*   value of _elem_ is '+'.

    block = elem / setl4.config.int
    this = +(remdr(elem,setl4.config.int) + 1)
    value = set.key(set)[block]
    ident(value)                                    :s(freturn)
    ident(substr(value,this,1),'+')                 :s(return)f(freturn)

member.iter

    integer(elem)                                   :f(freturn)
    iter = set.iter(set)
    lt(iter.step(iter)) lt(elem,iter.finis(iter))    :s(freturn)
    gt(iter.step(iter)) eq(remdr(elem - iter.start(iter),iter.step(iter))):s(return)
    lt(iter.step(iter)) eq(remdr(iter.start(iter) - elem,iter.step(iter))):s(return)
                                                    :(freturn)

member.set

    differ(set.key(set)[elem])                      :s(return)f(freturn)

member.end

    define('new(init)kind,i,iter,len,n,key,seq,val,words)'):(new.end)

*   _New_ constructs a new set and returns its value.

*   Construct new set with initial values determined by string _init_.
*   The first three characters in _init_ determine the initial
*   members of the set.
*
*       'iter'           Sequence of integers low, low+step, ... high
*       'set'           set, followed by list of initial members
*       'map'           map, followed by list of key/value pairs separated by colon
*       'seq'           sequence, followed by list of initial values.

new

    ident(init)                                     :s(new.set)
    init = init ' '
    init span(' ') =
    init break(' ') . kind span(' ') =
    kind = (gt,size(kind),3) substr(kind,1,3)
    begins('integers',kind)                          :s(new.kind)
    begins('iterator',kind)                          :s(new.kind)
    begins('map',kind)                               :s(new.kind)
    begins('seq',kind)                               :s(new.kind)
    begins('set',kind)                               :s(new.kind)
    begins('string',kind)                            :s(new.kind)
    error('bad kind to new ' kind )

new.kind

    kind = gt(size(kind),3) substr(kind,1,3)
    init span(' ') =
    kind = (gt,size(kind),3) substr(kind,1,3)

*   Branch on kind to finish initialization of new set.

                                                    :($('new.' kind))
new.int
    
    new = set('set',iterator(),table(set.4.config.int.table.size),table(setl4.config.int.table.size))
    set.kind(new) = 'int'
    set.index(new) = table(1000)
    set.key(new) = table(1000)

new.int.next

    init break(' ') . key span(' ') =              :f(return)
    add(new,int(key))                              :(new.int.next)

new.ite
new.iter

    iter = iterator()
    iter.step(iter) = 1
    seq = new('seq ' init)

*   Ignore extra arguments to iterator constructor.

    set.size(seq) = gt(set.size(seq),3) 
    eq(set.size(seq),1)                             :s(new.iter.1)
    eq(set.size(seq),2)                             :s(new.iter.2)
    eq(set.size(seq),3)                             :s(new.iter.3)

new.iter.1

    iter.start(iter) =  1
    iter.finis(iter) = get(seq,1)
    iter.step(iter) = 1                             :(new.iter.step)

new.iter.2

    iter.start(iter) =  get(seq,1)
    iter.finis(iter) = get(seq,2)
    iter.step(iter) = 1                             :(new.iter.step)

new.iter.3

    iter.start(iter) =  get(seq,1)
    iter.finis(iter) = get(seq,2)
    iter.step(iter) = get(seq,3) 

new.iter.step

*   Make sure step negative if first argument to iter is greater than the second.

    lt(iter.step) out('new -step',iter.step(iter))
    iter.step(iter) = gt(iter.start(iter),iter.finis(iter))  gt(iter.step(iter)) - iter.step(iter)
    new = set('iter',iter)
    set.size(new) = ((iter.finis(iter) - iter.start(iter)) / iter.step(iter)) + 1 
                                                    :(return)

new.map
    
    new = set('map',iterator(),table(setl4.config.set.table.size),table(setl4.config.set.table.size))

*   If present, _init_ is a list consisting of a list of key/value pairs,

*   with a colon (:) separating the key and value.

    init = init ' '
    init span(' ') =
    ident(init)                                     :s(return)

new.map.next

    init break(':') . key ':' break(' ') . val span(' ') =  :f(return)
    put(new,key,val)                                :(new.map.next)

new.seq

    new = set('map',iterator(),table(setl4.config.set.table.size),table(setl4.config.set.table.size))
    init span(' ') =
    ident(init)                                     :s(return)
    init = init ' '

new.seq.next

    out('seq init',init)
    init span(' ') =
    init break(' ') . val ' ' =                     :f(return)
    out('adding key ',i + 1)
    out('new.seq.next dt',datatype(val))
    out('adding val',val)
    put(new,i = i + 1,val)                          
    show(new)
                                                    :(new.seq.next)

new.set

    new = set('set',iterator(),table(setl4.config.set.table.size),table(setl4.config.set.table.size))
    set.kind(new) = 'set'
    ident(init)                                     :s(return)

new.iter.next

    init break(' ') . key span(' ') =               :f(return)
    add(new,key)                                    :(new.iter.next)

new.set.done

    iter.next(new) =                                 :(return)

new.end

    define('new.stack()')                           :(new.stack.end)

*   _New.stack_ returns a new stack.

new.stack

*   Don't allocate stack table when creating stack. Do that
*   when first add value to stack.

    new.stack = stack(,0)                           :(return)

new.stack.end

    define('next(set)i,iter,key,next,str,value')    :(next.end)

*   _Next_ Advances an  iteration by setting field _next_ to the next item
*   to be visisted, or fails if no more elements remain.

next

    iter = set.iter(set)
*   Branch on kind to find next iteration value.

        :($('next.' set.kind(set)))

next.int

*   Iteration over a set    of kind 'int' makes use of the following fields:
*
*       set.block      is current block for iteration
*       set.offset     is zero if this block not search, or else index of an
                           element of the set in this block
*       set.str        is set to the string of a block when advance to it.

*   Branch to get first block if _set.str_ is null.

    ident(set.str(set))                             :s(next.int.block)

next.int.test

*   See if any members remain in this block, branching to _next.int.block_ if none.

next.int.block

*   Here to advance to next block, ending iteration if no more remain.

    set.block(set) = set.block(set) + 1
    gt(set.block(set),set.blocks(set))              :s(freturn)
    set.str(set) = set.key(set)[set.index(set)[set.block(set)]]
    str = set.str(set)
    str break('+') . key                            :f(next.int.block)

*   Here when member found. Clear the membership character and return.

    set.str(set) = set.key(set)[block]
    set.str(set) = ne(set.offset(set)) 
.           substr(set.str(set),1,set.offset(set) - 1,'-','+')
.          '+' 
.          substr(str,set.offset(set) + 1)
    set.str(set) = str
    next = (set.block(set) * setl4.config.int) + size(key)
    this = set.this(set) =  next                    :(return)

next.iter

*   Here to find next element in iterator.

    next = iter.next(iter) = iter.next(iter) + iter.step(iter)
    gt(iter.step(iter)) gt(next,iter.finis(iter))   :s(freturn)
    lt(iter.step(iter)) lt(next,iter.finis(iter))   :s(freturn)
    this = set.this(set) = next                     :(return)

next.map

    next = iter.next(iter) = +iter.next(iter) + 1
    le(next,set.size(set))                          :f(freturn)
    out('next.map 1',next)
    next = set.index(set)[next]
    out('next.map 2',next)
    this = set.this(set) = next
                                                    :(return)

next.set
    
    next = iter.next(iter) = +iter.next(iter) + 1
    le(next,set.size(set))                          :f(freturn)
    next = set.index(set)[next]
    this = set.this(set) = next                     
                                                    :(return)

next.end

    define('not(expr)')                             :(not.end)

*   _Not_ returns the negation of a boolean expression.

not

    not = integer(expr) (eq(expr) 1, '')            :s(return)f(freturn)
    not = ident(expr) 1                             :s(return)f(freturn)

not.end

    define('or(a,b)')                               :(or.end)

*   _Or_ tests if either operand is true, fails otherwise, only evaluating
*   its second argument if necessary

or
    or = integer(a) ne(a)                           :s(return)
    or = integer(b) ne(b)                           :s(return)

*   Here if operands not both integers, so use ident/differ.

    or = differ(a)                                  :s(return)
    or = differ(b)                                  :s(return)f(freturn)

or.end

    define('out(text1,text2,text3)type1,type2')     :(out.end)

*   _Out_ writes a line to standard output  conisting of _text1_, 
*   then _text2_ enclosed in brackets if _text2_ is not null, followed
*   by _text3_ if _text3_ is not null.

out
*   output = text1 text2 text3
    out = ident(datatype(text1),'string') text1
    text2 = integer(text2) +text2
    output = 'dt text2 ' datatype(text2)
    out = differ(text2) out '[' text2 ']'
    out = differ(text3) out text3
    output = out                                    :(return)

out.end

    define('pop(stack)')                            :(pop.end)

*   _Pop_ removes (pops)  the top item from stack, or fails if the stack is empty.

pop

    eq(set.size(stack))                             :s(freturn)
    pop = set.key(stack)[set.index(stack)[set.size(stack)]]
    set.size(stack) = set.size(stack) - 1           :(return)

pop.end

    define('push(stack,value)')                     :(push.end)

*   _Push_ adds a new value to a stack (implemented as a sequence).

push

    put(stack,set.size(stack) + 1, value)           :f(freturn)s(return)

push.end

    define('put(map,key,value)v')                   :(put.end)

*   _Put_ sets the value of the entry for key _key_ in map _map_ to be _val_,

put

    key = integer(key) +key
    value = integer(value) +value
    out('Put key',key)
*   out('Put key',key)
    out('Put dt value',datatype(value))
    v = set.key(map)[key]
    differ(v)                                       :s(put.value)

*   Here to create new entry in map, and then merge to set new value.

    set.size(map) = set.size(map) + 1
    set.index(map)[set.size(map)] = key

put.value

    out('put value',value)
    set.key(map)[key] = value                       
*   out('Show put',set.key(map)[key])
*   show(map)
                                                    :(return)

put.end

    define('range(map)elem)')                       :(range.end)

*   _Range_ returns the range of map, which is the set of the values in _map_.

range

    range = new()
    loop(map)

range.next

    entry = next(map)                               :f(return)
    add(range,value(key(entry)))                    :(range.next)

range.end

	define('random(n)')				:(random.end)

*	Return integer uniformly distributed in 1,2,...,n. 
*	If n=0 returns real uniformly distributed in the interval [0,1].
*	The Algorithm is based on that in section 16.1 of "Algorithms in SNOBOL4,"
*	James F. Gimpel, John Wiley and Sons, 1976.

random

    ident(setl4.random.initialized) random.seed()
	setl4.random.value = remdr(setl4.random.value * 4676, 414971)
	random  = setl4.random.value / 414971.0
	random = ne(n) convert(random * n,'integer') + 1
							:(return)
random.end

	define('random.seed()s,c')			:(random.seed.end)

*	Compute seed for random number generator from date and time.

random.seed
    differ(setl4.random.initialized)                    :s(return)
    setl4.random.initialized = 'TRUE'
	setl4.random.value = 
	s = date()
	s = replace(s,'/:-','123')

*	Get all the digits in s.

random.seed.loop

	s len(1) . c =					:f(random.seed.done)
	ident(c,' ')					:s(random.seed.loop)
	setl4.random.value = setl4.random.value c			:(random.seed.loop)

random.seed.done

*	Reverse the seed so digits depending on time come first.

	setl4.random.value = +reverse(setl4.random.value)	
							:(return)
random.seed.end

    define('rank(set,type)ara,entry,key,map,seq,str,tbl,value')    :(rank.end)

*   _Rank_ reorders the index table of a set to reflect a desired sort of elements
*   of set, keys of maps, or values of map.

*   _Rank_ can also be used to put a string in normal form by converting the string
*   into a sequence of the characters in the string and then sorting the range
*   of the sequence.

*   The argument _type_ specifies the ordering to be used:

*       '+key'      increasing order of the values in the domain

*       '-key'      decreasing order of the values in the domain

*       '+value'    increasing order of the values in the range

*       '-value'    decreasing order of the values in the range

*       '' (null)   order in which entries were created

*   Types for keys and values may be abbreviated: "+key" may be written
*   as "+k" or "+ke", "+value" as "+v" or +"val", and so forth.

rank
    str = ident(datatype(set),'string') set
    type = get(setl4.rank.types,type) 

*   If the first argument is a string, build a sequence
*   of the characters in the string, and rank the sequence.

    ident(datatype(set),'set') ident(set.kind(set),'int')  :s(return)
    ident(datatype(set),'set') ident(set.kind(set),'iter') :s(return)
    differ(str)                                            :s(rank.string)

rank.merge

*   If  _set_ is a string, will merge here when we have 
*   converted the string to a sequence.

    rank = set
    differ(datatype(set),'set') error('wrong type for rank')
    setl4.sort(set,set.size(set),type)                                    
                                                    :(return)

rank.table

    tbl[ara[i = i + 1,1]] = ara[i,2]                :s(rank.table)f(return)

rank.string

*   Rank a string by using split() to build a sequence of
*   the characters in the string, then go to the label 
*   _rank.merge_ to finish by ranking the map.

    set = split(str)                                
    type = '+v'                                     :(rank.merge)

rank.end

    define('remove(set,elem)i,iter,this')             :(remove.end)

*   _Remove_ removes the element _elem_  from the set _set_. _Remove_
*   does nothing if _elem_ is not a member of the set.

*   If _elem_ is new, remove the most recently added element of a set or map.
*   If _set_ is a set, then remove _elem_ from _set_ if it is a member.
*   If _set_ is a map, remove the entry with key _value_.
*   Return the element removed.

remove

    eq(set.size(set))                               :s(freturn)
    ident(elem)                                     :s(remove.last)
    remove = elem
    ident(set.kind(set),'int')                      :s(remove.int)
    ident(set.kind(set),'map')                      :s(remove.map)
    ident(set.kind(set),'set')                      :s(remove.set)
    error('remove not defined for set of kind ' set.kind(set))

remove.int

    error("remove from set of kind 'int' not yet implemented.")

remove.last

    remove = set.index(set)[set.size(set)]
    set.size(set) = set.size(set) - 1               :(return)
 
remove.map
remove.set

    ident(set.key(set)[elem])                      :s(return)

*   Find the entry with key _elem_, assuming it's more likely
*   to be a newer addition than one of the older elements.

    iter = new('iter ' set.size(set) ' 1')
    i = set.size(set) + 1

remove.find

    gt(i = i - 1)                                   :f(remove.error)
    ident(set.index(set)[i],elem)                   :f(remove.find)

*   Delete _elem_ from the key table, then move the entries
*   in the index table following this one down one position.
*   Nothing remains to be done if the set had only one element, or
*   if the element was the last in the index table.

    set.key(set)[elem] =
    set.size(set) = set.size(set) - 1
    eq(set.size(set))                               :s(return)

remove.next

    eq(i,set.size(set))                             :s(return)
    set.index(set)[i] = set.index(set)[i + 1]
    i = i + 1                                       :(remove.next)

remove.error

    error('remove.set unable to locate member')

remove.end

    define('show(v,label,nested)ara,i,kind,elem,ent,line,hdr,map,n,set.this') :(show.end)

*   _Show_ displays the value of its first argument in a form that is hopefully both
*   readable and pleasing to the eye.

*   _lev_ is non-zero when called to list element of a compound object.

show

    ident(v)                                        :s(return)
    differ(label) out('show: ' upper(label))
    differ(datatype(v),'set')                       :s($('show.' datatype(v)))

*   Make a copy of the argument to avoid disrupting a possible 
*   existing iteration over the argument.
    
    v = copy(v)
    
    kind = set.kind(v)
    ident(kind,'int')                               :s(show.int)
    ident(kind,'iter')                              :s(show.iter)
    ident(kind,'map')                               :s(show.map)
    ident(kind,'set')                               :s(show.set)
    error('show unknown set kind',kind,' quitting.')

show.array

    proto = prototype(ara)
    proto break(',')                                :s(show.array.2)

*   Here for one dimensional array.

show.array.1
    first = ara[add1(.i)]                           :f(show.array.done)
    out(lpad(i,3) tab first)                        :(show.array.1)

show.array.2
    first = ara[add1(.i),1]                         :f(show.array.done)
    out(lpad(i,3) tab show(first) tab show(ara[i,2])) :(show.array.2)

show.entry

    show = show ' ' show(key(v),,1)  ':' show(value(v),,1) :(show.done)

show.iter

    show = 'iter{ '
    loop(v) 

show.iter.next

    elem = next(v)                                  :f(show.iter.done)
    show = show ' ' show(elem,,1)
    lt(size(show),80)                               :s(show.iter.next)
    out(show)
    show =                                          :(show.iter.next)

show.iter.done

    show = show ' }'                                :(show.done)

show.iterator

    show = '{iterator'
.           (ne(iter.start(v))  ' start:'   iter.start(v) ,'')
.           (ne(iter.finis(v))  ' finis:'   iter.finis(v),'')
.           (ne(iter.step(v))   ' step:'    iter.step(v),'')  '} ' :(show.done)

show.integer

    show = v                                        :(show.done)

show.map

    show = 'map{'
    rank(v,'+k')
    setl4.save(v)
    loop(v)


show.map.next

    elem = next(v)                                  :f(show.map.done)
*   show = show ' ' show(elem,,1) ':' show(set.key(v)[elem],,1)
    show = show ' ' show(elem) 
    lt(size(show),80)                               :s(show.map.next)
    out(show)
    show =                                          :(show.map.next)

show.map.done

    setl4.restore(v)
    show = show ' }'                                :(show.done)

show.pair

    show = show ' ' show(first(v),,1)  ':' show(second(v,,1)) ' ' :(show.done)

show.int

    show = '{ int'
    rank(v,'+k')
    setl4.save(v)
    loop(v)

show.int.next

    elem = next(v)                                  :f(show.int.done)
    show = show ' ' show(elem,,1)
    lt(size(show),80)                               :s(show.int.next)
    out(show)
    show =                                          :(show.int.next)

show.int.done

    setl4.restore(v)
    show = show ' }'                                :(show.done)

show.set

    show = 'set{'
    rank(v,'+k')
    setl4.save(v)
    loop(v)

show.set.next

    elem = next(v)                                :f(show.set.done)
    show = show ' ' show(elem,,1)
    lt(size(show),80)                             :s(show.set.next)
    out(show)
    show =                                        :(show.set.next)

show.set.done

    setl4.restore(v)
    show = show ' }'                                :(show.done)

show.string

*   Don't quote string that is an integer.

    show = integer(v) v                             :s(show.done)

    show = show.q(v)                                :(show.done)

show.table

    show = 'table ['
    ara = convert(v,'array')                        :f(show.table.error)
    i = 0
    prototype(ara) break(',') . n                   :(show.table.next)

show.table.error

    error('error converting table to array')

show.table.next

    le(i = i + 1,n)                                 :f(show.table.done)
    show = show ' ' show(ara[i,1],,1) ':' show(ara[i,2],,1)    
    lt(size(show),80)                              :s(show.table.next)
    out(show)
    show =                                          :(show.table.next)

show.table.done

    show = show ' ]'                                :(show.done)
 
show.string.quote

    show = '"'  v '"'                               :(show.done)

show.done

*   Write out result unless listing elements of compound object.

    eq(nested) out(show)                            :(return)

show.end

    define('show.b(e)')                             :(show.b.end)

*   _Show.b_ shows the value if its argument as a boolean value: TRUE or FALSE

show.b

    integer(e) out((ne(e) 'TRUE', 'FALSE'))         :s(return)
    out((differ(e) 'TRUE', 'FALSE'))                :(return)

show.b.end

    define('show.eval(expr)e')                      :(show.eval.end)

*   _Show.eval_ evaluates its argument and returns 'success' if
*   the evaluation succeeded, or 'failure' if not.

show.eval

    eval(expr)                                      :s(show.eval.success)
    show.eval = 'failure'                           :(show.eval.finis)

show.eval.success
   
    show.eval = 'success'

show.eval.finis

    out('eval ' expr ' ' show.eval)                 :(return)

show.eval.end

    define('show.line(line)')                       :(show.line.end)

*   _Show.line_  shows a line with spaces replaced by '.'

show.line

    show.line = replace(line,' ','.')               :(return)

show.line.end

    define('show.lines(lines,title)i,line,titled')  :(show.lines.end)

*   _Show.lines_ shows the lines in _lines_ that are not empty.

show.lines

    title  = 'lines' (differ(title) ' ' title, '')
    out(title)

show.lines.n

    line = lines[add1(.i)]                          :f(return)
    empty(line)                                     :s(show.lines.n)
    differ(titled)                                  :s(show.lines.titled)

*   Do not list header unless at least one non-empty line

    out('    123456789012345')
    titled = 1

show.lines.titled

    out(lpad(lineid(i),2) ' ' replace(line,' ','.')) :(show.lines.n)

show.lines.end

    define('show.q(str)')                           :(show.q.end)

*   _Show.q_ shows its argument string _str_ enclosed in quotes

show.q

    str break("'")                                  :s(show.q.double)

*   Here if string does not contain a single quote, so use single quotes around it.

    show.q = "'" str "'"                            :(return)

show.q.double

*   Here if string contains single quote, so use double quotes around it.

    show.q = '"' str '"'                            :(return)

show.q.end

    define('subset(a,b)elem')                       :(subset.end)

*   _Subset_ tests if its second argument is a subset of the first.

subset

    gt(set.size(b),set.size(a))                     :s(freturn)
    loop(b)

subset.next

    elem = next(b)                                  :f(return)
    member(a,elem)                                  :s(subset.next)f(freturn)

subset.end

    define('this(set)')                             :(this.end)

*   _This_ returns the value determined in the most recent call to next.

this

    this = set.this(set)                            :(return)

this.end

    define('true(e)')                               :(true.end)

*   _True_ Tests if its operand is true

true

    e = integer(e) +e
    integer(e) ne(e)                                :s(return)
    differ(e)                                       :s(return)f(freturn)

true.end

    define('union(a,b)elem')                        :(union.end)

*   _Union_ returns the union of sets _a_ and _b_.

union

*   Arrange so set a is the larger 

    ge(set.size(a),set.size(b))                     :s(union.a)
    union = a
    a = b
    b = union

union.a

*   Make copy of a by making copy of a's table.

    union = copy(a)
    loop(b)

union.b

    elem = next(b)                                  :f(return)
    add(union,elem)                                 :(union.b)

union.end

    define('visit(set,expr)this')                   :(visit.end)

*   _Visit_ loops over _set and calls _eval_ with argument
*   _expr_  for each of member of the set.

visit

    loop(set)

visit.next

    this = next(set)                                :f(return)
    eval(expr)                                      :(visit.next)

visit.end

*   The following functions with names beginning with 'setl4' are
*   for internal use only. There is no reason for a user to invoke
*   them save for debugging. Otherwise use them ar your peril

    define('setl4.clear()')                         :(setl4.clear.end)

*   _Setl4.clear) clearis the values of setl4 global variables. This reduces amount of &dump output.

setl4.clear

    setl4.config.set.table.size = setl4.config.stack = setl4.config.set.table.size = setl4.config.int =
.   setl4.stack = setl4.ascii.initialized = setl4.ascii.name = setl4.config.int.init =
.   setl4.ascii.value = setl4.random.initialized = setl4.any.digit = setl4.span.digits = 
.   setl4.break.digit = setl4.break.letter = setl4.any.letter =
.   setl4.span.letters = setl4.span.spaces = setl4.break.space =
.   setl4.any.word = setl4.span.word = setl.rank.map = setl4.rank.types = 
                                                    :(return)
setl4.clear.end

    define('setl4.restore(s)')                      :(setl4.restore.end)

*   _Setl4.restore_ restores the values saved by the most recent call to _setl4.push_.

setl4.restore

    set.this(s) = pop(setl4.stack)
    set.index(s) = pop(setl4.stack)                
                :(return)

setl4.restore.end

    define('setl4.save(s)')                         :(setl4.save.end)

*   _Setl4.save_ saves the _index and _this_ fields of its argument set.

setl4.save

    push(setl4.stack,set.index(s))
    push(setl4.stack,set.this(s))                   
                                                    :(return)

setl4.save.end

    define('setl4.show(set,label)iter')             :(setl4.show.end)

*   Setl4.show_ shows  the fields of an instance of _set_ or _iterator_.

setl4.show

    differ(label)          out(' setl4.show: '         str.upper(label))
    ident(datatype(set),'iterator')                 :s(setl4.show.iter)
    ident(datatype(set),'set')                      :s(setl4.show.set)
    error('setl4.show unsupported kind: ' set.kind(set))

setl4.show.iter

    setl4.show =  out('(iterator  start:'   +iter.start(set) 
.                             ' finis:'     +iter.finis(set)
.                             ' step:'      +iter.step(set) 
.                             ' next:'      +iter.next(set) ')')
                                                    :(return)

setl4.show.set

    iter = set.iter(set)
                           out('{')
                           out('  kind',     show.q(set.kind(set)))
    differ(set.index(set)) out('  has index table')
    differ(set.key(set))   out('  has key table')
    ne(set.size(set))      out('  size',     set.size(set))
    differ(set.this(set))  out('  this',     set.this(set))
    ne(iter.start(iter))   out('  start',    iter.start(iter))
    ne(iter.finis(iter))   out('  finis',    iter.finis(iter))
    ne(iter.step(iter))    out('  step',     iter.step(iter))
    differ(set.iter(set))  out('  ',         setl4.show(set.iter(set)))
                           out('}')
    differ(set.index(set)) differ(datatype(set.index(set)),'table') 
.           error(' set.index is not table')
    differ(set.key(set)) differ(datatype(set.key(set)),'table') 
.           error('set.key is not table')
                                                    :(return)
setl4.show.end

    define('setl4.set.size(set)')                   :(setl4.size.end)

*   Setl4.set.size_ returns the  size of operand.

setl4.size

    setl4.size = ident(datatype(set),'string') size(set)    :s(return)
    setl4.size = differ(iter.step(set)) (iter.finis(set) - iter.start(set) / iter.step(set)) + 1 :s(return)
    setl4.size = set.size(set)                      :(return)

setl4.size.end

    define('setl4.sort(set,n,type)i,key,sort,itbl')  :(setl4.sort.end)

*   _Setl4.sort_ sorts the index table of _set_ according to _type_ as 
*   described below. _setl4.sort_ doesn't create a new set;
*   it just updates the index table so that going forward
*   entries will be visited in the order defined by _type_.

setl4.sort

*   Nothing to do if set is empty or only has one element.

    le(n = set.size(set),1)                         :s(return)
    differ(datatype(set),'set') error('setl4.sort bad datatype ' datatype(set))
    setl4.sort = table(n)
    ident(type)                                     :s(setl4.sort.null)
    ident(type,'+k')                                :s(setl4.sort.key)
    ident(type,'-k')                                :s(setl4.sort.key)
    ident(type,'+v')                                :s(setl4.sort.value)
    ident(type,'-v')                                :s(setl4.sort.value)
    error('setl4.sort unsupported type ' type)

setl4.sort.key

*   If sorting by key, just need to sort the index table.

    setl4.sort = table(n)
    tbl = setl4.sort.table(set.index(set),n,type)

setl4.sort.key.next

    le(i = i + 1,n)                                 :f(setl4.sort.done)
    setl4.sort[i] = set.index(set)[ara[i,1]]        :(setl4.sort.key.next)
    
setl4.sort.value

*   Here to  sort by value: build table mapping index numbers into
*   the values associated with their keys, and sort that.

    tbl = compose(set.index(set),set.key(set))
    type = ident(type,'+v') '+k'
    type = ident(type,'-v') '-k'
    tbl = setl4.sort.table(tbl,n,type)

setl4.sort.value.next

*   The table is in proper order, so replace values with the keys
*   associated with that value.

    le(i = i + 1,n)                                 :f(setl4.sort.done)
    setl4.sort[i] = set.index(set)[tbl[i]]          :(setl4.sort.value.next)
    
setl4.sort.null

*   Here to sort on the order in which entries were created.

*   show(set.index(set),'setl4.sort index')
    tbl = setl4.sort.table(set.index(set),n)        :(setl4.sort.done)

setl4.sort.done

   set.index(set) = tbl                            
                                                        :(return)

setl4.sort.end

    define('setl4.sort.table(table,n,type)i,key,sort,itbl,vtbl') :(setl4.sort.table.end)

*   _Setl4.sort.table_ sorts a table of size _n_ that  maps
*   integers into values according to the value of _type_ , returning 
*   a table reflecting the sort.  The first element in the result
*   is the index (key) in the input table that corresponds to the
*   first value in the sorted order, and so forth.


setl4.sort.table

    le(n,1)                                         :s(return)
    type = substr(type,1,1)
    ara = ident(type)        sort(table,1)          :s(setl4.sort.table.ok)
    ara = ident(type,'+')    sort(table,2)          :s(setl4.sort.table.ok)
    ara = ident(type,'-')    rsort(table,2)         :s(setl4.sort.table.ok)

setl4.sort.table.ok

    setl4.sort.table = table(n)

setl4.sort.table.next
    le(i = i + 1,n)                                  :f(return)
    setl4.sort.table[i] = ara[i,2]                  :(setl4.sort.table.next)

setl4.sort.table.error

    error('error in setl4.sort.table converting table to array')

setl4.sort.table.end

    define('traceoff()')                            :(traceoff.end)

*   _Traceoff_ ends tracing.

traceoff

    &ftrace = &trace =
    out('stop TRACING ')

traceoff.end

    define('traceon()')                             :(traceon.end)

*   _Traceon_ begins tracing.

traceon

    out('start TRACING')
*   &ftrace = &trace = 1500000
    g.scoring = g.tracing = 1
                                                    :(return)
traceon.end

*   SETL4 uses some of the undefined SPITBOL operators for SETL4 functions.

*   Characters available for use by 'opsyn' to associate the character
*   with a function.

*   binary  &  @  #  %  ~
*   unary:  !  %  /  #  =  | /

*   define('setl4.op(ch,proc,n)')                   :(setl4.op.end)
*
**  _Setl4.opsyn_ uses _opsyn_ to define a SETL4 operator.
*
*setl4.op
*
*   opsyn(ch,proc,n)                                :s(return)
*   error('fatal problem with opsyn for ' ch ')
*
*setl4.op.end

    :(opsyn.bypass)
    output = 'at opsyn'
*   SETL4 binary operators

*    opsyn('&','and',        2)
    opsyn('@','at',         2)
    opsyn('#','filter',     2)
    opsyn('~','member',     2)
*   opsyn('^','or',        2)

*   SETL4 unary operators:

    opsyn('=','this',       1)
    opsyn('|','new',        1)
    opsyn('!','not',        1)
    opsyn('#','setl4.size', 1)
    opsyn('/','split',      1)

*   Use of opsyn for 'and' and 'or' deferred since supporting them requires
*   mucking about with bol4.

opsyn.bypass

*   Utility Functions
*   ---------------

*   In addition to set-theoretic functions SETL4 provides 
*   the following utility functions.

*   append(str,w,ch)            Appends _ch_ (or space if _ch_ is null) to _str_, then _w_
*   ascii(line)                 Returns the text of line with every ascii character identified
*   checkout(filename)          Returns ('checks out') set or map defined by a file in the libary
*   datename(date)              Returns string based on current time suitable for use as filename
*   digits()                    Returns list of digits: '0 1 2 .. 9'
*   even(n)                     Tests if _n_ is even
*   factorial(n)                Returns n!  = n * (n -1) * ... * 1
*   letters()                   Returns list of letters : 'a b c ... z A B ... Z''
*   less(str,sub)               Removes the first instance of each character in _sub_ from _str_,
*   lletters()                  Returns list of lower case letters : 'a b c ... z'
*   lower(s)                    Returns _s_ with upper case letters replaced by lower case equivalent
*   multiple(n,m)               Tests if _n_ is a multiple of _m_
*   number(n)                   Returns _n_ as one or two words if possible, else returns _n_
*   odd(n)                      Tests if _n_ is odd
*   out(text1,text2,text3)      Outputs _text1_, then _text2_ enclosed in '[]' if _text2_ not null,
*   prefix(str,pre)             Takes a list of space-separated words in _str_, prefixes each with _pre_
*   prime(n)                    Tests if _n_ is prime
*   primes(n)                   Returns set of primes less than _n_
*   reader(filename,expr)       Returns sequence of lines in file _filename_, using _expr_ (if given)
*   slice(str,first,last)       Same as SPITBOL _substr(str,first,last)_
*   reader(str,delim)           Like _reader(filename..)_ but reads lines from a string with lines
*   square.root(n)              Returns integer square root on _n_
*   thousands(s)                Returns _s_ with a comma every three spaces from the right.
*                               to filter out lines to be ignored.
*                                   separated by delimiter _delim_
*   tokens(line)                Returns sequence of the tokens in _line_
*   uletters()                  Returns list of upper case letters : 'A B C ... Z''
*   upper(s)                    Returns _s_ with lower case letters replaced by upper case equivalent
*   writer(lines)               Writes sequence _lines_ to standard output.

    define('append(str,w,ch)')                  :(append.end)

*   _Appends appends _ch_, or ' ' if _ch_ is null, to _str_ and then appends _w_.

append

    append = str (ident(str) w, (ident(ch) ' ' , ch) w):(return)

append.end

    define('ascii(line)c,n,name,nul,num,pos')   :(ascii.end)

*   _Ascii_ returns the text of its argument string with every ascii character identified.

ascii

    differ(ascii.initialized)                   :s(ascii.initialized)

*   Here to initialize the needed maps.
    
    ascii.init()
    ascii.initialized = 1

ascii.initialized

    nul = substr(&alphabet,1,1)

ascii.next

*   Add space after previous character if result not null.

    ascii = differ(ascii) ascii ' '
    c = substr(line,1,1)                        :f(ascii.done)
    ident(c,nul)                                :s(ascii.null)
    line any('0123456789')                      :s(ascii.integer)
    line any(&lcase &ucase)                     :s(ascii.letter)
    line ' '                                    :s(ascii.space)

*   Check for control character (code <=26)

    &alphabet break(c) . pos                    :f(ascii.other)
    pos = size(pos)
    gt(pos,26)                                  :s(ascii.other)
*TODO here fix g. usage
    ascii = ascii g.ascii.name[c] '(^'
               substr('ABCDEFGHIJKLMNOPQRSTUVWXYZ',pos,1) ')'
    line len(1) =                               :(ascii.next)

ascii.integer

    line span('0123456789') . text =
    ascii = ascii  text                         :(ascii.next)

asciiletter

    line span(&lcase &ucase) . text =
    ascii = ascii  text                         :(ascii.next)

ascii.null

    ascii = ascii 'NUL'                         :(ascii.next)

ascii.other

*   Here if none of the other cases apply, so just list the ascii name.

    ascii = ascii ascii.name[c]
    line = substr(line,2)                       :(ascii.next)

ascii.space

    line span(' ') . text =

    ascii =  ascii 'SPC'
    ascii = gt(size(text),1) ascii 'SPC*' size(text)
    ascii = ascii
                                                :(ascii.next)
ascii.done

    ascii = trim(ascii)                     :(return)

ascii.end

    define('ascii.init(init)entry,name,value') :(ascii.init.end)

*   _Ascii.init_ Initialize maps for use by _ascii_.
*   Since space (ascii 32) prints as space, use the name SPC for 32.

ascii.init


    ascii.init = new('map '
.      '0:NUL 16:DLE 32:SPC 48:0 64:@ 80:P  96:` 112:p '
.      '1:SOH 17:DC1 33:!   49:1 65:A 81:Q  97:a 113:q '
.      '2:STX 18:DC2 34:"   50:2 66:B 82:R  98:b 114:r '
.      '3:ETX 19:DC3 35:#   51:3 67:C 83:S  99:c 115:s '
.      '4:EOT 20 DC4 36:$   52:4 68:D 84:T 100:d 116:t '
.      '5:ENQ 21:NAK 37:%   53:5 69:E 85:U 101:e 117:u '
.      '6:ACK 22:SYN 38:&   54:6 70:F 86:V 102:f 118:v '
.      "7:BEL 23:ETB 39:'   55:7 71:G 87:W 103:g 119:w "
.      '8:BS  24:CAN 40:(   56:8 72:H 88:X 104:h 120:x '
.      '9:HT  25:EM  41:)   57:9 73:I 89:Y 105:i 121:y '
.      '10:LF 26:SUB 42:*   58:  74:J 90:Z 106:j 122:z '
.      '11:VT 27:ESC 43:+   59:; 75:K 91:[ 107:k 123:{ '
.      '12:FF 28:FS  44:,   60:< 76:L 92:\ 108:l 124:| '
.      '13:CR 29:GS  45:-   61:= 77:M 93:] 109:m 125:} '
.      '14:SO 30:RS  46:.   62:> 78:N 94:^ 110:n 126:~ '
.      '15:SI 31:US  47:/   63:? 79:O 95:_ 111:o 127:DEL ')

    ascii.name = .map(efault.size)
    ascii.value = .map(efault.size)
    loop(ascii.init)

ascii.init.next

    entry = setl4.l.next(ascii.init)                :(ascii.init.finis)
*   Correct entry for 0 to be NUL, the NUL character
    ascii.name[substr(&alphabet,+v + 1,1)] = name
    ascii.value[name] = +value                      :(ascii.init.next)
    ascii.name[] = 'NUL'
    ascii.value['NUL'] = 0
    ascii.name[' '] = 'SPC'
    ascii.value['SPC'] = 32                         :(return)

ascii.init.end

    define('begins(str,init)')                      :(begins.end)

*   _Begin_ tests if string _str_ begins with string _init_.
*   It returns _str_ on success, fails otherwise.

begins

    ident(str)                                      :s(freturn)
    ident(init)                                     :s(freturn)
    begins = str
    ident(str,init)                                 :s(return)
    gt(size(init),size(str))                        :s(freturn)
    ident(substr(str,1,size(init)),init)            :s(return)f(freturn)

begins.end

	define('checkout(filename)file,line,word')	    :(checkout.end)

*	_Checkout_ checks out (retrieves)  a file from the library as a sequence of lines
*   or a set of words. _Checkout_ lists the available files if _filename_ is null.

*   Dictionary has one word per line, with upper case 'S' at end denoting
*   that both singular and plural form are words in the dictionary.


checkout

    out('enter checkout',filename)
    differ(filename)                                :s(checkout.checkout)

checkout.list

    out('available texts in the checkout:')
	out('dictionary')
	out('genesis')
	out('hamlet')
	out('new-testament')
	out('old-testament')
	out('romeo-and-juliet')
	out('shakespeare')
	out('sonnets')
                                                    :(return)


checkout.checkout

*   See if _filename_ matches one of the available texts.


	filename = begins('dictionary',filename)        :s(checkout.open)
	filename = begins('enable1',filename)		    :s(checkout.open)
	filename = begins('genesis',filename)		    :s(checkout.open)
	filename = begins('hamlet',filename)		    :s(checkout.open)
	filename = begins('new-testament',filename)	    :s(checkout.open)
	filename = begins('old-testament',filename)	    :s(checkout.open)
	filename = begins('romeo-and-juliet',filename)  :s(checkout.open)
	filename = begins('shakespeare',filename)	    :s(checkout.open)
	filename = begins('sonnets',filename)		    :s(checkout.open)

    out('sorry, that text is not available.')
    out('here is a list of the available texts')    :(checkout.list)

checkout.open

    out('checking out',filename)
*	Read in text from the checkout.

	filename = './library/' filename '.txt'
    out('checking out',filename)
	input(.file,3,filename)		                    :s(checkout.opened)
	error('unable to open checkout file ',filename)	:(freturn)

checkout.opened

*   Dictionary requires special handling.

    ident(filename,'dictionary')                    :s(checkout.dict)
    checkout = set('map',iterator(),table(2000),table(2000))

checkout.text.next

	line = file					                    :f(checkout.finis)
*   out('read line',line)
    put(checkout,set.size(checkout) + 1, line)      :(checkout.text.next)

checkout.dict

    checkout = set('set',iterator(),table(40000),table(40000))

checkout.dict.add
   
*   Here to add word to the dictionary.

    add(checkout,word)

checkout.dict.next


    word = file                                     :f(checkout.finis)
    out('dict line',line)
    ident(substr(word,size(word),1),'S')            :f(checkout.dict.add)

*   Here if plural. Add plural form and them merge to add singular form.

    word = substr(word,1, size(word) -1)
    add(checkout, word 's')                         :(checkout.dict.add)
    
checkout.finis

	endfile(3)				                        :(return)

checkout.end

    define('datename()s')                           :(datename.end)

*   _Datename_ converts the current date in a form with no spaces,
*   just dashes, that is suitable for use as part of a file name.

datename

    datename = replace(date(),' :/','---')
    datename = substr(datename,12,8) '-' substr(datename,1,10)
                                                    :(return)
datename.end

    define('digits()str,ch')                        :(digits.end)

*   _Digits_ returns the string consisting of the digits 0 .. 9 separated by a space.

digits

    digits = 
    str = '0123456789'
    
digits.next

    str len(1) . ch =                               :f(return)
    digits = append(digits,ch)                      :(digits.next)

digits.end

    define('even(n)')                           :(even.end)

*   _Even_ tests if its argument is even.

even

    eq(remdr(n,2))                              :s(return)f(freturn)

even.end

    define('factorial(n)')                      :(factorial.end)

*   _Factorial_ computes the value of the factorial function of its argument.

factorial

    factorial = (eq(n,1) 1, n * factorial(n -1))    :(return)

factorial.end

    define('less(str,sub)before,after')             :(less.end)

*   _Less_ removes the first instance of each character in _sub_ from _str_,
*   where _sub_ is a substr of _str_.

less

    ident(str)                                      :s(return)
    less = str

less.ch
    sub len(1) . ch =                               :f(return)
    less break(ch) . before  ch rem . after
    less = before after                             :(less.ch)

less.end

    define('lletters()str,ch')                      :(lletters.end)

*   _Lletters_ returns a string consisting of the lower case letters in _str_ separated by a space.

lletters

    lletters = 
    str = &lcase
    
lleters.next

    str len(1) . ch =                               :f(return)
    lletters = append(lletters,ch)                  :(lleters.next)

lletters.end

    define('letters(str)ch')                        :(letters.end)

*   _Letters_ returns a string consisting of the letters in string _str_ separated by a space.
*   Letters can be used to build a sequence of the non-blank letters in a string: _new('seq ' letters(str))_

letters

    str len(1) . ch =                               :f(return)
    ident(ch,' ')                                   :s(letters)
    letters = letters (differ(letters) ' ', '') ch  :(letters)

letters.end

    define('lower(s)')                              :(lower.end)

*   _Lower_ converts argument to lower case.

lower

    lower = replace(s,&ucase,&lcase)                :(return)

lower.end

    define('multiple(n,m)')                     :(multiple.end)

*   _Multiple_ Tests if _n_ is a multiple of _m_.

multiple

    multiple = eq(remdr(n,m))                   :s(return)f(freturn)

multiple.end

    define('number(n)')                         :(number.end)

*  _Number_ determines if the integer _n_ can be represented as a string of one or two words,
*   and if so, returns that string. Otherwise it returns its argument value.

number
    error('number not implemented, quitting.' )
    number = eq(n) 'zero'                       :s(return)
    number = g.numbers[n]
    differ(number)                              :s(return)
    number = n                                  :(return)

number.end

    define('odd(n)')                            :(odd.end)

*   _Odd_ tests if its argument is odd.

odd

    odd = ne(remdr(n,2))                        :s(return)f(freturn)

odd.end

    define('prefix(str,pre)word')               :(prefix.end)

*   _Prefix_ takes a list of space-separated words _str_ and prefixes each
*   with the str _pre_.

prefix

    str = str ' ';* so each word followed by space

prefix.1

    str break(' ') . word span(' ')  =          :f(return)
    add1(.prefixcount)
    prefix = append(prefix, pre word,'A')       :(prefix.1)

prefix.end

    define('prime(n)')                          :(prime.end)

*   _Prime_ tests if _n_ is a prime integer.

prime

    n = integer(n) +n
    eq(n,2)                                     :s(return)
    even(n)                                     :s(freturn)
    exists(new('iter 3 ' square.root(n) ' 2'), 'multiple(n,this)') :s(freturn)f(return)

prime.end

    define('primes(n)set.this')                 :(primes.end)

*   _Primes_ returns the set of primes less than _n_.

primes

    primes = filter(new('iter 2 ' (n - 1)),'prime(this)') :(return)
    primes = new('seq 2')
    iter = new('iter 2 ' (n - 1))
    loop(set)

primes.loop
   
    this = next(set)                           :f(return)
    prime(this) push(primes,this)              :(primes.loop)

primes.end


*   Lines
*   -----

*   Lines can be just strings or, in some cases, a line is represented by a pair:

    data('line(mark,text)')

*   where

*           _mark_ is defined by the value returned by an instance
*           of the _eval_ function ...

*           _text_ is the text of the line.

*   For example, the _reader_ function reads a file and returns a
*   sequence of _lines_.

    define('reader(filename,expr)line,mark')        :(reader.end)

*   _Reader_ returns a sequence of the lines in the file specified by _filename_.

*   If _expr_ is not null, then _eval_ is called just after each
*   line is read, with the variable _pair_ set to the associated pair.
*   If _eval_ fails the line is skipped.  Otherwise returns a new pair
*   to be entered in the input seq.

reader

    differ(filename) input(.file,setl4.config.channel.1,filename):s(reader.opened)
    out('unable to open reader file ' filename '.') :(freturn)

reader.opened

    reader = new('map')

reader.next

    line = (ident(filename) input, file)                :f(reader.eof)
    out('reader', line)
    push(reader,line)                                   :(reader.next)

reader.eof

*   Here at end of file; close temporary file if one was needed.

    differ(filename) endfile(setl4.config.channel.1)    :(return)

reader.end

    define('reader.str(str,delim)line')             :(reader.str.end)

*   _Reader.str_ returns a sequence of the lines in _str_,
*   where the delimiter character _delim_ is used to mark
*   If _delim_ is  not given, then '/' is understood.
*   the end of a line. One intended use of _reader.str_
*   is to assist in the construction of test programs.

reader.str

    delim = ident(delim) '/'
    reader.str = new('seq')

reader.str.next

    str break(delim) . line delim =                 :f(return)
    push(reader,line)                               :(reader.str.next)

reader.str.end

    define('slice(str,first,last)')                 :(slice.end)

*   _Slice_ returns a slice of a string. It does the same operation as _substr),

slice

    slice = substr(str,first,last)                  :(return)

slice.end


    define('split(str)i,word')                       :(split.end)

*   _Split_ splits a string into words or characters. If the string _str_ has no spaces,
*   _split_ returns a sequence of the characters in _str_. Otherwise, _split_
*   returns a sequence of the words in _str_, where the words are separated by 
*   whitespace (one of more consecutive spaces or tabs).

split

    split = new('map')
    str break(' ')                                   :f(split.str)

split.next

*   Here to split string into a sequence of its words.

*    str break(' ') . word ' ' =                     :f(return)
    str break(' ') . word ' ' =                     :f(split.str.done)
    put(split,i = i + 1, word)                      :(split.next)

split.str
    
    split = new('map')
    str =  letters(str) ' '

split.str.next

    str span(' ') =
    str break(' ') . word ' ' =                     :f(split.str.done)
*    str break(' ') . word ' ' =                     :f(return)
    put(split,i = i + 1, word)                      :(split.str.next)

split.str.done

                                        :(return)

split.end

    define('square.root(n)')                    :(square.root.end)

*   _Square.root_ returns the square root of its argument, rounded up.

square.root
   
    square.root = int(sqrt(n)) + 1              :(return)

square.root.end

    define('thousands(s)n')                     :(thousands.end)

*   _Thousands_ formats its argument by inserting comma's every three digits from right.

thousands

    n = size(s)
    thousands = le(n,3) s                       :s(return)
    thousands = thousands(substr(s,1,n - 3)) ',' substr(s, n - 2, 3):(return)

thousands.end

    define('uletters()str,ch')                      :(uletters.end)

*   _Uletters_ returns string consisting of the upper case letters separated by a space.

uletters

    uletters = 
    str = &ucase
    
ulleters.next

    str len(1) . ch =                               :f(return)
    uletters = append(uletters,ch)                  :(ulleters.next)

uletters.end

*   Tokens: Lexical Scanning
*   ------------------------


*   A token is represented as an instance of the datatype _token_ as follows:

    data('token(lineno,ndx,type,text)')

*   where:
*           _lineno_        is the line number within the file;
*           _ndx_           is the index of the first character of the
*                           token in the line;
*           _type_          is the token's type, as described below; and
*           _text_          is the text of the token.

*   The type is represented by a single character, as follows:

*           'c'             comment, indicated by asterisk (*) in the first column.
*                           The text consists of the entire line.

*           'i'             integer, consisting of one or more digits ('0123456789')

*           'l'             left opener, one of '(<[{'

*           'p'             punctation, one of '.;,?!', or single quote ('),
*                           or double quote ("),

*           'o'             other printable character, one of '~@#$%^&*_-+=`'.

*            'q'            quoted str, starting witn '"', and continuing
*                           to the next instance of the opening quote character.

*           'r'             right closer, one of ')>]}'

*           's'             space, consistine of one or more spaces (spaces)

*           't'             tab character

*           'u'             unprintable character, for example control-k

*           'w'             word, consisting of one of more letters in
*                           upper or lower case or "'" or "_".

*   The longest possible str meeting the rules is used when building a token.
*   For example, 'abc' is just the word 'abc', not 'a' followed by 'bc', and so forth.

*   It is recommended that the tab character NOT be used as an abbreviation for
*   one or more spaces in the input file. If tabs are used, then _pos_ is ill-defined.
*   If tabs are not used, then _pos_ indicates the true position in the line of
*   the first character of the token, and so error messages and references to the
*   token will be exact.  For example, _pos_ could be used to indicate where to give
*   emphasis to a token by underlining it, or enclosing it in '_' to generate
*   markdown format, and so forth.

    define('tokens(line)type,pos,text,lineno')  :(tokens.end)

*   _Tokens_ scans a line _line_ and returns a table of the tokens in the line.
*   The table has keys from 1..n, where _n_ is the number of tokens found.

*   This function is an instance of what is called a lexiical scanner, or tokenizer,
*   which is the first stage in a programming language compiler, or for any program
*   that processes text files with a specified structure.

tokens

    tokens = new('seq')
    line '*'                                        :f(tokenl.next)
    type = 'c'
    text = line
    line =                                          :(tokenl.new)

tokenl.next

    line ' '                                        :s(tokens.space)
    line any('0123456789')                          :s(tokens.integer)
    line any('(<[{')                                :s(tokenl.left)
    line any('.;,?!')                               :s(tokens.punctuation)
    line '"'                                        :s(tokens.quote)
    line any('~@#$%^&*_-+=')                        :s(tokens.other)
    line any(')>]}')                                :s(tokens.right)
    line char(9)                                    :s(tokens.tab)
    line any(&lcase &ucase)                         :s(tokens.word)

*   Here for unprintable
    error('unprintable?? fix in tokens')

tokens.integer

    type = 'i'
    line span('0123456789') . text =                :(tokenl.new)

tokens.punctuation

    type = 'p'                                      :(tokens.character)

tokens.other

    type = 'o'                                      :(tokens.character)

tokens.quote

    type = 'q'
    line '"' break('"') . text '"' =
    text = '"' text '"'                             :(token.new)

tokens.right

    type = 'r'                                      :(tokens.character)

tokens.space

    type = 's'
    line span(' ')  . text =                        :(tokenl.new)

tokens.tab

    type = 't'                                      :(tokens.character)

tokens.word

*TODO*
    type = 'w'
    line span(&ucase &lcase "_" "'") . text =       :(tokenl.new)

tokens.character

*   Here if token is single character.

    line len(1) . text                              :(tokenl.new)

tokenl.new

    setl4.add(tokens,token(lineno,pos,type,text))   :(tokenl.next)

tokens.end

    define('upper(s)')                              :(upper.end)

*   _Upper_ converts its argument to upper case.

upper

    upper = replace(s,&lcase,&ucase)                :(return)

upper.end

    define('writer(lines)')                         :(writer.end)

*   _Writer_ writes the lines in the sequence _lines_ to standard output.

writer

    loop(lines)

writer.next

    output = next(lines)                            :f(return)s(writer.next)

writer.end

*   SETL4 Global variables
*   ----------------------

    setl4.ascii.initialized = 
    setl4.ascii.name = 
    setl4.ascii.value =  
    setl4.random.initialized =
    setl4.random.value = 2017

*   Useful patterns

    setl4.any.digit         =   any('0123456789')
    setl4.span.digits       =   span('0123456789')
    setl4.break.digit       =   break('0123456789')

    setl4.break.letter      =   break(&lcase &ucase)
    setl4.any.letter        =   any(&lcase &ucase)
    setl4.span.letters      =   span(&lcase &ucase)
    setl4.span.spaces       =   span(' ' char(9))
    setl4.break.space       =   break(' ' char(9))

    setl4.any.word          =   any(&lcase &ucase '0123456789')
    setl4.span.word         =   span(&lcase &ucase '0123456789')

    setlr.random.value      = 2017
*   setl4.rank.types gives valid values for the argument _type_ in the function _rank()_

    setl4.rank.types = new('map '
.      '+:+k +k:+k +ke:+k +key:+k -:-k -k:-k -ke:-k -key:-k '
.      '+v:+v +va:+v +val:+v +valu:+v +value:+v -v:-v -va:-v -val:-v -valu:-v -value:-v')

*   SETL4 needs a stack

    setl4.stack = new('seq')

*   _setl4.config.library.texts_ is a set of the names of the available texts.

    setl4.config.library.texts = new('set dictionary genesis hamlet new-testament old-testament romeo-and-juliet shakespeare sonnets')

*   Here endeth the SETL4 code.
*   May you fare well using it.


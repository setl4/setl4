*    Copyright 2017, David Shields
*   Licensed under the MIT license.

    &dump = 2

*   SETL4 is an extension of SPITBOL. This file consists of a set of functions
*   operator definitions that support set-theoretic operations defined
*   on finite sets.

*   SETL4 extends SPITBOL by adding the datatype _set_ to represent
*   finite sets. Several additional datatypes based on sets are
*   also provided. Each is identified by its kind.

*   A set is defined by the following datatype:

    data('set(set.kind,set.index,set.key,set.size,set.next,set.loop,set.low,set.high,set.step,set.text,set.seq)')

*   where

*           _kind_          the kind of _set_: 'int', 'map', 'seq', 'set', or 'str'.

*           _index_         a SPITBOL table used to map the integer
*                           id assigned each element to the value of the element.

*           _key_           a SPITBOL table, used only for maps, to permit iteration

*           _size_          the current number of members.

*           _next_          the last value returned by the _next_ primitive
*                           when iterating over a set.

*           _text_          is the text of the set of kind _str_

*           _seq_           is the array used to maintain a sequence. _set.key_
*                           and _set.index_ are not used for sequences.

*   Note that the null value is not allowed as an element of a set, or the
*   value of a map entry, but can be used as the value of an element in a seq.

*   The _key_ table is needed to provide constant time bounds for iterating over
*   a set, in all of its forms.

*   Since the _key_ table is needed, a set can be indexed using the key table.
*   This allows the definition of 'get' and 'put' on sequences.

*   Sequences are currently implemented using SPITBOL arrays, extending
*   the array length dynamically as needed.

*   New elements can be added to a sequence using the 'push' primitive,
*   and the most recent element can be deleted using the 'pop' primitive.

*   In order to avoid clashing with the names of user-defined functions, almost
*   all of the functions defined herein begin with one of the following strings:

*       'int'   'map'   'seq'   'set'   'setl4'    'str'

*   The following functions have no such prefix, due to the ubiquity of their use:

*       and  assert  exists false forall loop  mark  next  or  rank  show  true


*   SETL4 supports a variety of sets. Each has a kind, one of:

*       int   map   seq   set   str

*   For each kind, there are set-theoretic functions, as well as functions
*   that have proven to be useful. These are noted as 'utility' below.

*   SETL4 unary operators:

*   '='     =s      Arb             Returns arbitary (randomly selected)  element of s
*   '|'     |'str'  Constructor     Returns set specified by string _str_
*   '!'     !expr   Not             True if and only if _expr_ is false
*   '#'     #s      Size            Number of elements in set _s_
*   '/'     /s      Split           Splits a string into a sequence of words

*   SETL4 binary operators:

*   '&'     a & b   And             True if and only if both _a_ and _b_ are true
*   '@'     s @ e   Eval            Evaluates _e_ at current element of set _s_
*   '#'     s # e   Filter          Returns subset of set _s_ for which _e_ is true
*   '~'     m ~ s   Membership      Tests if _m_ is member of set _s_
*   '^'     a ^ b   Or              True if and only if _a_ or _b_ is true

*   For example, the folowing SETL4 expression determines if integer _P_ is prime:

*           !exists(|'int 2 P' @ 'multiple(P,this)')

*   where _multiple(a,b) is true if and only if _a_ is a multiple of _b_.

*   Boolean Logic
*   -------------

*   Boolean logic is an algebra with just two values: true and false.

*   In SPITBOL, the algebra is defined on strings: the null string is "false" 
*   and all other strings are "true".  The SPITBOL function IDENT is used 
*   to test for true, DIFFER for false. 
*   Each signals their result by success (true) or failure (false).

*   In SETL4, the algebra is defined both on integers and non-integers.  
*   For integers, zero is "false" and all other integers are "true." 
*   For non-integers, the null string ('') is true, and all other values are false.

*   SPITBOL comparison functions report their results by success or failure, so SETL
*   provides the following functions which return true or false.


*   String operations based on SPITBOL
*   ----------------------------------

*   str.any(a,b)    tests if the first character of a is in b
*   str.break(a,b)  tests if a contains one of the characters in b
*   str.notany(a,b) tests if first character in a is not in b
*   str.span(a,b)   tests if bcontains only characters in a

*   false(e)
*   true(e)
*   assert.dt(obj,typ)
*   assert(expr)
*   exists(set,expr)
*   forall(set,expr)


*   Int: sets of kind _int_
*   ----------

*   A set of kind _int_ represents a set of integers. The set cannot be changed
*   once it is created. You can only loop over a set of kind _int_ or test for 
*   membership.

*   Int set functions
*   -----------------

*   int.member(member,int)

*   Int utility functions
*   ---------------------

*   int.cardinal(n,word)
*   int.even(n)
*   int.factorial(n)
*   int.number(n)
*   int.multiple(n,m)
*   int.odd(n)
*   int.prime(n)set
*   int.square.root(n)
*   int.thousands(s)

*   loop(set)


*   Map: sets of kind 'map'
*   --------
*   A map is a set of ordered pairs.

*   Map set functions
*   -----------------


*   map.domain(map)
*   map.equal(a,b)
*   map.first(map)
*   map.get(map,key)
*   map.last(map)
*   map.put(map,key,val)
*   map.range(map)
*   map.defined(map,key)


*   mark(line)
*   next(set)
*   rank(set)

*   Seq: set of kind _seq_

*   A sequence (_seq_) is a map on the positive integers 1 .. n
*   Sequences are implemented using SPITBOL arrays, and so are very efficient.


*   Seq set functions
*   -----------------

*   seq.add(seq,val)
*   seq.get(seq,i)
*   seq.integers(n)
*   seq.push(seq,val)
*   seq.put(seq,i,val)
*   seq.range(seq)

*   Set 
*   ---

*   Set set functions
*   -----------------

*   set.add(set,elem)
*   set.difference(a,b)
*   set.equal(a,b)
*   set.first(set)
*   set.from(set,elem)
*   set.integers(n)
*   set.intersection(a,b)
*   set.last(set)
*   set.subset(a,b)
*   set.union(a,b)

*   Show: display SETL4 object

*   The function _show_ is used to represent the value of a SETL4 object
*   in a human-readable form.

*   Objcts are shown in the order defined by the function _rank_.
k
*   show(v,lvl)
*   show.b(e)
*   show.line(line)
*   show.lines(lines,title)
*   show.quote(str)
*   show.words(words)

*   Str: set of characters

*   _Str_ is used to treat a character string as a set of characters.

*   Str utility functions
*   -----------------

*   str.append(str,w,ch)
*   str.ascii(line)
*   str.ascii.init(init)
*   str.datename(date)
*   str.frequency(str)
*   str.lower(s)
*   str.spaces(line)c
*   str.less(str,sub)
*   str.out(text1,text2,text3)
*   str.prefix(str,pre)
*   str.reader(filename,expr)
*   str.reader.string(str,delim)
*   str.slice(str,first,last)
*   str.tokens(line)
*   str.upper(s)
*   str.words(line)
*   str.writer(lines)

*   this(set)
*   visit(set,expr)

*   Setl4 functions

*   Functions with names starting with 'setl4' are internal to the implementation.
*   Most of them implement the SETL4 operator such  as "^" and "&".
*   You can access them directly, but do so at your peril.

*
*   setl4.and(a,b)
*   setl4.arb(set)
*   setl4.binary.search(tbl,value)
*   setl4.concatenate(a,b)
*   setl4.eval(set,expr)
*   setl4.filter(set,expr)
*   setl4.kind(set,kind1,kind2,kind3,kind3,kind4)
*   setl4.member(elem,kind,entry,key,value)
*   setl4.new(str)
*   setl4.next(set)
*   setl4.not(expr)
*   setl4.or(a,b)
*   setl4.random(n)
*   setl4.random.seed()
*   setl4.size(set)
*   setl4.traceoff()
*   setl4.traceon()


*   SETL4 configuration options
*   ---------------------------

*   Initial size of any hash tables created when constructing
*   a new instance of a set.

*   Use large value for now, to avoid need for expansion during initial testing.
*    setl4.config.size = 16
    setl4.config.size = 120

*   SETL4 global variables
*   ----------------------


    setl4.break.whitespace = break(' ' char(9))
    setl4.span.whitespace =  span(' ' char(9))


*   SETL4 constants
*   ---------------

*   The values of the following variables should NEVER be changed, lest chaos ensue.

    FALSE = 0
    TRUE = 1

    THIS = 'THIS'


*   SETL4 function definitions
*   --------------------------


    define('false(e)')                              :(false.end)

*   Returns TRUE if its argument is false, or else FALSE.

false

    e = integer(e) +e
    false = integer(e) (eq(e,FALSE) TRUE,FALSE)     :s(return)
    false = (ident(e) TRUE, FALSE)                  :(return)

false.end

    define('true(e)')                              :(true.end)

*   Returns TRUE if its argument is true, or else FALSE.

true
    e = integer(e) +e
    true = integer(e) (eq(e,FALSE) FALSE,TRUE)     :s(return)
    true = (differ(e) TRUE, FALSE)                  :(return)

true.end

    define('assert.dt(obj,typ)')                    :(assert.dt.end)

*   Verify that _obj_ has datatype _typ_, end execution if not.

assert.dt

    assert(ident(datatype(obj),typ))                :s(return)
    error('assertion on datatype failed ' typ )
    

assert.dt.end

    define('assert(expr)')                          :(assert.end)

*   Verify that _expr_ is TRUE, end execution otherwise.

assert

    true(expr)                                      :s(return)
    output = 'assertion failed, quitting' :(end)

assert.end

    define('exists(set,expr)e')                     :(exists.end)

*   Tests if there is an element in _set such that _eval(expr)_ is TRUE.

exists

    output = ident(expr) 'exists expr is null'
    str.out('exists expr',expr)
    exists = FALSE
    loop(set)

exists.loop

    str.out('at exists.loop')
    next(set)                                       :f(return)
    str.out('exists.next',set.next(set))
    e = x.eval(expr)                                :f(exists.loop)
    str.out('eval didn not fail')
    false(e) str.out('x.eval returned false')
    false(e)                                        :s(exists.loop)
    str.out('eval exists expr ',e)
    str.out('true(e) after eval',true(e))
    exists = true(e) TRUE                           :s(return)f(exists.loop)

exists.end
    define('x.eval(e)')          :(x.eval.end)

x.eval
    str.out('x.eval',e)
 :(end)
    e = eval(e)                 :f(x.eval.f)
    x.eval = (ne(e) TRUE,FALSE)
    str.out('x.eval',x.eval)
    :(return)
x.eval.f
    x.eval = FALSE
    str.out('x.eval false',e) 
                            :(return)
x.eval.end

    define('forall(set,expr)e')                     :(forall.end)

*   Tests if _expr_ is TRUE for all the members of _set.

forall

    forall = FALSE
    loop(set)

forall.loop

    next(set)                                       :f(forall.true)

    e = eval(expr)                                  :f(return)
    true(e)                                         :s(forall.loop)f(return)

forall.true

    forall = TRUE                                   :(return)

forall.end

*   Integers (int's)
*   --------

*   SETL4 provides the type _int_ .
*   An _int_ is a sequence of positive integers.
*
*   SETL4 extends the integer operations provided by SPITBOL by
*   providing the following integer functions:

*            int.even(n)       true iff _n_ is even.
*            int.factorial(n)  returns the value of
*                                   n! = _n_ * (n - 1) * ... *
*            int.multiple(n,m) true iff _n_ is multiple of _m_
*            int.odd(n)        true iff _n_ is odd.
*            int.prime(n)      true iff _n_ is a prime number
*            int.square.root   square root rounded up to next integer.

    define('int.int.cardinal(n,word)')           :(int.int.cardinal.end)
*   If N is one, returns 'one' followed by WORD.
*   Otherwise returns NUMBER(N) followed by WORD and 'S'.

int.int.cardinal

    int.cardinal = (eq(n,1) 'one ' word, number(n) ' '  word 's'):(return)

int.int.cardinal.end

    define('int.even(n)')                           :(int.even.end)

*   Returns TRUE iff _n_ is even.

int.even

    int.even = (eq(remdr(n,2)) true,false)          :(int.even.end)

int.even.end

    define('int.factorial(n)')                      :(int.factorial.end)

*   Returns n! = n*(n-1)*(n-2) ... 1

int.factorial

    int.factorial = (eq(n,1) 1, n * int.factorial(n -1))    :(return)

int.factorial.end

    define('int.member(member,int)')                :(int.member.end)

*   Tests if _member_ is a member of _int_

int.member

    member = +member
    int.member = lt(member,set.low(int))    FALSE   :s(return)
    int.member = gt(member,set.high(int))   FALSE   :s(return)
    int.member = (multiple(
.                       (int.high(int) - int.low(int))
.                         / int.step(int),
.                       int.step(int))
.                       TRUE, FALSE)      :(return)

int.member.end

    define('int.multiple(n,m)')                      :(int.multiple.end)

*   Tests if _n_ is a multiple of _m_.

int.multiple

    int.multiple = (eq(remdr(n,m)) TRUE, FALSE)      :(return)

int.multiple.end

    define('int.number(n)')                          :(int.number.end)

**      If _n_ can be represented as a string of one or two words
**      then return that string. Otherwise return _n_.

int.number
    error('int.number not implemented, quitting.' )
    int.number = eq(n) 'zero'                    :s(return)
    int.number = g.numbers[n]
    differ(int.number)                           :s(return)
    int.number = n                               :(return)

int.number.end

    define('int.odd(n)')                            :(int.odd.end)

*   Returns true iff _n_ is odd.

int.odd

    int.odd = (ne(remdr(n,2)) TRUE,FALSE)           :(return)

int.odd.end


    define('int.prime(n)set')                       :(int.prime.end)

*   Returns true iff _n_ is prime.

int.prime

    set = setl4.new('int 2 ' square.root(p))
    int.prime = not(exists(set,'eq(remdr(p,=s))'))  :(return)

int.prime.end

    define('int.square.root(n)')                    :(int.square.root.end)

*   Returns square root of integer _n_, rounded up.

int.square.root

    int.square.root = convert(sqrt(convert(n,'real')),
.                               'integer') + 1 :(return)

int.square.root.end

    define('int.thousands(s)n')                  :(int.thousands.end)

*   Format s with comma's every three digits from right.

int.thousands

    n = size(s)
    int.thousands = le(n,3) s                    :s(return)
    int.thousands = int.thousands(substr(s,1,n - 3)) ',' substr(s, n - 2, 3):(return)

int.thousands.end

    define('loop(set)dt')                           :(loop.end)

*   Set up for loop. Set set.next field so that on first call to _next()_
*   the index will be advanced to the first element in the set.

loop

*   Returns loop member in interation over compound object _set.

    set.next(set) = ident(set.kind(set),'int') set.low(set) - set.step(set) :s(return)
    set.next(set) =  0                              :(return)

loop.end

*   Maps
*   --------------

*   A _pair_ joins two values together.

    data('pair(first,second)')

*   In mathematics, a map, or function, defined on a finite set is a set of 
*   ordered pairs that define a relation between the first element of a pair, 
*   its _key_, and the value of the map for _key_.

*   SETL4 represents a map entry as follows:

    data('entry(key,value)')

*   where _key_ is the key, and _value_ is the value of the
*   map for _key_.

*   The SPITBOL datatype TABLE provides the machinery to implement maps.
*   SPITBOL provides no way to determine the number of domain values,
*   or size, of a map other than converting the map to an array, which is
*   the only way to iterate over a set.

*   Each new entry added to a map is given an integer id,
*   starting with one.  The field _set.index_ maps the id's
*   to the associated entries.

*   The field _set.key_ maps the keys used in entries to
*   their associated id's, and is needed to allow constant-time
*   access to map entries, both when retrieving values and
*   when iterating over the set.

    define('map.defined(map,key)')                      :(map.defined.end)

*   Tests if the map _map_ has an entry for _key_.

map.defined

    map.defined = (differ(set.key(map)[key]) TRUE,FALSE) :(return)

map.defined.end

    define('map.domain(map)elem)')                      :(map.domain.end)

*   Return set of the keys in _map_.

map.domain

    map.domain = set.new()
    loop(map)

map.domain.next

    set.add(map.domain,key(next(map)))                  :s(map.domain.next)f(return)

map.domain.end

    define('map.equal(a,b)entry')                        :(map.equal.end)

*   Test two maps for equality.

map.equal

    map.equal = FALSE
    ne(set.size(a),set.size(b))                         :s(return)
    loop(a)

map.equal.next

    entry = next(a)                                     :f(map.equal.true)
    ident(map.get(a,key(entry)),map.get(b,key(entry)))  :f(return)s(map.equal.next)

map.equal.true

    map.equal = true                                    :(return)

map.equal.end

    define('map.first(map)')                            :(map.first.end)

*   Returns first element in _map_.

map.first

    map.first = set.key(map)[1]                         :(return)

map.first.end

    define('map.get(map,key)val)id')                :(map.get.end)

*   Gets the value of the key _key_ in the map _map_.

map.get

    id = set.key(map)[key]
    ident(id)                                       :s(return)
    map.get = set.index(map)[id]                    :(return)

map.get.end

    define('map.last(map)')                         :(map.last.end)

*   Returns last element in _map_.

map.last

    output = 'enter map.last'
    map.last = set.key(map)[set.size(map)]           :(return)

map.last.end

    define('map.put(map,key,value)v')               :(map.put.end)

*   Sets the value of the entry for key _key_ in map _map_ to be _val_,
*   creating a new entry if necessary.

map.put

    key = integer(key) +key
    value = integer(value) +value
    v = set.key(map)[key]
    differ(v)                                       :s(map.put.value)

*   Here to create new entry in map, and then merge to set new value.

    set.size(map) = set.size(map) + 1
    set.key(map)[key] = set.size(map)

map.put.value

    set.index(map)[set.key(map)[key]] = entry(key,value):(return)

map.put.end

    define('map.range(map)elem)')                  :(map.range.end)

*   Return set of the values in _map_.

map.range

    map.range = set.new()
    loop(map)

map.range.next

    set.add(map.range,value(next(map)))             :s(map.range.next)f(return)

map.range.end

    define('next(set)')                             :(next.end)

next

*   $THIS = next
    next = setl4.next(set)                          :s(next.t)f(next.f)

next.f
    str.out('next fails',next)                      :(freturn)

next.t
    str.out('next succeeds', next)                  :(return)

next.end


    define('rank(set)ara,freq,i,entry,key,seq,str,value')    :(rank.end)

*   Rank returns a sorted version of its operand such that
*   elements are in increasing order. For example,
*           rank('asxybza') is 'aabsxyz'.
*   Sets are ranked in increasing order of their members.
*   Maps are ranked in increasing order of their keys.
*   Sequences and int's are always maintained in rank order.

rank

    rank = setl4kind(set,'int','seq') copy(set)     :s(return)
    setl4kind(set,'map','set','str')                :s($('rank.' setl4kind(set)))
    ident(datatype(set),'string')                   :s(rank.string)
    error('rank unsupported operand type ' datatype(set) )

rank.map

    ara = sort(set.key,1)
    rank = map.new()

rank.map.next

    entry = ara[i = i + 1,1]                        :f(return)
    map.put(rank,key(entry),value(entry))           :(rank.map.next)

rank.set

    ara = sort(set.key,1)
    rank = set.new()

rank.set.next

    set.add(rank,ara[i = i + 1,1])                  :f(return)s(rank.set.next)

rank.str

    str = set.text(set)

rank.str.string

    freq = str.frequency(str)
    seq = set.new()

rank.str.collect

    str len(1) . i =                                :f(rank.str.set)
    set.add(seq,i)                                  :(rank.str.collect)

rank.str.set

    seq = rank(seq)
    loop(seq)

rank.str.next
    
    i = next(seq)                                   :f(return)
    rank.str = rank.str dupl(i,freq[i])             :(rank.str.next)

rank.string

    str = set                                       :(rank.str.string)

rank.end

*   Sequences:
*   ----------

*   A sequence, or 'seq', is a map defined on the positive integers
*   1,2, ... ,n. Sequences are implemented using SPITBOL arrays,
*   which are grown in size when adding a new element for which
*   no room remains in the array.


    define('seq.add(seq,val)')                      :(seq.add.end)

seq.add

    setl4.seq.room(seq)
    seq.add = seq.push(seq,val)                     :(return)

seq.add.end

    define('seq.get(seq,i)')                        :(seq.get.end)

*   Gets the value of element _i_ in the sequence _seq_

seq.get

    seq.get = set.seq(seq)[i]                     :f(freturn)s(return)

seq.get.end

    define('seq.integers(n)i')                      :(seq.integers.end)

*   Returns sequence of integers in the range 1 .. _n_.

seq.integers

    seq.integers = setl4.new('seq ' n)

seq.integers.next

    gt(i = i + 1, n)                                :s(return)
    setl4.seq.room(seq)
    seq.push(seq.integers,i)                        :(seq.integers.next)

seq.integers.end

    define('seq.push(seq,value)')                   :(seq.push.end)

seq.push

    assert.dt(seq,'set')
    assert(ident(set.kind(seq),'seq'))
    value = integer(value) +value
    setl4.seq.room(seq)
    set.size(seq) = set.size(seq) + 1
    set.seq(seq)[set.size(seq)] = value                    :(return)

seq.push.end

    define('seq.put(seq,i,value)v,len')             :(seq.put.end)

*   Sets the value of element _i_ in the sequence _seq_ to be _value_.

seq.put

    assert(ident(kind(seq),'seq'))
    set.seq(seq)[i] = value                         :(return)

seq.put.end

    define('seq.range(seq)')                        :(seq.range.end)


*    Return set with the values in _seq_ as its members.

seq.range

    kind = kind(seq)
    output = differ(kind,'seq') 'range called on non-seq, quitting' :s(end)
    seq.range = set.new()
    loop(seq)

seq.range.next

    set.add(seq.range,set.next(seq))                :f(return)s(seq.range.next)

seq.range.end


*   Sets
*   ____


    define('set.add(set,elem)')                     :(set.add.end)

*   Add _elem_ to set, unless already present.

set.add

    elem = integer(elem) +elem
    set.size(set) = set.size(set) + 1
    set.index(set)[set.size(map)] = elem
    set.key(set)[elem] = set.size(map)               :(return)

set.add.end

    define('set.difference(a,b)elem')               :(set.difference.end)

*   Returns set defined by set of elements of _a_ that are not in _b_.

set.difference

    set.difference = a @ !'set.member(=a,b)'          :(return)

set.difference.end

    define('set.equal(a,b)')                        :(set.equal.end)

*   Tests if two sets are equal.
*   Two sets are equal iff each is a subset of the other.

set.equal

    set.equal = and(set.subset(a,b),set.subset(b,a)) :(return)

set.equal.end

    define('set.first(set)')                            :(set.first.end)

*   Returns first element in _set_.

set.first

    set.first = set.key(set)[1]                         :(return)

set.first.end

    define('set.from(set,elem)this')                    :(set.from.end)

*   Return set consisting of all the elements of _a_ except _elem_.

set.from

    set.from = set.copy(set)
    loop(set)

set.from.next

    this = next(set)                                    :f(return)
    ident(this,elem)                                    :s(set.from.next)
    set.add(set.from,this)                              :(set.from.next)

set.from.end

    define('set.integers(n)i')                      :(set.integers.end)

*   Return set containing integers 1 .. _n_

set.integers

    set.integers = set.new(n)
    i = 0

set.integers.next

    gt(i = i + 1,n)                                 :s(return)
    set.add(set.integers,i)                         :(set.integers.next)

set.integers.end

    define('set.intersection(a,b)elem')             :(set.intersection.end)

*   Returns intersection of sets _a_ and _b_.

set.intersection

*   Make _a_ the smaller set.

    le(set.size(a),set.size(b))                     :s(set.intersection.next)
    set.intersection = a
    a = b
    b = set.intersection
    set.intersectino = set.new('set')
    loop(a)

set.intersection.next

    next(a)                                         :f(return)
    set.member(=a,b)                                :f(set.intersection.next)
    set.add(set.intersection,=a)                    :(set.intersection.next)

set.intersection.end

    define('set.last(set)')                         :(set.last.end)

*   Returns last element in _set_.

set.last

    set.last = set.key(set)[set.size(set)]           :(return)

set.last.end


    define('set.subset(a,b)member')                 :(set.subset.end)

*   Tests if _b_ is a subset of _a_.

set.subset

    set.subset = FALSE
    gt(set.size(b),set.size(a))                     :s(return)
    loop(b)

set.subset.next

    member = set.next(b)                            :f(set.subset.true)
    setl4.member(member,a)                          :s(set.subset.next)f(return)

set.subset.true

    set.subset = true                               :(return)

set.subset.end

    define('set.union(a,b)elem')                    :(set.union.end)

*   Returns union of sets _a_ and _b_.

set.union

*   Arrange so set a is the larger set.

    ge(set.size(a),set.size(b))                     :s(set.union.a)
    set.union = a
    a = b
    b = set.union

set.union.a

*   Make copy of a by making copy of a's table.

    set.union = copy(a)
    loop(b)

set.union.b

    elem = set.next(b)                              :f(return)
    set.add(set.union,elem)                         :(set.union.b)

set.union.end

    define('show(v,label,lvl)i,ent,type,line,hdr')        :(show.end)

*   Show the value of expression _v_.
*   _lev_ is non-zero when called to list member or element
*   of a compound object.

show
    differ(label) str.out('show: ' str.upper(label))
    typ = datatype(v)
                                                    :($('show.' typ))

show.array

    proto = prototype(ara)
    proto break(',')                                :s(show.array.2)

*   Here for one dimensional array.

show.array.1
    first = ara[add1(.i)]                           :f(show.array.done)
    out(lpad(i,3) tab first)                        :(show.array.1)

show.array.2
    first = ara[add1(.i),1]                         :f(show.array.done)
    str.out(lpad(i,3) tab show(first) tab show(ara[i,2])) :(show.array.2)

show.entry

    show = show ' ' show(key(v))  ':' show(value(v)) ' ' :(show.done)

show.int

    show = 'integers(' int.low(v) '..' int.high(v) ') ' :(show.done)

show.integer

    show = v                                        :(show.done)

show.map

*   Call _rank_ so entries listed in rank order.

    map = rank(map)
    loop(v)
    show = ' {'

show.map.next

    member = next(v)                                :f(show.map.done)
    show = show ' ' show(member,,1)
    lt(set.size(show),100)                          :s(show.map.next)
    output = show ' '
    show =                                          :(show.map.next)

show.map.done

    show = show ' }'
                                                    :(show.done)

show.pair

    show = '{' lineid(num(pair)) ',' "'"
.                       replace(line(pair),' ','.') "'" '}' :(show.done)

show.seq

    loop(v)
    show = ' ['

show.seq.next

    member = next(v)                                :f(show.seq.done)
    show = (ident(show) '[ ', show ' ') show(member,,1)
    lt(set.size(show),100)                          :s(show.seq.next)
    output = show ' '
    show =                                          :(show.seq.next)

show.seq.done

    show = show ' ]'                                :(show.done)

show.set

*   Call _rank_ so entries listed in rank order.

    set = rank(set)
    show =  ' {'
    loop(v)

show.set.next

    member = next(v)                                :f(show.set.done)

    show = (ident(show,'{') '{ ', show ' ') show(member,,1)
*   show = show ' '  show(member,,1)
    lt(set.size(show),100)                          :s(show.set.next)
    output = show
    show =                                          :(show.set.next)

show.set.done

    show = show ' }'
                                                    :(show.done)
show.str

    show = show.quote(str.text(set))                :(show.done)

show.string

*   Don't quote string that is an integer.

    show = integer(v) v                             :s(show.done)

    show = show.quote(v)                            :(show.done)


show.table

    t = convert(v,'array')

show.table.next

    key = t[i = i + 1,1]                            :f(show.done)
    value = t[i,2]

    output = tab show(key)    ' -> ' show(value)
                                                    :(show.table.next)
show.string.quote

    show = '"'  v '"'                               :(show.done)

show.done

    output = eq(lvl) show
                                                    :(return)

show.end
    
    define('show.b(e)')                             :(show.b.end)

*   Show value of _e_ as boolean: TRUE or FALSE

show.b

    integer(e) str.out((ne(e) 'TRUE', 'FALSE'))     :s(return)
    str.out((differ(e) 'TRUE', 'FALSE'))            :(return)

show.b.end

    define('show.line(line)')                       :(show.line.end)

*   Show a line with spaces replaced by '.'

show.line

    show.line = replace(line,' ','.')               :(return)

show.line.end

    define('show.lines(lines,title)i,line,titled')  :(show.lines.end)

*   Show the lines that are not empty in an array of lines

show.lines

    title  = 'lines' (differ(title) ' ' title, '')
    out(itle)

show.lines.n

    line = lines[add1(.i)]                          :f(return)
    empty(line)                                     :s(show.lines.n)
    differ(titled)                                  :s(show.lines.titled)

*   Do not list header unless at least one non-empty line

    out('    123456789012345')
    titled = 1

show.lines.titled

    out(lpad(lineid(i),2) ' ' replace(line,' ','.')) :(show.lines.n)

show.lines.end

    define('show.quote(str)')                       :(show.quote.end)

*   Show string _str_ enclosed in quotes

show.quote

    str break('"')                                  :s(show.quote.double)

    show.quote = '"' str '"'                        :(return)

show.quote.double

    show.quote = "'" str "'"                        :(return)

show.quote.end

    define('show.words(words)i,pos')                :(show.words.end)

*   Show results of words() call.

show.words

    pos = words[add1(.i),1]                         :f(return)
    out('words ' lpad(pos,2) ' ' words[i,2])        :(show.words)

show.words.end


*   Strings (str's)
*   ---------------

*   SETL4 provides additional operations, based on set theory,
*    on strings in the form of "str's".

    define('str.append(str,w,ch)')                  :(str.append.end)

*   _str.append_ appends _ch_, or ' ' if _ch_ is null, to _str_
*   and then appends _w_.

str.append

    str.append = str (ident(str) w, str (ident(ch) ' ' , ch) w):(return)

str.append.end

    define('str.ascii(line)c,n,name,nul,num,pos')   :(str.ascii.end)

*   Return the text of line with every str.ascii character identified.

str.ascii

    true(setl4.ascii.initialized)           :s(str.ascii.initialized)

*   Here to initialize the needed maps.
    
    setl4.ascii.init()
    setl4.ascii.initialized = true;

str.ascii.initialized

    nul = substr(&alphabet,1,1)

str.ascii.next

*   Add space after previous character if result not null.

    str.ascii = differ(str.ascii) str.ascii ' '
    c = substr(line,1,1)                            :f(str.ascii.done)
    ident(c,nul)                                    :s(str.ascii.null)
    line any('0123456789')                          :s(str.ascii.integer)
    line any(&lcase &ucase)                         :s(str.ascii.letter)
    line ' '                                        :s(str.ascii.space)

*   Check for control character (code <=26)

    &alphabet break(c) . pos                        :f(str.ascii.other)
    pos = size(pos)
    gt(pos,26)                                      :s(str.ascii.other)
*TODO here fix g. usage
    str.ascii = str.ascii g.str.ascii.name[c] '(^'
.               substr('ABCDEFGHIJKLMNOPQRSTUVWXYZ',pos,1) ')'
    line len(1) =                                   :(str.ascii.next)

str.ascii.integer

    line span('0123456789') . text =
    str.ascii = str.ascii  text                     :(str.ascii.next)

str.ascii.letter

    line span(&lcase &ucase) . text =
    str.ascii = str.ascii  text                     :(str.ascii.next)

str.ascii.null

    str.ascii = str.ascii 'NUL'                     :(str.ascii.next)

str.ascii.other

*   Here if none of the other cases apply, so just list the str.ascii name.

    str.ascii = str.ascii setl4.strl4..str.ascii.name[c]
    line = substr(line,2)                           :(str.ascii.next)

str.ascii.space

    line span(' ') . text =

    str.ascii =  str.ascii 'SPC'
    str.ascii = gt(size(text),1) str.ascii 'SPC*' size(text)
    str.ascii = str.ascii
                                                    :(str.ascii.next)
str.ascii.done

    str.ascii = trim(str.ascii)                     :(return)

str.ascii.end

    define('str.ascii.init(init)name,val')          :(str.ascii.init.end)

*   Initialize maps for use by _str.ascii_.
*   Since space (str.ascii 32) prints as space, use the name SPC for 32.

str.ascii.init


    str.ascii.init = setl4.str.map(
.       '0:NUL 16:DLE 32:SPC 48:0 64:@ 80:P  96:` 112:p '
.       '1:SOH 17:DC1 33:!   49:1 65:A 81:Q  97:a 113:q '
.       '2:STX 18:DC2 34:"   50:2 66:B 82:R  98:b 114:r '
.       '3:ETX 19:DC3 35:#   51:3 67:C 83:S  99:c 115:s '
.       '4:EOT 20 DC4 36:$   52:4 68:D 84:T 100:d 116:t '
.       '5:ENQ 21:NAK 37:%   53:5 69:E 85:U 101:e 117:u '
.       '6:ACK 22:SYN 38:&   54:6 70:F 86:V 102:f 118:v '
.       "7:BEL 23:ETB 39:'   55:7 71:G 87:W 103:g 119:w "
.       '8:BS  24:CAN 40:(   56:8 72:H 88:X 104:h 120:x '
.       '9:HT  25:EM  41:)   57:9 73:I 89:Y 105:i 121:y '
.       '10:LF 26:SUB 42:*   58:  74:J 90:Z 106:j 122:z '
.       '11:VT 27:ESC 43:+   59:; 75:K 91:[ 107:k 123:{ '
.       '12:FF 28:FS  44:,   60:< 76:L 92:\ 108:l 124:| '
.       '13:CR 29:GS  45:-   61:= 77:M 93:] 109:m 125:} '
.       '14:SO 30:RS  46:.   62:> 78:N 94:^ 110:n 126:~ '
.       '15:SI 31:US  47:/   63:? 79:O 95:_ 111:o 127:DEL ')

    str.ascii.name = str.map(setl4.strl4.default.size)
    str.ascii.val = str.map(setl4.strl4.default.size)


    loop(str.ascii.init)

str.ascii.init.next

    ent = setl4.str.next(str.ascii.init)                  :(str.ascii.init.finis)
*   Correct entry for 0 to be NUL, the NUL character
    setl4.strl4..str.ascii.name[substr(&alphabet,+v + 1,1)] = name
    setl4.strl4..str.ascii.val[name] = +val                    :(str.ascii.init.next)



    setl4.strl4..str.ascii.name[] = 'NUL'
    setl4.strl4..str.ascii.val['NUL'] = 0
    setl4.strl4..str.ascii.name[' '] = 'SPC'
    setl4.strl4..str.ascii.val['SPC'] = 32                :(return)

str.ascii.init.end

    define('str.datename(date)s')                         :(str.datename.end)

*   Convert date to form with no spaces, just dashes, to be
*   suitable for use as part of a file name.

str.datename

    str.datename = replace(date,' :/','---')
    str.datename = substr(str.datename,12,8) '-' substr(str.datename,1,10)
                                                           :(return)
str.datename.end

    define('str.frequency(str)')                        :(str.frequency.end)

*   Return map from the characters in a str to the number of times
*   each occurs in the str.

str.frequency

    str.frequency = map.new()

str.frequency.next

    str len(1) . c =                                :f(str.frequency.end)
    setl4.str.put(str.frequency,c,setl4.str.get(str.frequency,c) + 1)   :(str.frequency.next)

str.frequency.end

    define('str.less(str,sub)before,after')         :(str.less.end)

*   _Less_ removes the first instance of each character in _sub_ from _str_,
*   where _sub_ is a substr of _str_.

str.less

    ident(str)                                      :s(return)
    str.less = str

str.less.ch
    sub len(1) . ch =                               :f(return)
    str.less break(ch) . before  ch rem . after
    str.less = before after                         :(str.less.ch)

str.less.end

    define('str.lower(s)')                          :(str.lower.end)

*   Convert argument to lower case.

str.lower

    str.lower = replace(s,&ucase,&lcase)            :(return)

str.lower.end

    define('str.out(text1,text2,text3)type1,type2')     :(str.out.end)

*   Output a line conisting of TEXT1, TEXT2 enclosed
*   in brackets, followed by TEXT3.

str.out

    output = text1 (differ(text2) '[' text2 ']', '') (differ(text3) text3, ''):(return)

str.out.end

    define('str.prefix(str,pre)word')               :(str.prefix.end)

*   Prefix takes a list of space-separated words str and str.prefixes each
*   with the str pre.

str.prefix

    str = str ' ';* so each word followed by space

str.prefix.1

    str break(' ') . word span(' ')  =              :f(return)
    add1(.str.prefixcount)
    str.prefix = append(str.prefix, pre word,'A')   :(str.prefix.1)

str.prefix.end

*   Lines
*   -----

*   Lines can be just strs or, in some cases, a line is represented by a pair:

    data('line(mark,text)')

*   where

*           _mark_ is defined by the value returned by an instance
*           of the _eval_ function ...

*           _text_ is the text of the line.

*   For example, the _reader_ function reads a file and returns a
*   sequence of _lines_.

    define('str.reader(filename,expr)line,mark')    :(str.reader.end)

*   Return a sequence of the lines in the file specified by _filename_.
*   If _expr_ is not null, then _eval_ is called just after each
*   line is read, with the variable _pair_ setl4.str to the associated pair.
*   If _eval_ fails the line is skipped.  Otherwise returns a new pair
*   to be entered in the input seq.

str.reader

    differ(filename) input(.file,g.channel.temp,filename):s(str.reader.opened)
    out('unable to open str.reader file ' filename '.') :(freturn)

str.reader.opened

    str.reader = map(1024)

str.reader.next

    setl4.str.add(map, (ident(filename) input, file)) :f(str.reader.eof)s(str.reader.next)

str.reader.eof

*   Here at end of file; close temporary file if one was needed.

    differ(filename) endfile(g.channel.temp)        :(return)

str.reader.end

    define('str.reader.str(str,delim)line')      :(str.reader.str.end)

*   Returns a sequence of the lines in _str_,
*   where the delimiter character _delim_ is used to mark
*   the end of a line. One intended use of _str.reader.str_
*   is to assist in the construction of test programs.

str.reader.str

    delim = ident(delim) '/'
    str.reader.str = setl4.str.seq()

str.reader.str.next

    str break(delim) . line delim =                 :f(return)
    add(str.reader.str,line)                     :(str.reader.str.next)

str.reader.str.end

    define('str.set(str)')              :(str.set.end)

*   Returns setl4.str of characters in str _str_.

str.set

    str.str = setl4.str(size(str))
    loop(str)

str.set.next

    next(str.set)                   :f(return)
    setl4.str.add(str.set,next(set))        :(str.set.next)

str.set.end

    define('str.slice(str,first,last)')             :(str.slice.end)

str.slice

    str.slice = substr(str,first,last)              :(return)

str.slice.end

    define('str.spaces(line)c')                     :(str.spaces.end)

*   Returns str which has ' ' in position _i_ if the _i_-th
*   characer in _str_ is a space (' '), or '*' otherwise.

str.spaces

    line len(1) . c                                 :f(return)
    str.spaces = str.spaces (ident(c,' ') ' ', '*') :(str.spaces)

str.spaces.end

*   Tokens: Lexical Scanning
*   ------------------------


*   A token is represented as an instance of the datatype _token_ as follows:

    data('token(lineno,ndx,type,text)')

*   where:
*           _lineno_        is the line number within the file;
*           _ndx_           is the index of the first character of the
*                           token in the line;
*           _type_          is the token's type, as described below; and
*           _text_          is the text of the token.

*   The type is represented by a single character, as follows:

*           'c'             comment, indicated by asterisk (*) in the first column.
*                           The text consists of the entire line.

*           'i'             integer, consisting of one or more digits ('0123456789')

*           'l'             left opener, one of '(<[{'

*           'p'             punctation, one of '.;,?!', or single quote ('),
*                           or double quote ("),

*           'o'             other printable character, one of '~@#$%^&*_-+=`'.

*            'q'            quoted str, starting witn '"', and continuing
*                           to the next instance of the opening quote character.

*           'r'             right closer, one of ')>]}'

*           's'             space, consistine of one or more spaces (spaces)

*           't'             tab character

*           'u'             unprintable character, for example control-k

*           'w'             word, consisting of one of more letters in
*                           upper or lower case or "'" or "_".

*   The longest possible str meeting the rules is used when building a token.
*   For example, 'abc' is just the word 'abc', not 'a' followed by 'bc', and so forth.

*   It is recommended that the tab character NOT be used as an abbreviation for
*   one or more spaces in the input file. If tabs are used, then _pos_ is ill-defined.
*   If tabs are not used, then _pos_ indicates the true position in the line of
*   the first character of the token, and so error messages and references to the
*   token will be exact.  For example, _pos_ could be used to indicate where to give
*   emphasis to a token by underlining it, or enclosing it in '_' to generate
*   markdown format, and so forth.

    define('str.tokens(line)type,pos,text,lineno')  :(str.tokens.end)

*   Str.tokens scans _line_ and returns a table of the str.tokens in the line.
*   The table has keys from 1..n, where _n_ is the number of str.tokens found.

*   This function is an instance of what is called a lexiical scanner, or tokenizer,
*   which is the first stage in a programming language compiler, or for any program
*   that processes text files with a specified structure.

str.tokens

    str.tokens = setl4.str.seq()
    line '*'                                        :f(str.tokens.next)
    type = 'c'
    text = line
    line =                                          :(str.tokens.new)

str.tokens.next

    line ' '                                        :s(str.tokens.space)
    line any('0123456789')                          :s(str.tokens.integer)
    line any('(<[{')                                :s(str.tokens.left)
    line any('.;,?!')                               :s(str.tokens.punctuation)
    line '"'                                        :s(str.tokens.quote)
    line any('~@#$%^&*_-+=')                                        :s(str.tokens.other)
    line any(')>]}')                                :s(str.tokens.right)
    line char(9)                                    :s(str.tokens.tab)
    line any(&lcase &ucase)                         :s(str.tokens.word)

*   Here for unprintable
                                                    :(str.tokens.unprintable)

str.tokens.integer

    type = 'i'
    line span('0123456789') . text =                :(str.tokens.new)

str.tokens.punctuation

    type = 'p'                                       :(str.tokens.character)

str.tokens.other

    type = 'o'                                      :(str.tokens.character)

*str.tokens.other

    type = 'o'                                      :(str.tokens.character)

str.tokens.quote

    type = 'q'
    line '"' break('"') . text '"' =
    text = '"' text '"'                             :(str.tokens.new)

str.tokens.right

    type = 'r'                                      :(str.tokens.character)

str.tokens.space

    type = 's'
    line span(' ')  . text =                        :(str.tokens.new)

str.tokens.tab

    type = 't'                                      :(str.tokens.character)

str.tokens.word

*FIX*
    type = 'w'
    line span(&ucase &lcase "_" "'") . text =       :(str.tokens.new)

str.tokens.character

*   Here if token is single character.

    line len(1) . text                              :(str.tokens.new)

str.tokens.new

    setl4.str.add(str.tokens,token(lineno,pos,type,text)) :(str.tokens.next)

str.tokens.end

    define('str.upper(s)')                          :(str.upper.end)

*   Convert argument to upper case.

str.upper

    str.upper = replace(s,&lcase,&ucase)            :(return)

str.upper.end

    define('str.words(str)n,tmp,w')                 :(str.words.end)

*   Return sequence consisting of the words in _str_, where the 
*   words are separated by one or more consecutive spaces and tabs.

str.words

*   Make first pass over string to get number of words, _n_.

    str = str ' '
    tmp = str

str.words.count

    tmp setl4.break.whitespace . w setl4.span.whitespace  = :f(str.words.seq)
    n = n + 1                                       :(str.words.count)

str.words.seq

    str.words = setl4.new('seq ' n)
    
str.words.next

    str setl4.break.whitespace . w setl4.span.whitespace  = :f(return)
    seq.push(str.words,w)                           :(str.words.next)

str.words.end

    define('str.writer(lines)')                    :(str.writer.end)

*   Writes the lines in the sequence _lines_ to standard output.

str.writer

    loop(lines)

str.writer.next

    output = set.next(lines)                        :f(return)s(str.writer.next)

str.writer.end

*    define('this(set)')                             :(this.end)
*
**   Returns value found in most recent call to this.
*
*this
*
*    $THIS = set.next(set)                            
*    show('this',$THIS)
*    this = .THIS
*                                                    :(nreturn)
*
*this.end

    define('visit(set,expr)')                       :(visit.end)

*   _Visit_ loops over _set and calls _eval_ with argument
*   _expr_  for each of its members.

visit

    loop(set)

visit.next

    next(set)                                       :f(return)
    eval(expr)                                      :(visit.next)

visit.end

    define('setl4.and(a,b)')                        :(setl4.and.end)

*   Returns true iff (if and only if) both arguments are true.

setl4.and

*   See if both operands are integers.

    a = integer(a) +a
    b = integer(b) +b
    setl4.and = integer(a) integer(b) (ne(a * b) TRUE, FALSE)    :s(return)

*   Here where at least one operand for 'and' is not integer, so
*   use ident/differ to evaluate.

    setl4.and = differ(a) differ(b) true            :s(return)
    setl4.and = FALSE                               :(return)

setl4.and.end

    define('setl4.arb(set)n,r')                     :(setl4.arb.end)

*   Returns arbitary (randomly selected) element of _set_.

setl4.arb

    setl4.arb = integer(set) setl4.random(+set)     :s(return)
    r = setl4.random(set.size(set))
    setl4.arb = (
.       setl4.kind(set,'int')         set.low(set) + (r - 1) * set.step(set),
.       setl4.kind(set,'map','set')   set.index(set)[r],
.       setl4.kind(set,'seq')         set.seq(set)[r],
.       setl4.kind(set,'str')         substr(set.text(set),r,1),
.       ident(datatype(set),'string') substr(set,r,1))
                                                    :(return)
setl4.arb.end

    define('setl4.concatenate(a,b)')                :(setl4.concatenate.end)

*   Concatenate argument strings.

setl4.concatenate

    setl4.concatenate = a b :(return)

setl4.concatenate.end

    define('setl4.eval(set,expr)this')               :(setl4.eval.end)

*   Evaluate _expr_ 

setl4.eval

    this = set.next(set)
    setl4.eval = eval(expr)                         :(return)

setl4.eval.end

*   According to Paul Halmos, in his book "Naive Set Theory,"
*   a major principle of set theory, often referred to by its
*   German name _Aussonderungsaxiom_, is the Axiom of Specification:

*   To every set _A_ and every condition _S(x)_ there corresponds
*   a set _B_ whose elements are exactly those elements _x_ of _A_
*   for which _S(x)_ holds.

*   In SETL4 we say that the expression '_A_ @ _S_' "filters"
*   _A_ by _S_. This can also be read as
*           "the subset of _A_ such that _S_ is true"


    define('setl4.filter(set,expr)e,this')           :(setl4.filter.end)

*   Returns the subset of set or map _set_ for which _expr_ is true.

setl4.filter

    setl.filter = set.new(set.kind(set))

    loop(set)

setl4.filter.loop

    this = next(set)                                :f(return)
    e = eval(expr)                                  :f(setl4.filter.loop)
    false(e)                                        :s(set.4.filter.loop)
    setl4.kind(set,'set') setl4.add(setl4.filter,this)  :(setl4.filter.loop)
    map.put(setl4.filter,key(this),value(this))     :(setl4.filter.loop)

setl4.filter.end

    define('setl4.kind(set,kind1,kind2,kind3,kind3,kind4,kind5)kind')     :(setl4.kind.end)

*   Tests if the kind of _set_ is one of kind1, kind2, .... Returns true if so,
*   false otherwise.

setl4.kind

    kind = ident(datatype(set),'string') true       :s(return)
    kind = set.kind(set)
    setl4.kind = differ(kind1) ident(kind,kind1) TRUE       :s(return)
    setl4.kind = differ(kind2) ident(kind,kind2) TRUE       :s(return)
    setl4.kind = differ(kind3) ident(kind,kind3) TRUE       :s(return)
    setl4.kind = differ(kind4) ident(kind,kind4) TRUE       :s(return)
    setl4.kind = differ(kind5) ident(kind,kind5) TRUE       :s(return)
    setl4.kind = FALSE                                      :(return) 

setl4.kind.end

    define('setl4.member(elem,set)kind,entry,key,value)') :(setl4.member.end)

*   Tests if _elem_ is 'elem' of _set, where:

*   _elem_ is element of 'int' if in range, and

*   _elem_ is element of 'int' if in range, and
*   meets requirement if 'step' in nonzero

*   _elem_ is element of map _set if _map_ has entry _elem_.

*   _elem_ is element of sequence _set if _set has entry _elem)

*   _elem_ is element of set _set if _set.in(elem,set)_ is true.

*   _elem_ is element of string _set if _set contains instance of _elem.

setl4.member

    setl4.member = false
    kind = kind(set)
    setl4.member = false
    setl4.kind(kind,'int')                                  :s(setl4.member.int)
    setl4.kind(kind,'map')                                  :s(setl4.member.map)
    setl4.kind(kind,'seq')                                  :s(setl4.member.seq)
    setl4.kind(kind,'set')                                  :s(setl4.member.set)
    setl4.kind(kind,'str')                                  :s(setl4.member.str)
    setl4.kind(kind,'string')                               :s(setl4.member.string)
    setl4.kind(kind,'map')                                  :s(setl4.member.map)
    output = 'setl4.member wrong kind ' kind ' , quitting' :(end)

setl4.member.int

    setl4.member = lt(elem,set.low(set)) false              :s(return)
    setl4.member = gt(elem,set.low(set)) false              :s(return)
    setl4.member = (eq(remdr(elem - set.low(set),set.step(set))) TRUE, FALSE):(return)

setl.4.member.map

    key = key(elem)

*   Cannot be member if no entry in _key_ table.

    ident(set.key(set)[key])                        :s(return)

*   There is entry for _key_, see if it has right value.

    ident(set.index[set.key(set)[key]],value)       :f(return)
    setl4.member = TRUE                             :(return)

setl.4.member.seq

    output = 'setl4.member seq not yet done' :(end)
    ident(set.array[key,1])                         :s(return)

setl4.elem.set

    setl4.member = (differ(set.key(set)[elem]) TRUE, FALSE) :(return)

setl.4.member.str

    set break(elem)                                 :f(return)
    set4.member = TRUE                              :(return)

setl.4.member.string

    string break(elem)                              :f(return)
    setl4.member = TRUE                             :(return)

setl4.member.end


    define('setl4.new(init)kind,i,len,n,key,seq,val)')   :(setl4.new.end)

*   Construct new set with initial values determined by string _init_.

setl4.new

    kind = substr(init,1,3)
    init = substr(init,4)

*   Strip leading spaces from remaining part of _init_.

    init span(' ') =
    ne(size(kind),3) error('setl4.new missing kind specification')
    setl4.kind(kind,'int','map','seq','set','str')         :s(setl4.new.init)
    error('bad kind to setl4.new ' kind )

    ident(kind,'int')                               :s(setl4.new.map)

setl4.new.init

*   Remove kind specification and following space from _init_

*   Create new instance of data type 'set'.

    setl4.new = set(kind,table(setl4.config.size), table(setl4.config.size))

*   Branch on set kind to finish initialization.

        :($('setl4.new.' kind))
    ident(kind,'int')                               :s(setl4.new.int)
    ident(kind,'map')                               :s(setl4.new.map)
    ident(kind,'seq')                               :s(setl4.new.seq)
    ident(kind,'set')                               :s(setl4.new.new)
    ident(kind,'str')                               :s(setl4.new.str)
    error('bad kind to setl4.new ' kind)

setl4.new.int

    ident(init) error('setl4.new initialization information needed')
    setl4.new = set('int')
    set.step(setl4.new) = 1
    seq = str.words(init)

*   Ignore extra arguments to int constructor.

    set.size(seq) = gt(set.size(seq),3) 3
    eq(set.size(seq),1)                             :s(setl4.new.int.1)
    eq(set.size(seq),2)                             :s(setl4.new.int.2)
    eq(set.size(seq),3)                             :s(setl4.new.int.3)

setl4.new.int.1

*   If one argument, low is one, high is the argument.

    set.low(setl4.new) =  1
    set.high(setl4.new) = seq.get(seq,1)            
    set.step(set) = 1
                                                    :(setl4.new.int.done)

setl4.new.int.2

*   If two arguments, low is low, high is second.

    set.low(setl4.new) =  +seq.get(seq,1)
    set.high(setl4.new) = +seq.get(seq,2)             
    set.step(set) = 1
                                                    :(setl4.new.int.done)

setl4.new.int.3

*   If three arguments, low is first, high is second, step is third.

    set.low(setl4.new) =  +seq.get(seq,1)
    set.high(setl4.new) = +seq.get(seq,2)             
    set.step(setl4.new) = +seq.get(seq,3)            
                                                    :(setl4.new.int.done)

setl4.new.int.done

*   Set _next_ so that  incrmenting it on first call to _setl4.next_  
*   will point to first element in set

    set.next(setl4.new) = set.low(setl4.new) - set.step(setl4.new) 
                                                    :(return)
setl4.new.map

*   If present, _init_ is a list consisting of a list of key/value pairs,
*   with a colon (:) between the key and value.

    ident(init)                                     :s(return)
    init = init ' '

setl4.new.map.next

    init break(':') . key ':' break(' ') . val span(' ') =  :f(return)
    map.put(setl4.new.map,key,val)                  :(setl4.new.map.next)

setl4.new.seq

    set.index(setl4.new) =
    set.key(setl4.new) =                        
    set.seq(setl4.new) = array(setl4.config.size)
                                                    :(return)

setl4.new.set

    ident(init)                                     :s(return)
    init = init ' '

setl4.new.set.init

    init break(' ') . element ' ' =                 :f(return)
    set.add(setl4.new,element)                      :(setl4.new.set.init)

setl4.new.str

    str.text(setl4.new) = init                      :(return)

setl4.new.str.init

    init len(1) . key ' ' =                         :f(return)
    setl.add(setl4.new,key)                         :(setl4.new.str.init)

setl4.new.end

    define('setl4.next(set)kind,next')              :(setl4.next.end)

*   Advance iteration by setting field _set.next_.
*   Fail if no more elements remain.


setl4.next

    differ(kind = set.kind(set),'int')              :s(setl4.next.notint)

*    str.out('set4.next enter int')
*   Here to find next element in set of type _int_.

    next = set.next(set) = set.next(set) + set.step(set)
    gt(next,set.high(set))                          :s(freturn)
    setl4.next = next                       
                                                    :(return)

setl4.next.notint

    next = set.next(set) = set.next(set) + 1
    le(next,set.size(set))                          :f(freturn)
    set.next(set) = 
.       (
.       setl4.kind(kind,'int')          next,
.       setl4.kind(kind,'map','set')    set.index(set)[next],
.       setl4.kind(kind,'seq')          set.seq[next],
.       setl4.kind(kind,'str')          substr(set.text(set),next,1)
.       ident(datatype(set),'string')   substr(set,next,1)
.       )
    $THIS = next
    setl4.next = set.next(set) = next 
                                                    :(return)

setl4.next.end

    define('setl4.not(expr)')                       :(setl4.not.end)

*   Returns not of boolean expression.

setl4.not

    expr = integer(expr) +expr
    setl4.not = integer(expr) (ne(expr) FALSE, TRUE) :s(return)
    setl4.not = (differ(expr) FALSE, TRUE)          :(return)

setl4.not.end

    define('setl4.or(a,b)')                         :(setl4.or.end)

*   Returns true iff (if and only if) at least one argument is true.

setl4.or
    a = integer(a) +a
    b = integer(b) +b
    setl4.or = integer(a) ne(a) TRUE                :s(return)
    setl4.or = integer(b) ne(b) TRUE                :s(return)

*   Here if operands not both integers, so use ident/differ.

    setl4.or = (differ(a) TRUE, differ(b) TRUE, FALSE)    :(return)

setl4.or.end

    define('error(str)')                            :(error.end)

*   Report cause of error and quit execution

error

    &dump = 2
    output = 'Fatal error: ' str                    :(end)

error.end

    define('setl4.random(n)')                       :(setl4.random.end)

*   Return integer uniformly distributed in 1,2,...,n.
*   If n=0 returns real uniformly distributed in the interval [0,1].
*   The Algorithm is based on that in section 16.1 of "Algorithms in SNOBOL4,"
*   James F. Gimpel, John Wiley and Sons, 1976.

*RANDOM*
setl4.random

    setl4.random_var = remdr(setl4.random_var * 4676, 414971)
    setl4.random  = setl4.random_var / 414971.0
    setl4.random = ne(n) convert(setl4.random * n,'integer') + 1
                                                    :(return)
setl4.random.end

    define('setl4.random.seed()s,c')                :(setl4.random.seed.end)

*   Compute seed for setl4.random number generator from date and time.

*RANDOMSEED*
setl4.random.seed
    setl4.random_var =
    s = g.date
    s = replace(s,'/:-','   ')

*   Get all the digits in s.

setl4.random.seed.loop

    s len(1) . c =                                  :f(setl4.random.seed.done)
    ident(c,' ')                                    :s(setl4.random.seed.loop)
    setl4.random_var = setl4.random_var c           :(setl4.random.seed.loop)

setl4.random.seed.done

*   Reverse the seed so digits depending on time come first.

    setl4.random_var = +reverse(setl4.random_var    )
                                                    :(return)

setl4.random.seed.end

    define('setl4.seq.room(seq)len')                :(setl4.seq.room.end)

*   Ensures that sequence _seq_ has room for a new entry, expanding it if necessary.

setl4.seq.room

    len = prototype(set.seq(seq))
    le(set.size(seq),len)                           :s(return)

*   Here to extend length of array by fifty per cent.

    setl4.seq.extend(seq,(3 * len) / 2)             :(return)

setl4.seq.room.end
    
    define('setl4.show(set,label)')                 :(setl4.show.end)

*   Show the fields of an instance of _set_.

setl4.show

                               str.out('{')
    differ(label)              str.out('show: ' str.upper(label))
                               str.out('kind',set.kind(set))
    ne(set.size(set))          str.out('size',set.size(set))
    differ(set.index(set))     str.out('size(set.index(set))', size(set.index(set)))
    differ(set.key(set))       str.out('size(set.key(set))', size(set.key(set)))
    differ(set.next(set))      str.out('next',set.next(set))
    ne(set.low(set))           str.out('low',set.low(set))
    ne(set.step(set))          str.out('high',set.high(set))
    ne(set.high(set))          str.out('step',set.low(set))
    differ(set.text(set))      str.out('text',set.text(set))
    differ(set.seq(set))       str.out('seq',prototype(set.seq(set)))
                               str.out('}')

                                                    :(return)
setl4.show.end

    define('setl4.size(set)')                       :(setl4.size.end)

*   Return size of operand.

setl4.size

    setl4.size = ident(datatype(set),'string') size(set)    :s(return)
    kind = setl4.kind(set)
    setl4.size = setl4.kind(kind,'int')
.               set.high(set) - set.low(set) + 1    :s(return)
    setl4.size = set.size(set)                      :(return)

setl4.size.end

    define('setl4.split(str)word')                  :(setl4.split.end)

*   Returns sequence of the words in stirng _str_.
*   Words are separated by whitespace: one of more consecuture spaces
*   or tabs.

setl4.split

    setl4.split = setl4.new('seq')
    line =  line ' '

setl4.split.next

    line break(' ') . word ' ' =                    :f(return)
    set.add(setl4.split,word)                       :(setl4.split.next)

setl4.split.end

    define('setl4.traceoff()')                      :(setl4.traceoff.end)

*   Initiate tracing.

setl4.traceoff
    &fsetl4.trace = &setl4.trace =

    g.scoring = g.tracing = 0
    out('stop TRACING ')

setl4.traceoff.end

    define('setl4.traceon()')                       :(setl4.traceon.end)

*   Initiate tracing.

*TRACEON*
setl4.traceon

    out('start TRACING')
*   &fsetl4.trace = &setl4.trace = 1500000
    g.scoring = g.tracing = 1
                                                    :(return)
setl4.traceon.end

*HERE*
 :(bypass)
*   Use some of the undefined SPITBOL operators for SETL4 functions.

*   Characters available for use by 'opsyn' to associate the character
*   with a function.

*   binary  &  @  #  %  ~
*   unary:  !  %  /  #  =  | /

*   define('setl4.op(ch,proc,n)')           :(setl4.op.end)
*
**  Use _opsyn_ to define SETL4 operator.
*
*setl4.op
*
*   opsyn(ch,proc,n)                        :s(return)
*   error('fatal problem with opsyn for ' ch ')
*
*setl4.op.end
*   SETL4 unary operators:

    opsyn('=','setl4.arb',   1)
    opsyn('|','setl4.new',   1)
    opsyn('!','setl4.not',   1)
    opsyn('#','setl4.size',  1)
    opsyn('/','setl4.split', 1)



    opsyn('&','setl4.and',   2)
    opsyn('@','setl4.eval',  2)
    opsyn('#','setl4.filter',2)
    opsyn('~','setl4.member',2)
*    opsyn('^','setl4.or',    2)

*   Global variables
*   ----------------

*   SETL4 binary operators:
*    setl4.ascii.name = setl4.new('map')
*    setl4.ascii.val =  setl4.new('map')
*    setl4.ascii.initialized = false

*   Here endeth the SETL4 code.
*   May you fare well using it.
bypass
 output = 'THIS is |' THIS '|'

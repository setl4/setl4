

*   Copyright 2017, David Shields
*   Licensed under the MIT license.

-include "../setl4.stl"

    &stlimit = 25000

    define('product(sets,strings)set.in,set.out,this,i,seq,set.i,dt,t'):(product.end)

*   _Product_ returns the Cartesian product of a sequence of strings or sets.

*   Argument _strings_ if not null then _sets_ is a sequence of strings.
*
*   Compute the Cartesian product as follows.
*   If the input is the empty set, return the empty set.
*   If there is just one input, return a copy of it.

*   Otherwise compute the product in steps, with the output
*   from one step serving as input to the next. For each element
*   in the first set, build a sequence consisting of the element
*   and add it to the output set. For each element in the remaining sets,
*   iterate the input set. Get the existing sequence of the element,
*   add the element from the remaining set to the sequence, and continue.

*   Return as the product the last output set computed.

product

    product = new('set')
    set.out = new('set')

*   The product of an empty set is the empty set.

    eq(set.size(sets))                                 :s(return)

*   The product of a single set is the set itself.

*   Loop over the input sets

    loop(sets,.sets.this)

*   Initialize set.in from the first set.

    next(sets)
    set.out = copy(sets.this)

product.next

    next(sets)                                         :f(product.done)
    set.in = set.out
    set.out = product1(set.in,sets.this,strings)       :(product.next)

product.done

    product = set.out                                  :(return)

product.end

    define('product1(in,set,strings)in.this,set.out,s,seq,set.this'):(product1.end)

product1

    set.out = new('set')

*   Loop over input set.

    loop(in,.in.this)

product1.set.next

    next(in)                                           :f(product1.done)

*   Here with new element in _set_. Generate a new element in _out_ using _in_ and this element.

    loop(set,.set.this)

product1.next

    next(set)                                          :f(product1.set.next)

    output  = differ(strings) '[' join(in.this,set.this) ']'
    differ(strings) add(set.out,join(in.this,convert(set.this,'string')))
    ident(strings)  add(set.out,join(in.this,set.this))
                                                       :(product1.next)

product1.done

    product1 = set.out                                 :(return)

product1.end

    define('test(sets,strings)')                               :(test.end)

test

    out()
    out('enter test')
    show(sets)
    p = product(sets,strings)
    out('computed')
    show(p)
    out()
    out()
                                                       :(return)
test.end

    s1 = new('set a b')
    s2 = new('set 1 2 3')
    q1 = new('seq')
    push(q1,s1)
    push(q1,s2)
    test(q1,'TRUE')

    s1 = new('set 10 20')
    s2 = new('set I V C')
    q1 = new('seq')
    add(q1,s1)
    add(q1,s2)
    test(q1)
    out('end test')

end


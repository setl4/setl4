

*   Copyright 2017, David Shields
*   Licensed under the MIT license.

-include "../setl4.stl"

    &stlimit = 25000

    define('product(sets,strings)set.in,set.out,this,i,seq,set.i,dt,t'):(product.end)

*   _Product_ returns the Cartesian product of a sequence of strings or sets.

*   Argument _strings_ if not null then _sets_ is a sequence of strings.
*
*   Compute the Cartesian product as follows.
*   If the input is the empty set, return the empty set.
*   If there is just one input, return a copy of it.

*   Otherwise compute the product in steps, with the output
*   from one step serving as input to the next. For each element
*   in the first set, build a sequence consisting of the element
*   and add it to the output set. For each element in the remaining sets,
*   iterate the input set. Get the existing sequence of the element,
*   add the element from the remaining set to the sequence, and continue.

*   Return as the product the last output set computed.

product

    out('enter product')
    show(sets)

    product = new('set')
    set.out = new('set')

*   The product of an empty set is the empty set.

    eq(set.size(sets))                                 :s(return)

*   The product of a single set is the set itself.

*   Loop over the input sets

    loop(sets,.sets.this)

*   Initialize set.in from the first set.

    next(sets)
    set.out = copy(sets.this)
    out('initial set.out')
    show(set.out)

product.next

    next(sets)                                         :f(product.done)
    set.in = set.out
    set.out = product1(set.in,sets.this,strings)       :(product.next)

product.done

    product = set.out                                  :(return)

product.end

    define('product1(in,set,strings)in.this,set.out,s,seq,set.this'):(product1.end)

product1

    Out('ENTER PRODUCT1')
    Out('dt in',datatype(in))
    Out('dt set',datatype(set))

    set.out = new('set')

*   Loop over input set.

    loop(in,.in.this)

product1.set.next

    next(in)                                           :f(product1.done)

*   Here with new element in _set_. Generate a new element in _out_ using _in_ and this element.

    loop(set,.set.this)

product1.next

    next(set)                                          :f(product1.set.next)

    out('dt in.this',datatype(in.this))
    out('dt set.this',datatype(set.this))
    output  = differ(strings) '[' join(in.this,set.this) ']'
    differ(strings) add(set.out,join(in.this,convert(set.this,'string')))
    ident(strings)  add(set.out,join(in.this,set.this))
                                                       :(product1.next)

product1.done

    Out('EXIT PRODUCT1')
    product1 = set.out                                 :(return)

product1.end

    define('test(sets,strings)')                               :(test.end)

test

    out()
    out('enter test')
    show(sets)
    p = product(sets,strings)
    out('computed')
    show(p)
    out()
    out()
                                                       :(return)
test.end

    s1 = new("set a b")
    s2 = new("set 1 2 3")
    seq = new("seq")
    push(seq,s1)
    push(seq,s2)
    out('showing seq')
    show(seq)
    out('seq shown')
    test(seq,"TRUE")

    out('testing sequence of sets')
    s1 = new("set 10 20")
    s2 = new("set I V C")
    seq = new("seq")
    push(seq,s1)
    push(seq,s2)
*   out('showing top')
*   show(top(seq))
    out('showing seq')
    setl4.show(seq)
    show(seq)
    p = product(seq)
    out('computed')
    show(p)
end
    
*   test(seq)
    out("end test")

end


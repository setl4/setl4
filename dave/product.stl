
*   Copyright 2017, David Shields
*   Licensed under the MIT license.

-include "../setl4.stl"

    define('product(sets,strings)set.in,set.out,this,i,seq,set.i,dt,t') :(product.end)

*   _Product_ returns the Cartesian product of a sequence of strings or sets.

*   Argument _strings_ if not null then _sets_ is a sequence of strings.
*
*   Compute the Cartesian product as follows.
*   If the input is the empty set, return the empty set.
*   If there is just one input, return a copy of it.

*   Otherwise compute the product in steps, with the output
*   from one step serving as input to the next.
*   For each element in the first set, build a sequence consisting
*   of the element and add it to the output set.
*   For each element in the remaining sets, iterate the input set.
*   Get the existing sequence of the element, add the element from
*   the remaining set to the sequence, and continue.

*   Return as the product the last output set computed.

product

    out('enter product')
    product = new('set')
    set.out = new('set')

*   The product of an empty set is the empty set.

    eq(set.size(sets))                              :s(return)

*   The product of a single set is the set itself.

    product = eq(set.size(sets),1) copy(sets)   :s(return)

*   Loop over the input sets

    loop(sets,.sets.this)

*   Initialize set.in from the first set.

    set.in = copy(sets.this)              

product.next.sets

    out('product.next.set')
    next(sets)                                  :f(product.next.done)
    show(sets.this)
    out()

    set.out = new('set')

    loop(sets.this,.set.this)

product.next.set

    next(sets.this)                             :f(product.next.done)
    out('set.this dt',datatype(set.this))
    out('next.set')
    show(set.this)
    product1(set.out,set.in,set.this,strings)  :(product.next.set)

product.next.done

    out('product.next.done')
    product = set.out
    show(product)
    out('product.next.done updated set.in')
    set.in = set.out                    
    show(set.in)
                                            :(product.next.sets)

product.end
    
    define('product1(out,in,set,strings)s,seq')                     :(product1.end)

product1
 
    loop(set,.set.this)

product1.set.next

    next(set)                           :f(return)

    out('product1.set.next')
    show(set.this)

    loop(in,in.this)

product1.next

    next(in)                            :f(product1.set.next)
    out('product1.next')
    show(in.this)
    differ(strings) add(out,join(in.this,convert(set.this,'string')))
    ident(strings)  add(out,join(in.this,set.this))
    out('updated out')
    show(out)
                                        :(product1.next)

product1.end

    define('test(sets)')                    :(test.end)

test

    out()
    out('enter test')
    out('number of sets',set.size(sets))
    show(sets)
    p = product(sets,'TRUE')
    show(p)
    out()
    out()
                                            :(return)
test.end

    s1 = new('set a b')
    s2 = new('set 1 2 3')
    q1 = new('seq')
    push(q1,s1)
    push(q1,s2)
    test(q1)
    out('end test')

end
 

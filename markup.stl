*       Copyright 2017 Dave Shields

*       The software is licensed under the MIT license, a copy of which can be
*       found in the file LICENSE>


-include "setl4.stl"
-include "util.stl"

*       Translate comments, translating words enclosed in underscores,
*       or in upper case, to markdown italic format. 

*       Translate define() statements to show function name and arguments in 
*       markdown format

*       Utility functions.

        define('empty(line)')                           :(empty.end)

*       Test if line is empty (null or all blanks).

*EMPTY*
empty

*       Note that, in many cases, the first character in line is not null,
*	so first test so see if that is the case for the current line.

        ident(line)                                     :s(return)
        differ(substr(line,1,1),' ')                    :s(freturn)
        line span(whitespace) =
        ident(line)                                     :s(return)f(freturn)

empty.end

*       Main program

        define('main()i,line,last,name,p,rest,w,word')             :(main.end)

*MAIN*
main

*       Main program.

        &anchor = &trim = 1

	&dump = 3
	tab = char(9)
	whitespace = ' ' tab

*       _g.lines_ is a table that holds the lines read.
*	_g.lines.n_ is the number of lines in _g.lines_.
*	_g.pos_ is the index in _g.lines_ of the current line.

        g.lines = table()
	g.lines.n = g.lines.pos = 0

	output = 'start reader'
	read()
	output = 'end reader'
 	read()
	terminal = g.lines.n ' lines read.'

loop.l

        le(i = i + 1, g.lines.n)			:f(return)
        line = line()
	output = 'scanning [' line ']'
        words = words(line)
        w = 0
loop.w

        p = words[w = w + 1,1]				:f(loop.l)
        word = words[w,2]
        output = lpad(w,3) ' ' word                     :(loop.w)

        
main.copy

*       Only output first in a run of blank lines.

        line = line()					:f(return)
        empty(line) empty(last)                         :s(main.next)
        output = line
        last = line

main.next
        line = line()                                  	:f(main.done)
        ident(line)                                     :s(main.copy)
        line '*'                                        :s(main.comment)
        line span(' ') "define('"  =            :f(main.next)
        line "define('" rem . rest = rest
        line break('(') . name '()' rem . rest = tab name '()'  :s(main.copy)
        line break('(') . name 
.       '(' bal . args rem . rest = tab name '(' args ')' :(main.copy)

main.comment

        line '*' =
        line tab =

main.comment.word

        oline = line
        line breakx(&ucase) . first span(&ucase) . word rem . rest =
.               '*' first '_' lcase(word) '_' rest      :f(main.copy)
        line = eq(size(word),1) oline                   :s(main.copy)f(main.comment.word)

main.done
							:(return)
main.end

	main()
*       
*END*
end

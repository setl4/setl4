*   Copyright 2017, David Shields
*   Licensed under the MIT license.

*TODO - need separate out iterator from set data structure. May have multiple loops over same set at onece.
*TODO - need equal for general equality test on sets, maps, etc.


*   Utility Functions
*   ---------------

*   In addition to the set-theoretic functions defined in _setl4.stl_, SETL4 provides
*   the following utility functions.

*   even(n)                     Tests if _n_ is even
*   factorial(n)                Returns n!  = n * (n -1) * ... * 1
*   multiple(n,m)               Tests if _n_ is a multiple of _m_
*   number(n)                   Returns _n_ as one or two words if possible, else returns _n_
*   odd(n)                      Tests if _n_ is odd
*   prime(n)                    Tests if _n_ is prime
*   square.root(n)              Returns integer square root on _n_
*   thousands(s)
*   append(str,w,ch)            Appends _ch_ (or space if _ch_ is null) to _str_, then appends _w_
*   ascii(line)
*   datename(date)              Returns string based on current time suitable for use as filename
*   digits()                    Returns list of digits: '0 1 2 .. 9'
*   frequency(str)              Returns map giving frequency of characters in _str_
*   letters()                   Returns list of letters : 'a b c ... z A B ... Z''
*   less(str,sub)               Removes the first instance of each character in _sub_ from _str_,
*   s.lletters()                    Returns list of lower case letters : 'a b c ... z'
*   lower(s)                    Returns _s_ with upper case letters replaced by lower case equivalent
*   notany(a,b)                 Tests if first character in _a_ is not in _b_
*   out(text1,text2,text3)      Outputs _text1_, then _text2_ enclosed in '[]' if _text2_ not null,
*                                   then _text3_ if _text3_ is not null.
*   prefix(str,pre)             Takes a list of space-separated words in _str_ and prefixes each
*                                   with the string _pre_
*   reader(filename,expr)       Returns sequence of lines in file _filename_, using _expr_ (if given)
*                                   to filter out lines to be ignored.
*   readerstring(str,delim)    Like _reader(filename..)_ but reads lines from a string with lines
*                                   separated by delimiter _delim_
*   slice(str,first,last)       Same as SPITBOL _substr(str,first,last)_
*   tokens(line)                Returns sequence of the tokens in _line_
*   uletters()                  Returns list of upper case letters : 'A B C ... Z''
*   upper(s)                    Returns _s_ with lower case letters replaced by upper case equivalent
*   writer(lines)               Writes sequence _lines_ to standard output.

    define('cardinal(n,word)')           :(cardinal.end)
*   If N is one, returns 'one' followed by WORD.
*   Otherwise returns NUMBER(N) followed by WORD and 'S'.


cardinal

    cardinal = (eq(n,1) 'one ' word, number(n) ' '  word 's'):(return)

cardinal.end

    define('even(n)')                           :(even.end)

*   Returns TRUE iff _n_ is even.

even

    even = (eq(remdr(n,2)) TRUE,FALSE)          :(even.end)

even.end

    define('factorial(n)')                      :(factorial.end)

*   Returns n! = n*(n-1)*(n-2) ... 1

factorial

    factorial = (eq(n,1) 1, n * factorial(n -1))    :(return)

factorial.end

    define('multiple(n,m)')                      :(multiple.end)

*   Tests if _n_ is a multiple of _m_.

multiple

    multiple = (eq(remdr(n,m)) TRUE, FALSE)      :(return)

multiple.end

    define('number(n)')                          :(number.end)

*  If _n_ can be represented as a string of one or two words then return that string. Otherwise return _n_.

number
    error('number not implemented, quitting.' )
    number = eq(n) 'zero'                       :s(return)
    number = g.numbers[n]
    differ(number)                              :s(return)
    number = n                                  :(return)

number.end

    define('odd(n)')                            :(odd.end)

*   Returns true iff _n_ is odd.

odd

    odd = (ne(remdr(n,2)) TRUE,FALSE)           :(return)

odd.end
    define('prime(n)')                          :(prime.end)

*   Tests if _n_ is a prime integer

prime
*    set = new('iter 2 ' (convert(sqrt(n),'integer') + 1))
    show(set)
 :(end)
*    prime = not(exists(new('iter 2 ' square.root(n)),multiple(n,this))) :(return)

    :(return)
prime.end

    define('square.root(n)')                    :(square.root.end)

*   Returns square root of integer _n_, rounded up.
 :(end)

square.root

    square.root = convert(sqrt(n),'integer') + 1 :(return)

square.root.end

    define('thousands(s)n')                     :(thousands.end)

*   Format s with comma's every three digits from right.

thousands

    n = size(s)
    thousands = le(n,3) s                       :s(return)
    thousands = thousands(substr(s,1,n - 3)) ',' substr(s, n - 2, 3):(return)

thousands.end


*   Strings (str's)
*   ---------------

*   SETL4 provides additional operations, based on set theory,
*    on strings in the form of "str's".

    define('append(str,w,ch)')                  :(append.end)

*   _append_ appends _ch_, or ' ' if _ch_ is null, to _str_
*   and then appends _w_.

append

    append = str (ident(str) w, (ident(ch) ' ' , ch) w):(return)

append.end

    define('ascii(line)c,n,name,nul,num,pos')   :(ascii.end)

*   Return the text of line with every ascii character identified.

ascii

    true(ascii.initialized)                   :s(ascii.initialized)

*   Here to initialize the needed maps.
    
    ascii.init()
    ascii.initialized = true;

ascii.initialized

    nul = substr(&alphabet,1,1)

ascii.next

*   Add space after previous character if result not null.

    ascii = differ(ascii) ascii ' '
    c = substr(line,1,1)                            :f(ascii.done)
    ident(c,nul)                                    :s(ascii.null)
    line any('0123456789')                          :s(ascii.integer)
    line any(&lcase &ucase)                         :s(asciiletter)
    line ' '                                        :s(ascii.space)

*   Check for control character (code <=26)

    &alphabet break(c) . pos                        :f(ascii.other)
    pos = size(pos)
    gt(pos,26)                                      :s(ascii.other)
*TODO here fix g. usage
    ascii = ascii g.ascii.name[c] '(^'
               substr('ABCDEFGHIJKLMNOPQRSTUVWXYZ',pos,1) ')'
    line len(1) =                                   :(ascii.next)

ascii.integer

    line span('0123456789') . text =
    ascii = ascii  text                     :(ascii.next)

asciiletter

    line span(&lcase &ucase) . text =
    ascii = ascii  text                     :(ascii.next)

ascii.null

    ascii = ascii 'NUL'                     :(ascii.next)

ascii.other

*   Here if none of the other cases apply, so just list the ascii name.

    ascii = ascii ascii.name[c]
    line = substr(line,2)                           :(ascii.next)

ascii.space

    line span(' ') . text =

    ascii =  ascii 'SPC'
    ascii = gt(size(text),1) ascii 'SPC*' size(text)
    ascii = ascii
                                                    :(ascii.next)
ascii.done

    ascii = trim(ascii)                     :(return)

ascii.end

    define('ascii.init(init)entry,name,value') :(ascii.init.end)

*   Initialize maps for use by _ascii_.
*   Since space (ascii 32) prints as space, use the name SPC for 32.

ascii.init


    ascii.init = new('map '
.      '0:NUL 16:DLE 32:SPC 48:0 64:@ 80:P  96:` 112:p '
.      '1:SOH 17:DC1 33:!   49:1 65:A 81:Q  97:a 113:q '
.      '2:STX 18:DC2 34:"   50:2 66:B 82:R  98:b 114:r '
.      '3:ETX 19:DC3 35:#   51:3 67:C 83:S  99:c 115:s '
.      '4:EOT 20 DC4 36:$   52:4 68:D 84:T 100:d 116:t '
.      '5:ENQ 21:NAK 37:%   53:5 69:E 85:U 101:e 117:u '
.      '6:ACK 22:SYN 38:&   54:6 70:F 86:V 102:f 118:v '
.      "7:BEL 23:ETB 39:'   55:7 71:G 87:W 103:g 119:w "
.      '8:BS  24:CAN 40:(   56:8 72:H 88:X 104:h 120:x '
.      '9:HT  25:EM  41:)   57:9 73:I 89:Y 105:i 121:y '
.      '10:LF 26:SUB 42:*   58:  74:J 90:Z 106:j 122:z '
.      '11:VT 27:ESC 43:+   59:; 75:K 91:[ 107:k 123:{ '
.      '12:FF 28:FS  44:,   60:< 76:L 92:\ 108:l 124:| '
.      '13:CR 29:GS  45:-   61:= 77:M 93:] 109:m 125:} '
.      '14:SO 30:RS  46:.   62:> 78:N 94:^ 110:n 126:~ '
.      '15:SI 31:US  47:/   63:? 79:O 95:_ 111:o 127:DEL ')

    ascii.name = .map(efault.size)
    ascii.value = .map(efault.size)
    loop(ascii.init)

ascii.init.next

    entry = setl4.l.next(ascii.init)                  :(ascii.init.finis)
*   Correct entry for 0 to be NUL, the NUL character
    ascii.name[substr(&alphabet,+v + 1,1)] = name
    ascii.value[name] = +value                  :(ascii.init.next)
    ascii.name[] = 'NUL'
    ascii.value['NUL'] = 0
    ascii.name[' '] = 'SPC'
    ascii.value['SPC'] = 32                     :(return)

ascii.init.end

    define('datename(date)s')                  :(datename.end)

*   Convert date to form with no spaces, just dashes, to be
*   suitable for use as part of a file name.

datename

    datename = replace(date,' :/','---')
    datename = substr(datename,12,8) '-' substr(datename,1,10)
                                                   :(return)
datename.end

    define('digits()str,ch')                   :(digits.end)

*   Return string consisting of the digits 0 .. 9 separated by a space.

digits

    digits = 
    str = '0123456789'
    
digits.next

    str len(1) . ch =                               :f(return)
    digits = append(digits,ch)          :(digits.next)

digits.end

    define('frequency(str)')                    :(frequency.end)

*   Return map from the characters in a str to the number of times
*   each occurs in the .

frequency

    frequency = map.new()

frequency.next

    str len(1) . c =                                :f(frequency.end)
    setl4..put(frequency,c,setl4..get(frequency,c) + 1)   :(frequency.next)

frequency.end

    define('less(str,sub)before,after')         :(less.end)

*   _Less_ removes the first instance of each character in _sub_ from _str_,
*   where _sub_ is a substr of _str_.

less

    ident(str)                                      :s(return)
    less = str

less.ch
    sub len(1) . ch =                               :f(return)
    less break(ch) . before  ch rem . after
    less = before after                         :(less.ch)

less.end

    define('s.lletters()str,ch')                  :(s.lletters.end)

*   Return string consisting of the lower case letters separated by a space.

s.lletters

    s.lletters = 
    str = &lcase
    
s.lletterl.next

    str len(1) . ch =                              :f(return)
    s.lletters = append(s.lletters,ch)     :(s.lletterl.next)

s.lletters.end

    define('letters()str,ch')                  :(letters.end)

*   Return string consisting of the lower case letters separated by a space.

letters

    letters = 
    str = &lcase &ucase
    
letterl.next

    str len(1) . ch =                              :f(return)
    letters = append(letters,ch)       :(letterl.next)

letters.end

    define('lower(s)')                          :(lower.end)

*   Convert argument to lower case.

lower

    lower = replace(s,&ucase,&lcase)            :(return)

lower.end

    define('prefix(str,pre)word')               :(prefix.end)

*   Prefix takes a list of space-separated words str and prefixes each
*   with the str pre.

prefix

    str = str ' ';* so each word followed by space

prefix.1

    str break(' ') . word span(' ')  =              :f(return)
    add1(.prefixcount)
    prefix = append(prefix, pre word,'A')   :(prefix.1)

prefix.end

    define('uletters()str,ch')                  :(uletters.end)

*   Return string consisting of the upper case letters separated by a space.

uletters

    uletters = 
    str = &ucase
    
uletterl.next

    str len(1) . ch =                                :f(return)
    uletters = append(uletters,ch)       :(uletterl.next)

uletters.end


*   Lines
*   -----

*   Lines can be just strs or, in some cases, a line is represented by a pair:

    data('line(mark,text)')

*   where

*           _mark_ is defined by the value returned by an instance
*           of the _eval_ function ...

*           _text_ is the text of the line.

*   For example, the _reader_ function reads a file and returns a
*   sequence of _lines_.

    define('reader(filename,expr)line,mark')    :(reader.end)

*   Return a sequence of the lines in the file specified by _filename_.
*   If _expr_ is not null, then _eval_ is called just after each
*   line is read, with the variable _pair_ set to the associated pair.
*   If _eval_ fails the line is skipped.  Otherwise returns a new pair
*   to be entered in the input seq.

reader

    differ(filename) input(.file,g.channel.temp,filename):s(reader.opened)
    out('unable to open reader file ' filename '.') :(freturn)

reader.opened

    reader = map(1024)

reader.next

    setl4..add(map, (ident(filename) input, file)) :f(reader.eof)s(reader.next)

reader.eof

*   Here at end of file; close temporary file if one was needed.

    differ(filename) endfile(g.channel.temp)        :(return)

reader.end

    define('readerstr(str,delim)line')         :(reader..end)

*   Returns a sequence of the lines in _str_,
*   where the delimiter character _delim_ is used to mark
*   the end of a line. One intended use of _readerstr_
*   is to assist in the construction of test programs.

readerstr

    delim = ident(delim) '/'
    readerstr = setl4..seq()

reader.l.next

    str break(delim) . line delim =                 :f(return)
    add(readerstr,line)                        :(reader.l.next)

reader..end

*    define('set(str)')              :(set.end)
*
**   Returns setl4str of characters in str _str_.
*
*set
*
*    str = setl4str(size(str))
*    loop(str)
*
*set.next
*
*    next(set)                   :f(return)
*    setl4..add(set,next(set))                :(set.next)
*
*set.end

    define('slice(str,first,last)')             :(slice.end)

slice

    slice = substr(str,first,last)              :(return)

slice.end


    define('split(str)word')                  :(split.end)

*   Returns sequence of the words in stirng _str_.
*   Words are separated by whitespace: one of more consecuture spaces
*   or tabs.

split

    split = new('seq')
    line =  line ' '

split.next

    line break(' ') . word ' ' =                    :f(return)
    set.add(split,word)                             :(split.next)

split.end

*   Tokens: Lexical Scanning
*   ------------------------


*   A token is represented as an instance of the datatype _token_ as follows:

    data('token(lineno,ndx,type,text)')

*   where:
*           _lineno_        is the line number within the file;
*           _ndx_           is the index of the first character of the
*                           token in the line;
*           _type_          is the token's type, as described below; and
*           _text_          is the text of the token.

*   The type is represented by a single character, as follows:

*           'c'             comment, indicated by asterisk (*) in the first column.
*                           The text consists of the entire line.

*           'i'             integer, consisting of one or more digits ('0123456789')

*           'l'             left opener, one of '(<[{'

*           'p'             punctation, one of '.;,?!', or single quote ('),
*                           or double quote ("),

*           'o'             other printable character, one of '~@#$%^&*_-+=`'.

*            'q'            quoted str, starting witn '"', and continuing
*                           to the next instance of the opening quote character.

*           'r'             right closer, one of ')>]}'

*           's'             space, consistine of one or more spaces (spaces)

*           't'             tab character

*           'u'             unprintable character, for example control-k

*           'w'             word, consisting of one of more letters in
*                           upper or lower case or "'" or "_".

*   The longest possible str meeting the rules is used when building a token.
*   For example, 'abc' is just the word 'abc', not 'a' followed by 'bc', and so forth.

*   It is recommended that the tab character NOT be used as an abbreviation for
*   one or more spaces in the input file. If tabs are used, then _pos_ is ill-defined.
*   If tabs are not used, then _pos_ indicates the true position in the line of
*   the first character of the token, and so error messages and references to the
*   token will be exact.  For example, _pos_ could be used to indicate where to give
*   emphasis to a token by underlining it, or enclosing it in '_' to generate
*   markdown format, and so forth.

    define('tokens(line)type,pos,text,lineno')  :(tokens.end)

*   Strtokens scans _line_ and returns a table of the tokens in the line.
*   The table has keys from 1..n, where _n_ is the number of tokens found.

*   This function is an instance of what is called a lexiical scanner, or tokenizer,
*   which is the first stage in a programming language compiler, or for any program
*   that processes text files with a specified structure.

tokens

    tokens = setl4..seq()
    line '*'                                        :f(tokenl.next)
    type = 'c'
    text = line
    line =                                          :(tokenl.new)

tokenl.next

    line ' '                                        :s(tokens.space)
    line any('0123456789')                          :s(tokens.integer)
    line any('(<[{')                                :s(tokenl.left)
    line any('.;,?!')                               :s(tokens.punctuation)
    line '"'                                        :s(tokens.quote)
    line any('~@#$%^&*_-+=')                                        :s(tokens.other)
    line any(')>]}')                                :s(tokens.right)
    line char(9)                                    :s(tokens.tab)
    line any(&lcase &ucase)                         :s(tokens.word)

*   Here for unprintable
                                                    :(tokens.unprintable)

tokens.integer

    type = 'i'
    line span('0123456789') . text =                :(tokenl.new)

tokens.punctuation

    type = 'p'                                       :(tokens.character)

tokens.other

    type = 'o'                                      :(tokens.character)

*tokens.other

    type = 'o'                                      :(tokens.character)

tokens.quote

    type = 'q'
    line '"' break('"') . text '"' =
    text = '"' text '"'                             :(tokenl.new)

tokens.right

    type = 'r'                                      :(tokens.character)

tokens.space

    type = 's'
    line span(' ')  . text =                        :(tokenl.new)

tokens.tab

    type = 't'                                      :(tokens.character)

tokens.word

*FIX*
    type = 'w'
    line span(&ucase &lcase "_" "'") . text =       :(tokenl.new)

tokens.character

*   Here if token is single character.

    line len(1) . text                              :(tokenl.new)

tokenl.new

    setl4..add(tokens,token(lineno,pos,type,text)) :(tokenl.next)

tokens.end

    define('upper(s)')                          :(upper.end)

*   Convert argument to upper case.

upper

    upper = replace(s,&lcase,&ucase)            :(return)

upper.end

    define('writer(lines)')                    :(writer.end)

*   Writes the lines in the sequence _lines_ to standard output.

writer

    loop(lines)

writer.next

    output = set.next(lines)                        :f(return)s(writer.next)

writer.end
